<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张志成博客</title>
  
  
  <link href="https://793338023.github.io/atom.xml" rel="self"/>
  
  <link href="https://793338023.github.io/"/>
  <updated>2020-09-19T06:51:11.475Z</updated>
  <id>https://793338023.github.io/</id>
  
  <author>
    <name>zhangzhicheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http第三篇</title>
    <link href="https://793338023.github.io/2020/09/14/http%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
    <id>https://793338023.github.io/2020/09/14/http%E7%AC%AC%E4%B8%89%E7%AF%87/</id>
    <published>2020-09-14T15:50:36.000Z</published>
    <updated>2020-09-19T06:51:11.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="MIME-type"><a href="#MIME-type" class="headerlink" title="MIME type"></a>MIME type</h3><p>数据类型表示实体数据的内容是什么，使用的是 <code>MIME type</code>，相关的头字段是 Accept 和 Content-Type；</p><p>Accept 字段标记的是客户端可理解的 <code>MIME type</code></p><p>相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型</p><p>有了 <code>MIME type</code> 和 Encoding type，无论是浏览器还是服务器就都可以轻松识别出 body 的类型，也就能够正确处理数据了。</p><p>以为为常见的<code>MIME type</code>:</p><ol><li><p>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</p></li><li><p>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</p></li><li><p>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</p></li><li><p>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，需要客户端猜的，就会是 application/octet-stream，即不透明的二进制数据。</p></li></ol><h3 id="Encoding-type"><a href="#Encoding-type" class="headerlink" title="Encoding type"></a>Encoding type</h3><p>数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；</p><p>常用的只有下面三种：</p><ol><li><p>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</p></li><li><p>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</p></li><li><p>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</p></li></ol><h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p>当传输大内容时使用只使用一次的请求应答模式会导致响应时间过长，这是很影响性能的，那么如何处理这样的问题呢？</p><p>那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。</p><p>这种“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块逐个发送。</p><p>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。</p><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>如果使用范围请求，需要服务器在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。</p><p>如果已经确定双端都支持范围请求，我们就可以在请求资源的时候使用它。</p><p>HTTP/1.1 中定义了一个 Ranges 的请求头，来指定请求实体的范围。它的范围取值是在 <code>0 - Content-Length</code> 之间，使用 <code>-</code> 分割。。</p><p>服务器收到 Range 字段后，需要做以下操作：</p><ol><li><p>它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。</p></li><li><p>如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</p></li><li><p>服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</p></li></ol><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”，每次的传输内容都会带上 cookie 信息，所以尽量不要让自己服务器以外的人看到。</p><p>为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 、SameSite 等。</p><p>Cookie 最基本的一个用途就是身份识别，保存用户的登录信息，实现会话事务。</p><p>比如，你用账号和密码登录某电商，登录成功后网站服务器就会发给浏览器一个 Cookie，内容大概是“name=yourid”，这样就成功地把身份标签贴在了你身上，实现了“状态保持”。</p><p>Cookie 的另一个常见用途是广告跟踪。</p><p>你上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站（例如 Google），它会“偷偷地”给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。</p><p>这种 Cookie 不是由访问的主站存储的，所以又叫“第三方 Cookie”。如果广告商势力很大，广告到处都是，那么就比较“恐怖”了，无论你走到哪里它都会通过 Cookie 认出你来，实现广告“精准打击”，但也是最容易泄露隐私。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>因为 http 的不安全性，才有 https 的出现。</p><p>通信安全必须同时具备机密性、完整性、身份认证和不可否认这四个特性，而 https 为 HTTP 增加了这四大安全特性。</p><p>HTTPS 默认端口号是 <code>443</code>，除了协议名“http”和端口号 <code>80</code> 这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。</p><p>HTTPS 与 HTTP 最大的区别，它能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、篡改或者“钓鱼”、伪造。</p><p>而 HTTPS 把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，让 HTTP 运行在了安全的 SSL/TLS 协议上，其实就是在 TCP/IP 与 HTTP 之间添加一层 SSL/TLS。</p><h2 id="HTTP2-3"><a href="#HTTP2-3" class="headerlink" title="HTTP2/3"></a>HTTP2/3</h2><h3 id="阐述"><a href="#阐述" class="headerlink" title="阐述"></a>阐述</h3><p>当 HTTP 到 HTTPS 后，在安全上已经有保障了，但本来性能一般般的 HTTP 又加上一层处理，变得更加重，在性能上有所损耗，那么成熟后的 HTTPS 已经在性能暴露了问题，那么只能对其性能方面下手，所以就出现后续的 HTTP2/3。</p><p>而为什么 HTTP 在后续的版本再也没有出现过小版本？</p><p>以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号，只使用大版本号，从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”。</p><p>这样就可以明确无误地辨别出协议版本的“跃进程度”，让协议在一段较长的时期内保持稳定，每当发布新版本的 HTTP 协议都会有本质的不同，绝不会有“零敲碎打”的小改良。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>保持功能上的兼容，完全兼容 HTTP1，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。</p><p>特别要说的是，与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。</p><p>可以让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。</p><p>但 HTTP/2 的内容对于 HTTP/1 有着“天翻地覆”的改造</p><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>由于 HTTP1 没有针对头部的优化手段，头部还有优化的空间，不过 HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。</p><h4 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h4><p>相对于 HTTP/1 里纯文本形式的报文，HTTP/2 采用二进制格式</p><p>二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。</p><h4 id="虚拟的“流”"><a href="#虚拟的“流”" class="headerlink" title="虚拟的“流”"></a>虚拟的“流”</h4><p>HTTP/2 为此定义了一个“流”的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</p><p>因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”——多个往返通信都复用一个连接来处理。</p><p>在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>多路复用多个请求没有顺序，而长连接多个请求必须排队，就会队头阻塞。</p><p>http 协议要求请求-响应必须一来一回，上一个请求没有处理完，下一个请求是不能发出去的。一个 tcp 连接上的 http 请求必然是串行。</p><p>管道模式可以顺序发出多个请求，但响应也必须顺序响应。这些都是 http/1.1 里规定的。</p><p>再对比 http/2，一个 tcp 连接里有多个流，每个流就是一个请求，所以多个请求可以并发，“复用”在了一个连接里。</p><h3 id="http-3"><a href="#http-3" class="headerlink" title="http/3"></a>http/3</h3><p>HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</p><p>由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。</p><p>Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。</p><p>QUIC 选择使用 UDP 为基础，因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。</p><p>QUIC 在 UDP 上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。</p><p>QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。</p><h2 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h2><p>其实 WebSocket 与 HTTP/2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的。HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。</p><p>“请求 - 应答”是一种“半双工”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。</p><p>“请求 - 应答”模式，导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域。</p><p>为了克服 HTTP“请求 - 应答”模式的缺点，WebSocket 就“应运而生”了。</p><p>WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，而不用像 HTTP“你拍一，我拍一”那么“客套”。于是，服务器就可以变得更加“主动”了。一旦后台有新的数据，就可以立即“推送”给客户端，不需要客户端轮询，“实时通信”的效率也就提高了。</p><p>WebSocket 使用兼容 HTTP 的 URI 来发现服务，但定义了新的协议名“ws”和“wss”，端口号也沿用了 80 和 443；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>http/1 请求-应答都是有序并且每次都需要建立连接，而后 http/1.1 出现长连接与管道模式可以让连接维持不断并且多个请求有序的同时发送等待响应，但响应部分还是需要排队等待一个一个返回，而 HTTP/2 出现就是主要是压缩头部信息与数据格式从文本改为二进制，让数据的体积变小，而且让应用层上连接的有序变为无序，解决了连接层上队头阻塞，而 HTTP/3 的出现主要解决了 TCP 的传输层上队头阻塞问题，把 TCP 换为 UDP 无序的、包之间没有依赖更快传输协议，并改造为可靠的传输协议。</p><p>而使用 HTTP2/3 就没有必要使用精灵图、多个请求合并的操作，因为这些技术出现都是为了解决对头阻塞导致的请求响应慢的问题，而且还不能很好的使用 HTTP 的缓存机制，在 HTTP2/3 中这些技术反而会拖慢请求响应的速度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;h3 id=&quot;MIME-type&quot;&gt;&lt;a href=&quot;#MIME-type&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="http" scheme="https://793338023.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http第二篇</title>
    <link href="https://793338023.github.io/2020/09/10/http%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
    <id>https://793338023.github.io/2020/09/10/http%E7%AC%AC%E4%BA%8C%E7%AF%87/</id>
    <published>2020-09-10T14:59:52.000Z</published>
    <updated>2020-09-13T16:01:19.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>HTTP 是基于 TCP/IP 的，那么传输的事情应该是 TCP/IP 完成的，那么 HTTP 称为超文本传输协议是不是有点不妥了，因为它不负责传输，那这个传输又是怎么回事，答案就在它的传输的报文内容，HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略。</p><p>HTTP 协议是一个“纯文本”的协议，而 HTTP2/3 后就是二进制协议，http/1 纯文本的好处是方便易读，对人类友好，而 http/2 正相反，易于机器解析。</p><p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ol><li><p>起始行（start line）：描述请求或响应的基本信息；</p></li><li><p>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</p></li><li><p>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</p></li></ol><p>通俗的理解就是“header+body”。</p><p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p><p>这个使用 fiddler 抓取 HTTP 包就能看得出来，如:</p><ul><li>请求报文:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST https://array701.prod.do.dsp.mp.microsoft.com/join/ HTTP/1.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Microsoft-Delivery-Optimization/10.0</span><br><span class="line">MS-CV: edXwuc8Ok0mKLY9H.1.2.3.1.7.2.6.1.10</span><br><span class="line">Content-Length: 682</span><br><span class="line">Host: array701.prod.do.dsp.mp.microsoft.com</span><br><span class="line"></span><br><span class="line">&#123;&quot;ContentId&quot;:&quot;d91f96082d4a8db9f1bdccaeb06a29cb6c1341b7&quot;,&quot;AltCatalogId&quot;:&quot;http://11.au.download.windowsupdate.com/d/msdownload/update/software/secu/2020/08/windows10.0-kb4576484-x64-ndp48_d91f96082d4a8db9f1bdccaeb06a29cb6c1341b7.cab&quot;,&quot;PeerId&quot;:&quot;2614138130a28042b021b5b0c0add9c400000000&quot;,&quot;ReportedIp&quot;:&quot;192.168.1.54&quot;,&quot;SubnetMask&quot;:&quot;255.255.255.0&quot;,&quot;Ipv6&quot;:&quot;&quot;,&quot;IsBackground&quot;:&quot;1&quot;,&quot;ClientCompactVersion&quot;:&quot;10.0.18362.959&quot;,&quot;Uploaded&quot;:&quot;0&quot;,&quot;Downloaded&quot;:&quot;8388608&quot;,&quot;DownloadedCdn&quot;:&quot;8388608&quot;,&quot;DownloadedDoinc&quot;:&quot;0&quot;,&quot;Left&quot;:&quot;0&quot;,&quot;JoinRequestEvent&quot;:&quot;3&quot;,&quot;RestrictedUpload&quot;:&quot;0&quot;,&quot;PeersWanted&quot;:&quot;50&quot;,&quot;GroupId&quot;:&quot;&quot;,&quot;Scope&quot;:&quot;2&quot;,&quot;UploadedBPS&quot;:&quot;0&quot;,&quot;DownloadedBPS&quot;:&quot;0&quot;,&quot;Profile&quot;:&quot;0&quot;,&quot;ConnAttempts&quot;:&quot;1:96;&quot;,&quot;Seq&quot;:&quot;9&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>响应报文:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Server: Microsoft-IIS/10.0</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">X-AspNet-Version: 4.0.30319</span><br><span class="line">X-Powered-By: ASP.NET</span><br><span class="line">Date: Thu, 10 Sep 2020 16:04:09 GMT</span><br><span class="line">Content-Length: 287</span><br><span class="line"></span><br><span class="line">&#123;&quot;FailureReason&quot;:null,&quot;NextJoinTimeIntervalInMs&quot;:231680,&quot;Complete&quot;:0,&quot;Incomplete&quot;:0,&quot;Rediscover&quot;:false,&quot;KVVersion&quot;:&quot;1E81C22A406C2F10A31B4149E8C96946EB35AD4CA26974B2145E165F2762B22B&quot;,&quot;GeoVersion&quot;:&quot;E6B6DF02CFC90F2720E5594DF177BA33ABDAE4CCBA432D08DDEAD11123552399&quot;,&quot;Peers&quot;:[],&quot;Leave&quot;:false&#125;</span><br></pre></td></tr></table></figure><p>报文头与报文体之间有一行空行</p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行就是起始行</p><p>它简要地描述了客户端想要如何操作服务器端的资源。</p><p>三部分构成：</p><ol><li><p>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</p></li><li><p>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</p></li><li><p>版本号：表示报文使用的 HTTP 协议版本。</p></li></ol><p>这三个部分通常使用空格来分隔，最后要用 CRLF 换行表示结束。</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST https://array701.prod.do.dsp.mp.microsoft.com/join/ HTTP/1.1</span><br></pre></td></tr></table></figure><p>请求方法为<code>POST</code>，请求目标为<code>https://array701.prod.do.dsp.mp.microsoft.com/join/</code>，版本号为<code>HTTP/1.1</code></p><p>而响应的起始行就是状态行</p><p>也是由三部分构成:</p><ol><li><p>版本号：表示报文使用的 HTTP 协议版本；</p></li><li><p>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</p></li><li><p>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</p></li></ol><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><p>版本号为<code>HTTP/1.1</code>,状态码<code>200</code>,原因<code>OK</code></p><h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><p>请求头和响应头的结构是基本一样的，唯一的区别是起始行</p><p>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束</p><p>HTTP 头字段非常灵活可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能</p><p>不过使用头字段需要注意下面几点：</p><ol><li><p>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</p></li><li><p>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</p></li><li><p>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</p></li><li><p>字段的顺序是没有意义的，可以任意排列不影响语义；</p></li><li><p>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</p></li></ol><p>HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。</p><h2 id="标准请求方法"><a href="#标准请求方法" class="headerlink" title="标准请求方法"></a>标准请求方法</h2><p>目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式</p><ol><li><p>GET：获取资源，可以理解为读取或者下载数据；</p></li><li><p>HEAD：获取资源的元信息；</p></li><li><p>POST：向资源提交数据，相当于写入或上传数据；</p></li><li><p>PUT：类似 POST；</p></li><li><p>DELETE：删除资源；</p></li><li><p>CONNECT：建立特殊的连接隧道；</p></li><li><p>OPTIONS：列出可对资源实行的方法；</p></li><li><p>TRACE：追踪请求 - 响应的传输路径。</p></li></ol><p>请求方法是客户端发出的、要求服务器执行的、对资源的一种操作;<br>请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；<br>最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据；</p><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3><p>1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</p><h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3><p>2×× 类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。</p><p>“200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果</p><h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3><p>3×× 类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。</p><p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</p><p>“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”</p><p>301、302 和 304 分别涉及了 HTTP 协议里重要的“重定向跳转”和“缓存控制”</p><h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3><p>4×× 类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。</p><ul><li><p>“400 Bad Request”是一个通用的错误码，表示请求报文有错误</p></li><li><p>“403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。</p></li><li><p>“404 Not Found”、资源在本服务器上未找到，所以无法提供给客户端。</p></li><li><p>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</p></li></ul><h3 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h3><p>5×× 类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。</p><h2 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h2><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。</p><h3 id="灵活可扩展"><a href="#灵活可扩展" class="headerlink" title="灵活可扩展"></a>灵活可扩展</h3><p>HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</p><p>同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。</p><p>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</p><h3 id="应用广泛和跨平台"><a href="#应用广泛和跨平台" class="headerlink" title="应用广泛和跨平台"></a>应用广泛和跨平台</h3><p>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。</p><p>而无状态这个特性在不同的场景，体现出现的价值不一样，是一把双刃剑。</p><ul><li><p>好处:<br>如在不需要客户端或者服务器里保存的一些数据或者标志来记录通信过程中的一些变化信息时，可以减轻服务器的负担，提高性能。</p></li><li><p>坏处:<br>如果需要知道每次操作的请求是不是同一个人时需要记录一些数据，那么要完成这个关联性的操作时会非常麻烦，因为每个请求都是独立的。</p></li></ul><p>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p><ul><li>解决方法<br>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。</li></ul><p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了，</p><h3 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h3><p>明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</p><p>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。</p><h3 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h3><p>HTTP 比较严重的缺点就是不安全：</p><ol><li>通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。</li><li>不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。</li><li>无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。</li></ol><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><h4 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h4><p>HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。</p><p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p><p>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</p><h4 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h4><p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。</p><p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班坐公交车和别的公交车并行行驶，但驶入公交站时大家串行排队等待前面的车辆的人下完后驶出才到你坐的公交车驶入站下车。</p><p>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;报文结构&quot;&gt;&lt;a href=&quot;#报文结构&quot; class=&quot;headerlink&quot; title=&quot;报文结构&quot;&gt;&lt;/a&gt;报文结构&lt;/h2&gt;&lt;p&gt;HTTP 是基于 TCP/IP 的，那么传输的事情应该是 TCP/IP 完成的，那么 HTTP 称为超文本传输协议是不是有点</summary>
      
    
    
    
    
    <category term="http" scheme="https://793338023.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http第一篇</title>
    <link href="https://793338023.github.io/2020/09/06/http%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>https://793338023.github.io/2020/09/06/http%E7%AC%AC%E4%B8%80%E7%AF%87/</id>
    <published>2020-09-06T11:18:47.000Z</published>
    <updated>2020-09-19T07:55:39.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-简史"><a href="#http-简史" class="headerlink" title="http 简史"></a>http 简史</h2><ol><li><p>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；</p></li><li><p>HTTP/0.9 是个简单的文本协议，只能获取文本资源；</p></li><li><p>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；</p></li><li><p>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；</p></li><li><p>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</p></li><li><p>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</p></li></ol><h2 id="http-是什么"><a href="#http-是什么" class="headerlink" title="http 是什么"></a>http 是什么</h2><p>HTTP 是超文本传输协议</p><p>HTTP 的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li>超文本</li><li>传输</li><li>协议</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="HTTP三部分.png" alt="HTTP三部分" title="">                </div>                <div class="image-caption">HTTP三部分</div>            </figure><h3 id="协议是什么"><a href="#协议是什么" class="headerlink" title="协议是什么"></a>协议是什么</h3><p>协议是指两个或两个以上实体为了开展某项活动，经过协商后双方达成的一致意见。协议在法律上是合同的同义词。合同是当事人或当事双方之间设立、变更、终止民事关系的协议。</p><p>而协议必须要有两个或多个参与者，为了保证最基本的顺畅交流与对参与者的一种行为约定和规范。</p><p>例如，为了保证你顺利就业，“三方协议”里的参与者有三个：你、公司和学校；为了保证你顺利入住，“租房协议”里的参与者有两个：你和房东。</p><p>而有多个参与者并能正常交流还是不够的，还需要达成某个共同的目的而站在了一起，那么必须明确地规定各方的“责、权、利”，约定该做什么不该做什么，先做什么后做什么，做错了怎么办，有没有补救措施等等。例如，“租房协议”里就约定了，租期多少个月，每月租金多少，押金是多少，水电费谁来付，违约应如何处理等等。</p><p>而 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</p><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>HTTP 是一个传输协议，就是传输的过程中都需要遵循这个协议，而传输就是字面上的意思，把一堆东西从 A 点传到 B 点，或者 B 点传到 A 点，但 A、B 两点之间是否还有其他的点进行传输那它就没有限制,允许有<code>中转或接力</code>，就像运动会上接力棒比赛一样，起点、终点规定有多少人是不限的，但要遵循比赛规则，而且还可以 A 到 B，然后 B 到 A，可以知道它是一个<code>双向的协议</code>。</p><p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。</p><p>HTTP 是一个在计算机世界里专门用来在<code>两点之间传输数据</code>的约定和规范。</p><p><strong>注意是两点之间，是不限制你在服务器还是客户端</strong></p><h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p><p>再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p><p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p><h3 id="超文本传输协议"><a href="#超文本传输协议" class="headerlink" title="超文本传输协议"></a>超文本传输协议</h3><p>使用一句话表达<code>超文本传输协议</code></p><p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p><h2 id="HTTP-的概念"><a href="#HTTP-的概念" class="headerlink" title="HTTP 的概念"></a>HTTP 的概念</h2><p>在互联网世界里 HTTP 是最常见的也是最普遍的，当然还有其实的各自的专有协议，如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等</p><p>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。</p><p>综合起来看，现在的互联网 90% 以上的部分都被 HTTP 所覆盖，所以把互联网约等于 HTTP 应该也不算大错。</p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器的正式名字叫“Web Browser”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。</p><p>万维网，它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p><p>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。</p><p>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求，通常称之为“客户端”。</p><h4 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h4><p>Web 服务器是协议另一端的应答方（响应方）</p><p>而 Web 服务器一般都是 Apache、Nginx、IIS、Jetty/Tomcat 等</p><p>Nginx 使用的最普遍，特点是高性能、高稳定，且易于扩展。</p><h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><p>它也是一种用户代理，代替我们访问互联网</p><p>而无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML。</p><h2 id="HTTP-相关的协议"><a href="#HTTP-相关的协议" class="headerlink" title="HTTP 相关的协议"></a>HTTP 相关的协议</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。可以对比一下现实中的电话系统，你拿着的手机相当于互联网上的计算机，而要打电话就必须接入电话网，由通信公司给你分配一个号码，这个号码就相当于 IP 地址。</p><p>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但已经被分配完了。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，但 v6 没有考虑向下兼容的问题，所以完全代替 v4 版本是不可能的，而且 NAT 的出现也在一定程度上解决 v4 版本不足的问题。</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</p><p>可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p><p>而互联网上的 HTTP 协议就运行在了 TCP/IP 上</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>IP 地址来标识计算机，对于人类来说难以记住，于是就有了“域名系统”，用有意义的名字来代替 IP 地址。</p><p>但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。</p><p>但能域名解析的服务器很多，而且会出现层级关系，逐层递归地实现域名查询，因此域名解析也会很耗时，所以出现 DNS 缓存。</p><p>而我们的本地就有一个特殊的“主机映射”文件，<code>C:\WINDOWS\system32\drivers\etc\hosts</code>,在缓存里找不到 DNS 记录，就会找这个文件。</p><p>使用域名，我们可以很简单的实现 IP 地址任意变动，可以基于域名实现的负载均衡，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡，域名解析也可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡</p><p>但不怀好意的人可以在域名这方面“做手脚“</p><ul><li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li><li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li></ul><p>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</p><p>代理有很多的种类，常见的有：</p><ol><li><p>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</p></li><li><p>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</p></li><li><p>正向代理：靠近客户端，代表客户端向服务器发送请求；</p></li><li><p>反向代理：靠近服务器端，代表服务器响应客户端的请求；</p></li></ol><p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</p><ol><li><p>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</p></li><li><p>内容缓存：暂存上下行的数据，减轻后端的压力；</p></li><li><p>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</p></li><li><p>数据处理：提供压缩、加密等额外的功能。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;http-简史&quot;&gt;&lt;a href=&quot;#http-简史&quot; class=&quot;headerlink&quot; title=&quot;http 简史&quot;&gt;&lt;/a&gt;http 简史&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="http" scheme="https://793338023.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>探讨react的核心原理</title>
    <link href="https://793338023.github.io/2020/07/19/%E6%8E%A2%E8%AE%A8react%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>https://793338023.github.io/2020/07/19/%E6%8E%A2%E8%AE%A8react%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</id>
    <published>2020-07-19T15:46:40.000Z</published>
    <updated>2020-07-19T15:53:18.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-核心"><a href="#React-核心" class="headerlink" title="React 核心"></a>React 核心</h2><p>而前三个就可以实现一个简单版 React，最后一个 Fiber 为 React 核心数据结构</p><ul><li>React.createElement：创建虚拟 DOM</li><li>React.Component：实现⾃定义组件</li><li>ReactDOM.render：渲染真实 DOM</li><li>Fiber 核心数据结构</li></ul><h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p>React 会把 jsx 语法经过 babel 转译成 React.createElement，所以当使用 jsx 时识别到的标签都会转译。<br>如:</p><p>jsx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &lt;div&gt;123&lt;/div&gt;;</span><br></pre></td></tr></table></figure><p>转译后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    __self: <span class="literal">undefined</span>,</span><br><span class="line">    __source: &#123;</span><br><span class="line">      fileName: _jsxFileName,</span><br><span class="line">      lineNumber: <span class="number">7</span>,</span><br><span class="line">      columnNumber: <span class="number">13</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"123"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// __source,__self 属性是开发环境时调式使用的，在生成环境时不会存在。</span></span><br></pre></td></tr></table></figure><h4 id="createElement-参数"><a href="#createElement-参数" class="headerlink" title="createElement 参数"></a>createElement 参数</h4><ul><li>第一参数为标签名，如果是自定标签，那么就是组件的变量如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = React.createElement(App, &#123;&#125;, <span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure><ul><li>第二参数为标签上的属性，如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = &lt;App name="10"&gt;xxx&lt;/App&gt;;</span><br><span class="line"><span class="comment">//转换后</span></span><br><span class="line"><span class="keyword">const</span> Test = React.createElement(App, &#123; <span class="attr">name</span>: <span class="string">"10"</span> &#125;, <span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure><ul><li>第三个之后包括第三个，都是 chlidren</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;App name="10" /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/转换后</span></span><br><span class="line"><span class="regexp">const Test = React.createElement(</span></span><br><span class="line"><span class="regexp">  "div",</span></span><br><span class="line"><span class="regexp">  &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  React.createElement("div", &#123;&#125;, "123"),</span></span><br><span class="line"><span class="regexp">  React.createElement(App, &#123; name: "10" &#125;)</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>render 会根据 createElement 返回的数据结构(虚拟 DOM)遍历生成真实 DOM 节点，而自定义标签组件会根据是否为 class 组件或函数组件获取 createElement 返回的数据结构，而函数组件的当前函数就是 jsx 数据，而 class 组件是从 render 方法上获取 jsx 数据。</p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>我们写 class 组件，都需要继承 React.Component，而 Component 主要是包含了一个 class 需要属性与方法</p><p>方法有:</p><ol><li>setState</li><li>forceUpdate</li></ol><p>而这两个方法的目的都是更新 state 的，只是一个正常的更新 state 数据，setState 会被 shouldComponentUpdate 优化更新拦截更新视图，而 forceUpdate 则不会，因为它是直接跳过更新视图的，所以当我们的数据没有走 setState 更新 state 时，而是直接更新 state 或自己定义的状态对象那么可以使用 forceUpdate 直接渲染视图达到更新视图的效果，如 antd 的 form 就是使用 forceUpdate 更新数据的，由于无法使用 shouldComponentUpdate 优化，表单过大的渲染量大导致操作一项更新所有表单项很消耗性能，会出现卡顿的现象。</p><p>属性有:</p><ol><li>props</li><li>context</li><li>refs</li><li>updater</li></ol><p>props 与 context 略过，就是状态</p><p>refs 是 class 组件上的让我们存储组件上 ref 值的</p><p>updater 才是重点，因为状态的更新就在这里实现，每个组件都有一个更新对象，而里面只实现了更新需要的方法，真正需要更新的数据都存储在 fiber 里面</p><p>那么我们在写组件时就会带上默认的属性与方法</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>render 用于将 React 渲染的虚拟 DOM 渲染到浏览器 DOM，一般在顶层组件使用。该方法把元素挂载到 container 中，并且返回 element 的实例（即 refs 引用），如果是函数组件，render 会返回 null。当组件装载完毕时，callback 就会被调用。其语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(ReactElement element,DOMElement container,[<span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><p>React diff 三大策略</p><ol><li>策略一（tree diff）：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。（DOM 结构发生改变—–直接卸载并重新加载组件）</li><li>策略二（component diff）：DOM 结构一样—–不会卸载,但是会 update</li><li>策略三（key diff）：比较节点的 key 值，通过 key 来区分重载与更新—–同时遵循 1.2 两点</li></ol><h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p>fiber 其实可以理解为虚拟 DOM，因为 createElement 创建的虚拟 DOM 会对应到 fiber 上，而 DOM 上更新是根据 fiber 的信息，比如 diff 比较。</p><p>进行 render 后会把 createElement 的数据转换成 Fiber 数据结构</p><p>fiber 最大的好处是可暂定可恢复，让 React 实现让出机制，时间分片，使用的 API requestIdleCallback:</p><p>React 已经内部实现了 requestIdleCallback，不使用 requestIdleCallback API</p><p><strong><a href="https://793338023.github.io/2020/04/28/React16-fiber/">React16/fiber</a></strong></p><h2 id="js-事件循环机制"><a href="#js-事件循环机制" class="headerlink" title="js 事件循环机制"></a>js 事件循环机制</h2><p>我理解的同步异步，是进入主线程的为同步，进行事件队列的为异步，简单的说就是任务在没有进入主线程即为异步</p><p>而会进入事件队列里的大概有如下:</p><ol><li>浏览器事件：window.load、document.DomContentLoaded 等</li><li>网络请求事件:ajax、websocket</li><li>用户事件:单双击、鼠标滚动、调整页面大小等</li><li>计时器事件：setTimeout,setInterval 等</li><li>延迟对象或在某个阶段才触发的浏览器 API，Promise、requestIdleCallback、requestAnimationFrame 等</li></ol><p>事件队列分为宏任务的事件队列与微任务的事件队列</p><p>宏任务：setTimeout，setInterval，setImmediate，requestAnimationFrame，I / O，UI 呈现，js 初始执行代码等<br>微任务：Promise，Object.observe，MutationObserver</p><p>js 引擎的执行机制是执行把一个宏任务放入主线程上执行，当这个宏任务结束后执行当前的整个微任务队列，然后交出线程让 GUI 渲染线程接管，执行界面上渲染，如解析 DOM 树、css 树之类的，就是做视觉上的工作</p><p>而首次执行的代码也是属于宏任务的，所以整个 js 执行机制，可以理解为事件循环机制，但我们不使用会进入事件队列的 API，那么整个代码执行的过程都是在主线程上，因为整个代码都是一个宏任务</p><p>而 js 引擎线程与 GUI 渲染线程是互斥的</p><h3 id="为什么-React-15-会出现卡顿"><a href="#为什么-React-15-会出现卡顿" class="headerlink" title="为什么 React 15 会出现卡顿"></a>为什么 React 15 会出现卡顿</h3><p>在 React 没有使用 Fiber 进行重构之前，React 实现的代码是没有使用能进入事件队列的 API 的，所以我们使用 React 实现的功能就是一个宏任务，当这个宏任务代码量与计算量庞大时，就会让 GUI 渲染无法执行，导致到了该渲染时无法渲染。</p><p>而 React 重构后加入了时间分片的原理，实现方式是使用了 requestIdleCallback 的原理，React 没有直接使用 requestIdleCallback，因为它有兼容性问题</p><p>而我们常说 React 的 setState 使用异步更新，这是因为在代码执行上的效果如异步操作，不会立即更新状态的值，而它的事件原理是进行 setState 时不会立即赋值到 state 上而会进行一轮的状态收集,即进入更新队列里,并且更新队列里的状态改为等待中,当收集完毕后改变状态为完成,并进行 state 更新与 render 渲染内容,但进入事件队列里的方法内的 setState 的状态就无法收集,因为更新流程是在主线程执行的，而事件队列是要等主线程执行完毕后才进行执行的，那么当前的更新队列里的状态已经为完成了,所以异步内的 setState 为同步更新,因为 setState 后获取 state 就是当前的 setState 后的状态,如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; <span class="attr">a</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    a: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.a); <span class="comment">// 0</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">3</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.a); <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">4</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.a); <span class="comment">// 4</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div onClick=&#123;this.click&#125;&gt;&#123;this.state.a&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 的事件是合成事件，不是原生的事件，内部已经实现了状态更新过程的状态收集</p><p><strong><a href="https://github.com/793338023/react-base" target="_blank" rel="noopener">github 项目</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;React-核心&quot;&gt;&lt;a href=&quot;#React-核心&quot; class=&quot;headerlink&quot; title=&quot;React 核心&quot;&gt;&lt;/a&gt;React 核心&lt;/h2&gt;&lt;p&gt;而前三个就可以实现一个简单版 React，最后一个 Fiber 为 React 核心数据结构</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>redux中间件原理</title>
    <link href="https://793338023.github.io/2020/06/01/redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://793338023.github.io/2020/06/01/redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-01T15:17:20.000Z</published>
    <updated>2020-09-19T07:59:27.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>redux 中间件设计的代码，简洁到极致，它的代码量很少，但却满足 redux 设计中间件的要求，柯里化的特性也在这里完美的体现。</p><h2 id="涉及的代码"><a href="#涉及的代码" class="headerlink" title="涉及的代码"></a>涉及的代码</h2><p>createStore.ts、compose.ts、applyMiddleware.ts</p><p>createStore 所有 store 集中所在，这里包括了监听变化，数据存储、替换 reducer、中间件等处理逻辑。</p><p>compose 使用数组 reduce 的特性，让数组内的函数从左到右层层向内嵌套，并使用柯里化，把真实的 args 实参传递给最里面的函数。</p><p>applyMiddleware 给每一层的中间件函数传递 getState 与改造的 dispatch，而真实的 dispatch 使用 compose 传递给最里面一层的中间件，其他层的 dispatch 都是使用 compose 的第二调用的函数，因此中间件的要使用多层函数而最里层的函数接受 compose 的第三调用的函数的入参，既 action 数据。</p><h2 id="compose-实现"><a href="#compose-实现" class="headerlink" title="compose 实现"></a>compose 实现</h2><p>在 redux 中 compose 的实现很简洁，但又比较难吃透，因为对数组的 reduce 与闭包结合的理解不够</p><p>以下为它的源码:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs: <span class="built_in">Function</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args: <span class="built_in">any</span>) =&gt; a(b(...args)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一次调用 compose 时，compose 接受多个函数形参，使用扩展扩展运算符获取把所有函数入参以数组的形式获取到，然后当函数个数为 0 时返回一个空数组，当函数个数为 1 时直接返回当前函数，而大于 1 时，使用 reduce 累计函数，让函数之间形成嵌套关系，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compose(fn1, fn2, fn3);</span><br><span class="line"><span class="comment">// === 等价于</span></span><br><span class="line">fn1(fn2(fn3(...args)));</span><br></pre></td></tr></table></figure><p>由于 funcs.reduce 里面使用了箭头函数，理解起来会有点困难，所以转化为以下的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funcs.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a(b(...args));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而当使用 reduce 累计函数时,如累计 fn1、fn2、fn3，由于 reduce 没有使用默认值，所以第一次遍历的 a、b 分别为 fn1、fn2,而第二次遍历为 reduce 返回的函数与 fn3，累计结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次遍历</span></span><br><span class="line">a = fn1;</span><br><span class="line">b = fn2;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">...args: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn1(fn2(...args));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次遍历</span></span><br><span class="line"></span><br><span class="line">a = <span class="function"><span class="keyword">function</span> (<span class="params">...args: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn1(fn2(...args));</span><br><span class="line">  &#125;;</span><br><span class="line">b = fn3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后累计出来的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">...args: any</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn1(fn2(...args));</span><br><span class="line">  &#125;)(fn3(...args));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们调用最后累计出来的函数(既第二次调用 compose)时，就会先调用 fn3、fn2、fn1 这样的顺序去执行，但从源码中是把 store.dispatch 为参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = compose&lt;<span class="keyword">typeof</span> dispatch&gt;(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure><p>而我们每个 fn 都是嵌套函数，如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">next: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">targs1: any</span>) </span>&#123;</span><br><span class="line">    next(targs1);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们 compose 第二次调用完后返回的 fn1 的内层函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">targs1: any</span>)</span>&#123;</span><br><span class="line">    next(targs1);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>然后当我们第三次调用 compose 时就会执行 fn1 内层函数，而 next 是 fn2 的内层函数，所以执行顺序为 fn1、fn2、fn3 的内层函数，并把 fn1 的 targs1 一层层传递下去，让每一层对其进行改造或获取处理等然后继续传递下去，直到遇到真正的 dispatch,既 store.dispatch,最后触发 redux 数据更新。</p><ul><li>总结:<br><code>compose(funcs)(dispatch)(action)</code>,首先会把函数数组改造成嵌套数组，然后第二次调用 dispatch，第三次传入需要修改的数据 action<br>执行顺序为</li></ul><p><code>*</code>代表内层函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn1(fn2(fn3(dispatch)))</span><br><span class="line"></span><br><span class="line">fn3-&gt;fn2-&gt;fn1-&gt;fn1*-&gt;fn2*-&gt;fn3*</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="洋葱模型" title="">                </div>                <div class="image-caption">洋葱模型</div>            </figure><h2 id="applyMiddleware-实现"><a href="#applyMiddleware-实现" class="headerlink" title="applyMiddleware 实现"></a>applyMiddleware 实现</h2><p>源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ...middlewares: Middleware[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">StoreEnhancer</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore: StoreCreator</span>) =&gt;</span> &lt;S, A extends AnyAction&gt;(</span><br><span class="line">    reducer: Reducer&lt;S, A&gt;,</span><br><span class="line">    ...args: any[]</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer, ...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch: Dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Dispatching while constructing your middleware is not allowed. '</span> +</span><br><span class="line">          <span class="string">'Other middleware would not be applied to this dispatch.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI: MiddlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">action, ...args</span>) =&gt;</span> dispatch(action, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose&lt;<span class="keyword">typeof</span> dispatch&gt;(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applyMiddleware 是三层，第一次调用传递中间件数组 middlewares，而第二次调用 applyMiddleware 传递 createStore 创建 Store 的，第三次调用传递 reduces 与初始化 State(preloadedState)。</p><p>而 applyMiddleware 调用二三次都在<code>createStore.ts</code>里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> enhancer(createStore)(</span><br><span class="line">      reducer,</span><br><span class="line">      preloadedState <span class="keyword">as</span> PreloadedState&lt;S&gt;</span><br><span class="line">    ) <span class="keyword">as</span> Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext</span><br></pre></td></tr></table></figure><p>然后中间件需要编写三层函数，第一层是为了传递<code>getState</code>与改造的<code>dispatch</code>的，二三层是为了 compose 实现的，而改造的 dispatch 是如上的<code>fn1*</code>，这样只要不是调用到真正的 dispatch，那么 dispatch 后都会把所有的中间件都走一遍并把数据 action 也传递进去了，那样中间就可以灵活的处理数据。</p><h2 id="thunk-实现"><a href="#thunk-实现" class="headerlink" title="thunk 实现"></a>thunk 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> (next) =&gt; <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure><p>thunk 也是先接受改造的 dispatch 与 getState，然后接受 next，从上可知 next 最后一个就是真实的 dispatch，而 thunk 为了实现异步，判断了 action 是否为函数，如果是函数就把改造的 dispatch 与 getState，这样就简单的实现了 redux 只是异步的操作。</p><p>而中间件的实现最少要三层函数，因为第一层是给 applyMiddleware 内把改造的 dispatch 与 getState 传入的，而第二三层是给 compose 使用的，因为 compose 调用中间件函数的第一次传入 next(下一次函数)或 dispatch，第二次传入 action 数据，而 action 数据也是 redux 需要的数据，用过 redux 的都知道 reduce 的 action，而这个 action 与这里的是一样的。</p><p>从 redux 实现的中间件机制可知，只要我们明确功能是干什么的，核心是什么，那么我们就可以从核心内容在合理的范围内进行实现可预测的扩展机制，从而使功能尽量可面对未来的各种变化而进行扩展适配来符合变化，而 redux 的核心就是变化的数据与触发数据变化的方法，所以我们可以从这方面下手。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;redux 中间件设计的代码，简洁到极致，它的代码量很少，但却满足 redux 设计中间件的要求，柯里化的特性也在这里完美的体现。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="redux" scheme="https://793338023.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>了解react-router的实现</title>
    <link href="https://793338023.github.io/2020/05/30/%E4%BA%86%E8%A7%A3react-router%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://793338023.github.io/2020/05/30/%E4%BA%86%E8%A7%A3react-router%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-30T04:37:36.000Z</published>
    <updated>2020-05-30T15:23:39.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>react-router 的路由是是基于 history 实现的，而我们可以根据不同的使用场景，使用不同的包，如浏览器上使用<code>react-router-dom</code>,而<code>react-router</code>是一个 monorepo 项目，使用 yarn 的工作空间管理 node_modules 的包，所以 package 目录下的包是没有 node_modules 的，在<code>scripts\build.js</code>里有它的打包方式，是进入每个 package 的包目录下进行打包，而且是使用了 roullup 打包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> execSync = <span class="built_in">require</span>(<span class="string">"child_process"</span>).execSync;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">cmd</span>) </span>&#123;</span><br><span class="line">  execSync(cmd, &#123; <span class="attr">stdio</span>: <span class="string">"inherit"</span>, <span class="attr">env</span>: process.env &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cwd = process.cwd();</span><br><span class="line"></span><br><span class="line">[<span class="string">"react-router"</span>, <span class="string">"react-router-dom"</span>, <span class="string">"react-router-config"</span>].forEach(</span><br><span class="line">  (packageName) =&gt; &#123;</span><br><span class="line">    process.chdir(path.resolve(__dirname, <span class="string">"../packages/"</span> + packageName));</span><br><span class="line">    exec(<span class="string">"yarn build"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">process.chdir(cwd);</span><br></pre></td></tr></table></figure><p>而<code>react-router</code>包是其他包的基础包，就是其他包都会去引用它，就是其他包都在基础包的功能上新增功能来实现到符合不同场景的使用，所以有部分的功能都是直接包基础包的功能进行导出或增强而已。</p><p>而<code>react-router</code>只是进行了组件层的实现，真正的路由逻辑都在 history 这个包里面，如 Prompt、Route、Router 等组件的实现，而纯粹地址变化的路由实现是 history 实现的，包含三种模式<code>createBrowserHistory</code> H5 的 history 模式、<code>createHashHistory</code> URL 的 hash 模式、<code>createMemoryHistory</code> 无输入地址栏的内存记录模式，这是对 Native 场景很有用。</p><p><code>react-router</code>组件间数据的传递使用了<code>React.createContext</code>，而<code>Router</code>组件是数据提供方，而其他组件基本上都是数据消费方，所以我们都要使用<code>Router</code>放置在组件的顶层，让其他的组件都包含在它之下使用。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>我们在使用的<code>react-router-dom</code>导出的 BrowserRouter 与 HashRouter 其实在实现上是没有很大的区别的，只是在使用 createBrowserHistory 与 createHashHistory 的区别，它们都是简单的封装了 Router。</p><p>如 HashRouter:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  history = createHashHistory(<span class="keyword">this</span>.props);</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就调用了 createHashHistory 让路由设置为 hash 模式的路由，而 Router 的使用方式都是一样的。</p><h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><p>route 组件实现关键在<code>match</code>，因为这是路由匹配决定是否加载组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> match = <span class="keyword">this</span>.props.computedMatch</span><br><span class="line">  ? <span class="keyword">this</span>.props.computedMatch <span class="comment">// &lt;Switch&gt; already computed the match for us</span></span><br><span class="line">  : <span class="keyword">this</span>.props.path</span><br><span class="line">  ? matchPath(location.pathname, <span class="keyword">this</span>.props)</span><br><span class="line">  : context.match;</span><br></pre></td></tr></table></figure><p>从以下可以知道 route 组件渲染路由匹配组件，而第一层三元表达式就是决定是否加载组件，而其他的三元表达式是根据在 route 组件传入组件方式进行组件加载，从中可以看出 props 传入的加载组件顺序是 children、component、render</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">  &#123;props.match</span><br><span class="line">    ? children</span><br><span class="line">      ? <span class="keyword">typeof</span> children === <span class="string">"function"</span></span><br><span class="line">        ? __DEV__</span><br><span class="line">          ? evalChildrenDev(children, props, <span class="keyword">this</span>.props.path)</span><br><span class="line">          : children(props)</span><br><span class="line">        : children</span><br><span class="line">      : component</span><br><span class="line">      ? React.createElement(component, props)</span><br><span class="line">      : render</span><br><span class="line">      ? render(props)</span><br><span class="line">      : <span class="literal">null</span></span><br><span class="line">    : <span class="keyword">typeof</span> children === <span class="string">"function"</span></span><br><span class="line">    ? __DEV__</span><br><span class="line">      ? evalChildrenDev(children, props, <span class="keyword">this</span>.props.path)</span><br><span class="line">      : children(props)</span><br><span class="line">    : <span class="literal">null</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br></pre></td></tr></table></figure><p><code>Switch</code>组件的子组件要的是 route 组件，因为它主要的作用使用只要匹配中后就不再匹配，就只渲染当前的 route 组件，而它实现是<code>React.Children.forEach</code>遍历所有的子组件，所以要实现只匹配一次，那么就要使用它包囊，否则无法生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">React.Children.forEach(<span class="keyword">this</span>.props.children, (child) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">    element = child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> path = child.props.path || child.props.from;</span><br><span class="line"></span><br><span class="line">    match = path</span><br><span class="line">      ? matchPath(location.pathname, &#123; ...child.props, path &#125;)</span><br><span class="line">      : context.match;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>element 当前组件，match 为匹配情况，如果匹配中，从判断<code>match == null</code>可知就再也无法进入遍历的赋值逻辑。</p><h2 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h2><p>Prompt 是 react-router 唯一的路由守卫，不像 vue-router 钩子特别丰富，它的作为就是路由离开时的操作，需要匹配 history 的 getUserConfirmation 使用，因为真正拦截路由的时 getUserConfirmation，而 Prompt 只是一个离开时是否渲染的组件，它的实现很简单，就是基于 Lifecycle 生命周期组件做了一些添加信息，而它的作用就是在全局的路由里进行一些离开是否需要提示或二次确认是否离开的操作，如我们实现一个有大量填写内容的页面，如果误操作直接路由离开，那么可以会因为丢失数据，这样的用户体验是很差的，所以我们可以使用这个功能就是二次确认，来提示用户是否要放弃这些数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onMount) <span class="keyword">this</span>.props.onMount.call(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onUpdate) <span class="keyword">this</span>.props.onUpdate.call(<span class="keyword">this</span>, <span class="keyword">this</span>, prevProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onUnmount) <span class="keyword">this</span>.props.onUnmount.call(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Lifecycle;</span><br></pre></td></tr></table></figure><p>而添加信息，它调用的是 history 的 block，block 会接受一个入参 prompt，然后会把 prompt 保存起来，当调用 getUserConfirmation 会当一个参数传入，而它的第二参数为 callback，当 callback 传入为 true 时就跳转路由，传入为 false 则停止跳转，而 history 内部路由跳转实现也是基于 getUserConfirmation 实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">transitionManager.confirmTransitionTo(</span><br><span class="line">  location,</span><br><span class="line">  action,</span><br><span class="line">  getUserConfirmation,</span><br><span class="line">  (ok) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      setState(&#123; action, location &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      revertPop(location);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>confirmTransitionTo 的第四个参数就是决定了是否跳转路由。</p><h3 id="history-的属性了解"><a href="#history-的属性了解" class="headerlink" title="history 的属性了解"></a>history 的属性了解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    length, <span class="comment">// 历史堆栈高度</span></span><br><span class="line">    action, <span class="comment">// 当前导航动作有 pushpopreplace 三种</span></span><br><span class="line">    location: &#123;</span><br><span class="line">        pathname, <span class="comment">// 当前 url</span></span><br><span class="line">        search, <span class="comment">// queryString</span></span><br><span class="line">        hash, <span class="comment">// url hash</span></span><br><span class="line">    &#125;,</span><br><span class="line">    push(path[state]), <span class="comment">// 将一个新的历史推入堆栈 (可以理解为正常跳转)</span></span><br><span class="line">    replace(path[state]), <span class="comment">// 替换当前栈区的内容 (可以理解为重定向)</span></span><br><span class="line">    go(number), <span class="comment">// 移动堆栈指针</span></span><br><span class="line">    goBack(number), <span class="comment">// 返回上一历史堆栈指针 -1</span></span><br><span class="line">    goForward(number), <span class="comment">// 前进到下一历史堆栈指针 +1</span></span><br><span class="line">    block(string | <span class="function">(<span class="params">location, action</span>) =&gt;</span> &#123;&#125;) <span class="comment">// 传入提示信息，监听并阻止路由变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react-router 其实它的实现没有想象那么复杂，可以说只是实现了路由该有的功能，而一些扩展功能，它完全没有实现，保留最大的灵活性给使用者，让使用者根据需要自己完成所需的扩展实现，如鉴权，我们要根据二次封装 Route 组件实现一个鉴权路由，没有使用那些所谓的路由守卫的功能，因此我们可以通俗的理解为 react-router 就是一个普通的组件，在我们需要的时候就加载使用，不需要时就不加载，只是它比我们的组件多了一个根据路由匹配出需要加载的组件而已。</p><p>而实现 keep-alive，我们可以考虑使用<code>react-activation</code>,这个可以查看<a href="https://793338023.github.io/2020/05/05/react-%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F/">react-组件缓存的方式</a></p><p>而 hooks 方面可以使用 useHistory、useLocation、useParams、useRouteMatch 获取数据或方法，就不必使用 withRouter。</p><p>basename 设置路由的默认前缀路径，就是基础路径 basePath。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;react-router 的路由是是基于 history 实现的，而我们可以根据不同的使用场景，使用不同的包，如浏览器上使用&lt;code&gt;re</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>ora-终端loading动画与shellJs</title>
    <link href="https://793338023.github.io/2020/05/27/ora-%E7%BB%88%E7%AB%AFloading%E5%8A%A8%E7%94%BB%E4%B8%8EshellJs/"/>
    <id>https://793338023.github.io/2020/05/27/ora-%E7%BB%88%E7%AB%AFloading%E5%8A%A8%E7%94%BB%E4%B8%8EshellJs/</id>
    <published>2020-05-27T14:09:42.000Z</published>
    <updated>2020-05-27T16:04:58.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ora"><a href="#ora" class="headerlink" title="ora"></a>ora</h2><p>如果有深入进行过前端构建的，一定会遇到除了 webpack 等构建工具之外的实现前端自动化的过程，比如编译、git 提交、发布一步完成，无需开发者进行多次的指令操作等，那么一般当我们合并这些流程后等待时由于命令行界面就只有我们输入的内容外没有任何的提示而卡在这等待会感觉体验特别差，而 ora 就是为了解决这个问题的，就是我们在客户端界面上发送请求后需要一个 loadding 的动画一样，而 ora 就是让命令行界面有一个<code>spinner</code>旋转动画的效果。</p><p>使用方式例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">"ora"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spinner = ora(<span class="string">"npm publish ."</span>).start();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  spinner.succeed(<span class="string">"成功"</span>);</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  <span class="comment">// spinner.fail("失败");</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>ora 方法的入参为开始显示的内容，成功或失败后的入参为结果的内容。</p><p>如果没有特殊要求就是那么简单，而且操作的体验效果也很棒。</p><p>以下是<code>ora</code>的官方例子</p><p><a href="https://github.com/sindresorhus/ora/blob/master/example.js" target="_blank" rel="noopener">ora 的例子代码</a></p><h2 id="shellJs"><a href="#shellJs" class="headerlink" title="shellJs"></a>shellJs</h2><p>就是让我们可以使用 node 的方式，写 shell 脚本，就像平时操作 Linux 上的 shell 一样，</p><p>比如 Linux 上，在 temp 目录下生成 test.js 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch temp/test.js</span><br></pre></td></tr></table></figure><p>而使用 ShellJs 也可以实现，而且不需要考虑操作系统的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">"shelljs"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; touch &#125; = shell;</span><br><span class="line">touch(<span class="string">"temp/test.js"</span>);</span><br></pre></td></tr></table></figure><p>效果是一样的</p><p>使用 sed 添加 package 版本号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed(</span><br><span class="line">  <span class="string">"-i"</span>,</span><br><span class="line">  /(version.*:[\W]*)\d+\.\d+\.[\w-]+<span class="regexp">/,</span></span><br><span class="line"><span class="regexp">  "$10.1.190",</span></span><br><span class="line"><span class="regexp">  path.resolve(__dirname, "../</span>../package.json<span class="string">")</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure><p><code>$1</code> 为匹配中的第一组内容，那么我们可以使用匹配中的组加上替换的版本号，就可以直接对 package.json 的版本进行替换</p><p>而 shellJs 中<code>exec</code>是我觉得最有用的方法，因为它可以进行执行的指令，如<code>npm run build</code></p><p>如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">"shelljs"</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">"chalk"</span>);</span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">"ora"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; which, exec &#125; = shell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installYalc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">res, rej</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`全局安装: <span class="subst">$&#123;chalk.green(<span class="string">"yalc"</span>)&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> spinner = ora(<span class="string">"install yalc"</span>).start();</span><br><span class="line">    exec(<span class="string">"npm i -g yalc"</span>, &#123; <span class="attr">silent</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">code, stdout</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">        spinner.fail(stdout);</span><br><span class="line">        rej();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spinner.succeed(stdout);</span><br><span class="line">        res();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hasYalc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!which(<span class="string">"yalc"</span>)) &#123;</span><br><span class="line">    <span class="keyword">await</span> installYalc();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = hasYalc;</span><br></pre></td></tr></table></figure><p>而 exec 最好是使用异步，否则会卡着终端。</p><p><a href="https://github.com/793338023/components-lib/tree/master/config" target="_blank" rel="noopener">shell 例子</a></p><h2 id="yalc"><a href="#yalc" class="headerlink" title="yalc"></a>yalc</h2><p>最好的 link 方法</p><p>它的使用很简单，就是全局安装，然后当前项目发布，联调项目 add 就行了，联调完后<code>yalc remove --all</code></p><p><a href="https://www.kutu66.com//GitHub/article_154781" target="_blank" rel="noopener">参考资料</a><br><a href="https://github.com/whitecolor/yalc" target="_blank" rel="noopener">yalc github</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ora&quot;&gt;&lt;a href=&quot;#ora&quot; class=&quot;headerlink&quot; title=&quot;ora&quot;&gt;&lt;/a&gt;ora&lt;/h2&gt;&lt;p&gt;如果有深入进行过前端构建的，一定会遇到除了 webpack 等构建工具之外的实现前端自动化的过程，比如编译、git 提交、发布一步完</summary>
      
    
    
    
    
    <category term="node" scheme="https://793338023.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>umi体验</title>
    <link href="https://793338023.github.io/2020/05/18/umi%E4%BD%93%E9%AA%8C/"/>
    <id>https://793338023.github.io/2020/05/18/umi%E4%BD%93%E9%AA%8C/</id>
    <published>2020-05-18T04:11:35.000Z</published>
    <updated>2020-05-18T04:49:21.755Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=3a4d41c50723e5863e3bf447acf48e8b" target="_blank" rel="noopener">umi 体验</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=3a4d41c50723e5863e3bf447acf48e8b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;umi 体验&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>np与组件模板生成</title>
    <link href="https://793338023.github.io/2020/05/16/np%E4%B8%8E%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90/"/>
    <id>https://793338023.github.io/2020/05/16/np%E4%B8%8E%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90/</id>
    <published>2020-05-16T14:29:36.000Z</published>
    <updated>2020-05-16T14:29:56.448Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=02b0d3b0e7aee7c1ee1f13461f8f4e98" target="_blank" rel="noopener">np 与组件模板生成</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=02b0d3b0e7aee7c1ee1f13461f8f4e98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;np 与组件模板生成&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="npm" scheme="https://793338023.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>前端开发规范</title>
    <link href="https://793338023.github.io/2020/05/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://793338023.github.io/2020/05/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2020-05-15T15:39:07.000Z</published>
    <updated>2020-05-16T14:28:57.417Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=efe43926d29cf8508b9efd4eda35b316" target="_blank" rel="noopener">前端开发规范</a></p><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=a3a2d139fc417746ecdf11f7d478655c&amp;type=note" target="_blank" rel="noopener">git 提交规范</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=efe43926d29cf8508b9efd4eda35b316&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端开发规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="代码规范" scheme="https://793338023.github.io/tags/代码规范/"/>
    
  </entry>
  
  <entry>
    <title>代码规范eslint</title>
    <link href="https://793338023.github.io/2020/05/08/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83eslint%E4%B8%8Estylelint/"/>
    <id>https://793338023.github.io/2020/05/08/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83eslint%E4%B8%8Estylelint/</id>
    <published>2020-05-08T15:27:44.000Z</published>
    <updated>2020-05-08T15:57:15.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><p>ESLint 是一个 Javascript Linter，帮助我们规范代码质量，提高团队开发效率。</p><p>现在搭建项目一般都是使用现有的脚手架然后进行调整。</p><p>而且 typescript 的代码 lint 检查也转战为 eslint 了，tslint 已经是历史了。</p><p>eslint 带来的好处:</p><ul><li>避免代码错误</li><li>写出最佳实践的代码</li><li>规范变量使用方式</li><li>规范代码格式</li><li>更好的使用新的语法</li></ul><p>现在大家比较认可的代码规范:</p><ul><li><a href="https://standardjs.com/readme-zhcn.html" target="_blank" rel="noopener">standardjs</a></li><li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb</a></li></ul><p>ESLint 的规则已经完全插件化了。每一个规则都是一个插件并且你自由的添加修改规则。</p><p><a href="http://eslint.cn/" target="_blank" rel="noopener">ESLint 中文官网</a></p><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>eslint 虽然能帮助我们提高代码质量，但并不能完全统一编码风格，因为这些代码规范的重点并不在代码风格上，虽然有一定的限制。</p><p>prettier 是一个能够统一团队编码风格的工具，能够极大的提高团队执行效率，统一的编码风格能很好的保证代码的可读性。</p><p>而且我们能把 Prettier 集成到 eslint 里。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>安装初始项目</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app eslint-demo --typescript</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 ESLint 解析 TypeScript 的依赖</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin -D</span><br></pre></td></tr></table></figure><ol start="3"><li>初始配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure><p>根据需要选择需要的配置，然后安装初始需要的包，最后会生成一个<code>.eslintrc.js</code>，里面已经初始化好一些配置了。</p><p>我们把由<code>Create React App</code>团队提供的规则<code>&quot;react-app&quot;</code>添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">...</span><br><span class="line">  extends: [&quot;plugin:@typescript-eslint/recommended&quot;, &quot;react-app&quot;],</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们对 TypeScript 和 React 进行了 规范，此时需要选择一种代码格式化程序。前面提到的 Prettier 将是首选工具，因为它在检测和修复样式错误方面做的很出色，并且和 ESLint 有很好的集成。</p><ol start="4"><li>安装 prettier 依赖</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add prettier eslint-config-prettier eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">...</span><br><span class="line">  extends: [&quot;plugin:@typescript-eslint/recommended&quot;, &quot;react-app&quot;,&quot;plugin:prettier/recommended&quot;],</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后添加提交检测<br><a href="https://793338023.github.io/2019/11/19/git%E6%8F%90%E4%BA%A4%E5%89%8D%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/">具体操作查看</a></p><p>具体参考，可查看 GitHub 例子的配置<br><a href="https://github.com/793338023/react-standard" target="_blank" rel="noopener">github 的 Demo 例子</a></p><p>由于这种方式是不是在开发热更新报错，若需要这方面的，需要另外设置</p><h4 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h4><p><a href="https://zhuanlan.zhihu.com/p/62401626?from_voters_page=true" target="_blank" rel="noopener">使用 ESLint+Prettier 规范 React+Typescript 项目</a><br><a href="https://www.cnblogs.com/ssw-men/p/11155699.html" target="_blank" rel="noopener">自搭 react+webpack 的 ESlint</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;eslint&quot;&gt;&lt;a href=&quot;#eslint&quot; class=&quot;headerlink&quot; title=&quot;eslint&quot;&gt;&lt;/a&gt;eslint&lt;/h2&gt;&lt;p&gt;ESLint 是一个 Javascript Linter，帮助我们规范代码质量，提高团队开发效率。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="代码规范" scheme="https://793338023.github.io/tags/代码规范/"/>
    
  </entry>
  
  <entry>
    <title>react-组件缓存的方式</title>
    <link href="https://793338023.github.io/2020/05/05/react-%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://793338023.github.io/2020/05/05/react-%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-05T09:02:14.000Z</published>
    <updated>2020-05-05T13:54:18.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h1><ol><li>数据缓存，把组件的数据保持起来</li><li>从显示上实现，样式上的显示隐藏方式，如<code>display:none</code></li><li>伪造组件，然后把真实所需的组件移位，渲染到 HTML 的节点保持与伪造组件一致</li></ol><h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><p>这是最常用的缓存方式，而且也是最符合 react 的，因为 react 就是为了 UI 层实现的，从数据到数据被直观的显示。<br>react 是一个面向数据的，所以我们可以把所有的内容保存为一份数据，然后当我们需要这份数据时让它经过 react 转换为<br>我们显示的页面。</p><p>但这种方式实现缓存也是最辛苦的，首先我们要把界面上操作的信息保存为数据，然后我们还要对浏览器操作的行为也转换为数据，如滚动高度，<br>而且需要每个需要缓存的页面都进行这样的操作，这个工作量是很大的，并且还需要考虑性能问题，定制缓存策略，否则一些数据量的页面保存<br>那么几份就可以把客户端玩崩。</p><p>数据缓存的方式:</p><ul><li><p>redux<br>这也是最好的方式</p></li><li><p>本地缓存<br>如果数据需要跨客户端 Tabs 或缓存时效，那么这也是比较好的方式，只是它的存储量有限</p></li><li><p>利用模块化的闭包<br>如果对 redux 操作觉得很麻烦，而且会触发状态更新，那么可以新建一个文件进行数据保存</p></li><li><p>利用上层组件状态机保存数据<br>如果缓存的数据只想在某个组件没有被卸载时进行缓存操作，也可以使用上层数据进行数据保存</p></li></ul><h2 id="从显示上实现"><a href="#从显示上实现" class="headerlink" title="从显示上实现"></a>从显示上实现</h2><p>对组件添加<code>display:none</code>。</p><p>简单粗暴，因为没有卸载组件，所以可以不用管页面的数据状态的保存情况。只需要管理好恢复显示、隐藏与正常 re-render，再恢复滚动位置即可。</p><h2 id="伪造组件"><a href="#伪造组件" class="headerlink" title="伪造组件"></a>伪造组件</h2><p>伪造组件的实现思路是利用包囊组件 children 方式把 children 传递出现，在一个缓存组件区内被渲染，而当前组件正常卸载重载，并且卸载这个组件也把它传递出去的 children 的 DOM 节点 remove 了，而重新加载这个组件时由于虚拟 DOM 的部分已经缓存了，还有 DOM 节点的 node 也保存了一份，而使用 react，最重要的就是虚拟 DOM 这部分了(既 FiberNode)，因为组件的实例就在这里，而数据就在实例里，而 react 就是根据最后处理出的虚拟 DOM 的结构来进行渲染的，所以只要虚拟 DOM 不被卸载，那么组件其实就存在，只是 DOM 节点被删除了，所以当伪造组件被加载后重新把保存的 node 节点 append 到 HTML 结构上那么就能在当前页面正常显示了，这样在 HTML 结构查看时就和正常的组件一模一样，只是使用 react 的工具查看结构时才会发现缓存组件区里的组件实例是没有卸载的，FiberNode 还是存在的。</p><h3 id="伪造组件例子"><a href="#伪造组件例子" class="headerlink" title="伪造组件例子"></a>伪造组件例子</h3><p>伪造组件启发是来源这个 github <a href="https://github.com/CJY0208/react-activation" target="_blank" rel="noopener">react-activation</a>，react 的实现真的很大层度给予开发最大灵活性</p><p>而目前来看我觉得<code>react-activation</code>的缓存实现是入侵性最小的，不像别的组件缓存，都把 react-router 包都替换了，因为是个人开发的，如果有一天不维护了或你使用它出现很大 BUG，作者不能及时修复，又或者跟不上 react-router 的更新，那么我觉得它就是一个大坑。</p><p>还有别的零散的组件缓存包，但我觉得大同小异，但<code>react-activation</code>实现与使用都是比它们好一些的，而且如果出现的 BUG，作者不及时修改，我们也可以快速去除它，及时止损，因为一般使用缓存都是前进后退这样的，所以对项目来说还是可以接受的范围，如果与核心功能有关，去除后影响很大，那也可以使用<code>display:none</code>替换为方案，只是要干掉路由，所以从耦合性比较，<code>react-activation</code>还是值得使用的，而且只要你了解它的源码，出问题后也可以自行修复。</p><p><a href="https://github.com/793338023/single-demo/tree/master/packages/my-demo" target="_blank" rel="noopener">使用 react-activation 例子</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的就是组件的缓存方式的思路，因为 react 的机制问题，react 没有实现缓存，路由没有实现缓存，因为 react 给我们最大权限去操作代码，所以 API 方面会很少，而且如果没有良好缓存策略，会导致很严重的性能问题，而 vue 的 keep-alive 使用了 LRU 算法限制缓存数量来让缓存占用内存限制一个区间内。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存方式&quot;&gt;&lt;a href=&quot;#缓存方式&quot; class=&quot;headerlink&quot; title=&quot;缓存方式&quot;&gt;&lt;/a&gt;缓存方式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;数据缓存，把组件的数据保持起来&lt;/li&gt;
&lt;li&gt;从显示上实现，样式上的显示隐藏方式，如&lt;code&gt;displa</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>qiankun微前端爽一把</title>
    <link href="https://793338023.github.io/2020/05/03/qiankun%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%88%BD%E4%B8%80%E6%8A%8A/"/>
    <id>https://793338023.github.io/2020/05/03/qiankun%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%88%BD%E4%B8%80%E6%8A%8A/</id>
    <published>2020-05-03T08:07:44.000Z</published>
    <updated>2020-05-04T07:54:19.153Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yuque.com/kuitos/gky7yw/gesexv" target="_blank" rel="noopener">为什么不使用 Iframe</a></p><p>微前端现在越来越火，因为大家尝到微服务的甜头，而前端行业，都是别人好的东西往家里搬，所以大家都纷纷搭建属于自己的那个微前端架子，那么最好的方式当然开箱即用，所以就有了 qiankun，qiankun 在使用者推动下会越来越符合大众的微前端方案。</p><p><strong><a href="https://github.com/793338023/qiankun-packages" target="_blank" rel="noopener">qiankun 微前端 Demo 与文档</a></strong></p><p>例子使用了 react 脚手架与 vue 脚手架</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/kuitos/gky7yw/gesexv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么不使用 Iframe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微前端现在越来越火，因为大家尝到微服务的甜头，而前端行业</summary>
      
    
    
    
    
    <category term="微前端" scheme="https://793338023.github.io/tags/微前端/"/>
    
  </entry>
  
  <entry>
    <title>react/hooks之二</title>
    <link href="https://793338023.github.io/2020/05/02/react-hooks%E4%B9%8B%E4%BA%8C/"/>
    <id>https://793338023.github.io/2020/05/02/react-hooks%E4%B9%8B%E4%BA%8C/</id>
    <published>2020-05-02T14:24:20.000Z</published>
    <updated>2020-05-03T08:01:47.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>使用 hooks 的动机:</p><ul><li>在组件之间复用状态逻辑很难；</li></ul><p>class 组件要实现复用逻辑，通常会以高阶组件的形式实现或<a href="https://zh-hans.reactjs.org/docs/render-props.html" target="_blank" rel="noopener">render props</a>,但它们需要重新组织你的组件结构并让组件嵌套变深，代码难以理解，形成“嵌套地狱”。</p><ul><li>复杂组件变得难以理解；</li></ul><p>当一个简单的组件，由于需要的迭代，组件间的状态散布到生命周期的各个时期里，而状态之间既互相关联又互相不影响，导致代码拆分困难，组件的逻辑与代码越来越庞大，变得难以阅读理解。</p><ul><li>class 让开发人员与计算机都难理解，而表现为函数式编程比 OOP 更加简单；</li></ul><p>class 你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器，当然可以使用箭头函数解决。<br>class 不能很好的压缩，并且会使热重载出现不稳定的情况。</p><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>useState 其实就是阉割版的 useReducer,但在实际开发中 useState 才是主要被使用的,而 useReducer 是 useState 的替代方案。</p><p>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</p><p>比如直接在函数组件里调用请求之类的，需要等请求的数据回来后才进行某些操作，那么你就要维护一个 loading 与 data 的 state，而异步的 state 是 useState 后就立刻 render 一次，那么执行两次 useState，就会执行两次的 render，这就有可能出现一些执行顺序上的 BUG 问题，所以我们可以使用 useReducer 把它们维护到一个 state 上，并且 useReducer 里的 reducer 可以执行一些逻辑上的操作。<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useReducer, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface InitState &#123;</span><br><span class="line">  data: any[];</span><br><span class="line">  page: &#123; [key: string]: any &#125;;</span><br><span class="line">  loading: boolean;</span><br><span class="line">&#125;</span><br><span class="line">const initState: InitState = &#123;</span><br><span class="line">  data: [],</span><br><span class="line">  page: &#123; total: 10, record: 10 &#125;,</span><br><span class="line">  loading: true,</span><br><span class="line">&#125;;</span><br><span class="line">function reducer(</span><br><span class="line">  state: InitState,</span><br><span class="line">  action: &#123; type: string; payload: InitState &#125;</span><br><span class="line">) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;a&quot;:</span><br><span class="line">      return &#123; ...action.payload &#125;;</span><br><span class="line">    case &quot;b&quot;:</span><br><span class="line">      return &#123; ...action.payload &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const useRequest = () =&gt; &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, initState);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      const data = &#123;</span><br><span class="line">        type: &quot;a&quot;,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          data: [&quot;zhhh&quot;, &quot;xxx&quot;, 3, 4],</span><br><span class="line">          page: &#123; total: 51, record: 999 &#125;,</span><br><span class="line">          loading: false,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">      dispatch(data);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default useRequest;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/793338023/single-demo/tree/master/packages/my-demo/src/pages/hookTest" target="_blank" rel="noopener">github 例子</a></p><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer" target="_blank" rel="noopener">官方 usereducer 说明</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>hooks 接入 React-Redux 后 mapDispatchToProps 的第二参数是有问题的，如果使用了第二参数，那么每当 connected 的组件接收到新的 props 时，mapDispatchTopProps 都会被调用，这意味着组件会返回一个新的 props，导致使用 useEffect 监听 props 的属性的都会被触发掉而出现一些 BUG 问题，当然如果有正确判断规则，那么这个对于项目来说问题不大，就是多了一次 render 机会，不会严重影响程序与用户体验。</p><p><strong><a href="https://juejin.im/post/5d415282f265da03970b96e6" target="_blank" rel="noopener">Redux with Hooks</a></strong></p><h2 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h2><ul><li>React 通过单链表来管理 Hooks</li><li>按 Hooks 的执行顺序依次将 Hook 节点添加到链表中</li><li>每个 Hook 节点通过循环链表记住所有的更新操作</li><li>在 update 阶段会依次执行 update 循环链表中的所有更新操作，最终拿到最新的 state 返回</li><li>FiberNdoe 节点中会又一个 updateQueue 链表来存放所有的本次渲染需要执行的 effect。</li><li>mountEffect 阶段和 updateEffect 阶段会把 effect 挂载到 updateQueue 上。</li><li>updateEffect 阶段，deps 没有改变的 effect 会被打上 NoHookEffect tag，commit 阶段会跳过该 Effect。</li></ul><p><strong>为什么只能在函数顶层使用 Hooks 而不能在条件语句等里面使用 Hooks?</strong></p><p>其实 hooks 就是把挂载与更新分开来了，如果组件第一次加载那么就会走 mount 的函数，更新后走 update 的函数，由于函数组件其实就是 render 函数，所以每次的更新都会把整个函数都重新执行一遍，那么执行的函数里的钩子就要与第一次执行时是一致，这是为什么，你可以想象一下，数组，数组只有下标，而每次执行函数后函数里的数组都是重新 push 一遍内容的，那么如果组件第一次加载时保存一个全局钩子数组，与这次的钩子的 push 进去的不一致，那么全局钩子与更新的钩子匹配时整个更新就会错乱。</p><p>而像 preact 模拟 hooks 直接就使用数组，没有使用链表结构，然后每次获取当前 hooks 钩子都是 index 索引加一方式。</p><p>useState 的实现与 useReducer 是一样的，因为 useState 返回的就是一个 state 与 dispatch，只是它的 action 是内容实现的，action 就是更新的内容，不需要有 type 这样的字段。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://juejin.im/post/5dc6e1b35188251ab9183c7d#heading-6" target="_blank" rel="noopener">React Hooks 源码解析（3）：useState</a><br><a href="https://juejin.im/post/5d569b39e51d453b7779d531" target="_blank" rel="noopener">React Hooks 源码模拟与解读</a><br><a href="https://juejin.im/post/5e5e66d6e51d4526e651c796#heading-3" target="_blank" rel="noopener">React Hooks 源码解析，原来这么简单～</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;使用 hooks 的动机:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在组件之间复用状态逻辑很难；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;class 组件要实现复用逻</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>linux002</title>
    <link href="https://793338023.github.io/2020/05/02/linux002/"/>
    <id>https://793338023.github.io/2020/05/02/linux002/</id>
    <published>2020-05-02T06:59:42.000Z</published>
    <updated>2020-05-02T07:08:15.223Z</updated>
    
    <content type="html"><![CDATA[<p><strong>平时使用，记事内容</strong></p><p>惯用账号密码:<br>root<br>admin123</p><p>virtualbox 虚拟机的使用-关于没有 IP 地址<br><a href="https://www.cnblogs.com/caizhw3/articles/virtualbox_net_surfingInternetBasic.html" target="_blank" rel="noopener">https://www.cnblogs.com/caizhw3/articles/virtualbox_net_surfingInternetBasic.html</a></p><p>msconfig</p><ul><li><p>递归创建目录<br>mkdir -p zz/xx/cc</p></li><li><p>删除非空目录<br>rm -rf zz</p></li><li><p>创建空文件<br>touch aa.js bb.js</p></li><li><p>copy 文件<br>cp aa.txt /bb</p></li><li><p>整个文件夹<br>cp -r aa /bb copy</p></li><li><p>移动文件<br>mv 重命名\移动目录或文件</p></li><li><p>只读文件内容<br>cat -n 只读</p></li></ul><p><code>ls &gt;&gt;a.txt</code><br>当 a.txt 不存在，创建，存在覆盖，把指令的内容追加输出 a.txt<br>ls &gt; a.txt<br>如上，但是是覆盖</p><p>指令<br><code>&gt;&gt;</code>追加<br><code>&gt;</code>覆盖</p><p><code>echo aaabbb &gt;&gt; a.txt</code></p><p>cal 时间</p><p>head -n 行数 文件<br>查看前几行<br>tail -f 文件<br>实时监听尾部几行</p><p>tail -100f 文件<br>尾部 100 行</p><p>查看历史记录<br>history [n]</p><p>history 10 查看最近十次的指令</p><p>find 查看<br>指定目录下查找文件或目录</p><p>find [搜索·范围][选项]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find / -name \*.txt 按文件名查找</span><br><span class="line">find / -size +20M 大于 20M 的文件</span><br><span class="line">find / -size -20M 小于</span><br><span class="line">find / -size 20M 等于</span><br><span class="line">20k</span><br></pre></td></tr></table></figure><p>grep 管道符号|</p><p><code>grep [选项] 查找内容 源文件</code></p><p>-n 显示行号<br>-i 忽略大小写</p><p><code>##文件名+内容</code><br>grep -r “查询内容” 文件目录</p><p><code>##只显示包含内容的文件名</code><br>grep -r -l “查询内容” 文件目录</p><p><code>##文件名+内容</code><br>find 文件目录 -type f |xargs grep “查询内容”;</p><p><code>grep -r -l zhangzhi ./</code></p><p>zip/unzip</p><p><code>zip -r my.zip /home</code><br>-r 专门压缩目录的，压缩后文件名称 压缩文件路径</p><p><code>unzip -d /opt/temp/ my.zip</code></p><p>-d 解压到的目录， 解压后目录 解压的文件路径</p><p>tar<br>解压<br><code>tar -zxvf aa.tar.gz</code><br>压缩，指定压缩文件名称，可以多个文件，<br><code>tar -zcvf aa.tar.gz a.txt b.txt</code></p><p>关机<br>halt -p</p><p>wifi 查看<br>netsh wlan show profiles<br>查看某个 wifi 的密码<br>netsh wlan show profiles 名称 key=clear</p><p>临时关闭防火墙<br>/etc/init.d/iptables stop<br>查看关闭后的状态<br>/etc/init.d/iptables status</p><p>iptables: Firewall is not running.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;平时使用，记事内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;惯用账号密码:&lt;br&gt;root&lt;br&gt;admin123&lt;/p&gt;
&lt;p&gt;virtualbox 虚拟机的使用-关于没有 IP 地址&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/cai</summary>
      
    
    
    
    
    <category term="linux" scheme="https://793338023.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>gulp底层vinyl-fs</title>
    <link href="https://793338023.github.io/2020/05/02/gulp%E5%BA%95%E5%B1%82vinyl-fs/"/>
    <id>https://793338023.github.io/2020/05/02/gulp%E5%BA%95%E5%B1%82vinyl-fs/</id>
    <published>2020-05-02T02:52:30.000Z</published>
    <updated>2020-05-02T03:16:25.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vinyl-fs"><a href="#vinyl-fs" class="headerlink" title="vinyl-fs"></a>vinyl-fs</h2><p>当你只想处理文件到文件的文件处理场景时可以使用<code>vinyl-fs</code>,而不必使用 gulp，因为 gulp 的 src、pipe、dest 的实现，就是使用了它。<br>而 webpack\rollup 都是模块化打包工具，这里模块一般都是把文件当成一个模块，然后处理完之后把所有模块整合，所以有时不符合场景，当然也是用 babel 的 cli，但它的处理可能会出现一些小问题，如目录里是单目录时输出的结构不符合等情况，所以结合总总的还是使用 vinyl-fs 进行文件流的处理比较简单方便且可以直接使用围绕 gulp 生态的包与使用 node 编程，完美。</p><p>当然 webpack\rollup tree-shaking 加模块化打包机制，可以解决很多场景问题，所以推荐尽量使用 webpack\rollup。</p><p><strong><a href="https://github.com/793338023/vinyl-demo" target="_blank" rel="noopener">请查看 github</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vinyl-fs&quot;&gt;&lt;a href=&quot;#vinyl-fs&quot; class=&quot;headerlink&quot; title=&quot;vinyl-fs&quot;&gt;&lt;/a&gt;vinyl-fs&lt;/h2&gt;&lt;p&gt;当你只想处理文件到文件的文件处理场景时可以使用&lt;code&gt;vinyl-fs&lt;/code&gt;,而</summary>
      
    
    
    
    
    <category term="gulp" scheme="https://793338023.github.io/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>使用chrome排查内存泄露</title>
    <link href="https://793338023.github.io/2020/05/01/%E4%BD%BF%E7%94%A8chrome%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>https://793338023.github.io/2020/05/01/%E4%BD%BF%E7%94%A8chrome%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</id>
    <published>2020-05-01T06:09:14.000Z</published>
    <updated>2020-09-19T07:58:17.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-chrome-排查内存泄露"><a href="#使用-chrome-排查内存泄露" class="headerlink" title="使用 chrome 排查内存泄露"></a>使用 chrome 排查内存泄露</h2><p>内存分析使用的工具包括 chrome 任务管理器、chrome 时间轴（低版本是 Timeline，高版本对应 performance）、chrome memory（低版本是 chrome profiles，主要用 JS 堆快照、JS 堆动态分配时间轴）</p><p>chrome 的工具里提供了很多种方式去排查明确内存情况，但我觉得会其中的一些就够了，就好像使用 js API 一样，我们会 js API 里的某些就可以了，其他的不会，也可以使用我们懂的进行模拟，或快速上手其他 API。</p><p>而我喜欢使用<code>Head snapshot</code>生成某个时刻的内存快照，然后多进行几次进行比较，得出我的结果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用 Summary 如图</p><ul><li><p>Constructor：构造函数，节点下的对象都是由改构造函数创建而来。</p></li><li><p>Distance：与根节点的距离。</p></li><li><p>Objects Count：对象个数及百分占比。</p></li><li><p>Shallow size：对象的直接内存总数，直接内存是指对象自身占用的内存大小。</p></li><li><p>Retained size：对象的最大保留内存，保留内存是指对象被删除后可以释放的那部分内存。</p></li></ul><p>点击展开构造函数，可以看到所有构造函数相关的对象实例，@后面的数字是该对象实例的唯一标识符。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用比较快照的，comparison</p><ul><li><p>Contructor - 表示使用此构造函数创建的所有对象</p></li><li><p>Distance - 显示使用节点最短简单路径时距根节点的距离</p></li><li><p>Shallow Size - 显示通过特定构造函数创建的所有对象浅层大小的总和。浅层大小是指对象自身占用的内存大小（一般来说，数组和字符串的浅层大小比较大）</p></li><li><p>Retained Size - 显示同一组对象中最大的保留大小。某个对象删除后（其依赖项不再可到达）可以释放的内存大小称为保留大小。</p></li><li><p>#New - Comparison 特有 - 新增项</p></li><li><p>#Deleted - Comparison 特有 - 删除项</p></li><li><p>#Delta - Comparison 特有 - 增量</p></li><li><p>Alloc. Size - Comparison 特有 - 内存分配大小</p></li><li><p>Freed Size - Comparison 特有 - 释放大小</p></li><li><p>Size Delta - Comparison 特有 - 内存增量</p></li></ul><h3 id="常见的顶层构造函数："><a href="#常见的顶层构造函数：" class="headerlink" title="常见的顶层构造函数："></a>常见的顶层构造函数：</h3><ul><li><p>(global property)：全局对象和普通对象的中间对象，和常规思路不同。比如在 Window 上定义了一个 Person 对象，那么他们之间的关系就是[global] =&gt; (global property) =&gt; Person。之所以使用中间对象，是出于性能的考虑。</p></li><li><p>(closure)：使用函数闭包的对象。</p></li><li><p>(array, string, number, regexp)：一系列对象类型，其属性指向 Array/String/Number/Regexp。</p></li><li><p>HTMLDivElement/HTMLAnchorElement/DocumentFragment：元素的引用或者代码引用的指定文档对象。</p></li></ul><p>在 Class filter(类过滤器)文本框中输入 Detached 可以搜索分离的 DOM 树。</p><p>一般来说排查过程是一个细心的活，因为 chrome 的工具提供了很多信息给我们，但代码方面可能不是自己写的，不能很明确这部分是否是真的有问题，因此我们只能根据 chrome 提供的文件名、方法、实例对象、DOM 节点等等去尝试这部分变化是否能给应用带来改进，而我觉得最常出问题应该是闭包这类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用-chrome-排查内存泄露&quot;&gt;&lt;a href=&quot;#使用-chrome-排查内存泄露&quot; class=&quot;headerlink&quot; title=&quot;使用 chrome 排查内存泄露&quot;&gt;&lt;/a&gt;使用 chrome 排查内存泄露&lt;/h2&gt;&lt;p&gt;内存分析使用的工具包括 ch</summary>
      
    
    
    
    
    <category term="chrome" scheme="https://793338023.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>React16/fiber</title>
    <link href="https://793338023.github.io/2020/04/28/React16-fiber/"/>
    <id>https://793338023.github.io/2020/04/28/React16-fiber/</id>
    <published>2020-04-28T14:41:51.000Z</published>
    <updated>2020-05-01T06:05:37.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>react 在进行组件渲染时，从 setState 开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js 执行会占据主线程时间较长，会导致页面响应度变差，使得 react 在动画、手势等应用中效果比较差。</p><p>所以在 react v15 之前使用它做一些动画效果或大数据量处理渲染之类的都可能会出现卡顿等性能问题。</p><p>react v15 是函数调用栈，递归的方式，从父节点（Virtual DOM）开始遍历，以找出不同。将所有的 Virtual DOM 遍历完成后，reconciler 才能给出当前需要修改真实 DOM 的信息，并传递给 renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的 vDOM 树来说，reconciliation 过程会很长(大于浏览器渲染帧的时间 16ms)，在这期间，主线程是被 js 占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。</p><p>破解 JavaScript 中同步操作时间过长的方法其实很简单——分片。<br>把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。<br>React Fiber 把更新过程碎片化，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。<br>维护每一个分片的数据结构，就是 Fiber。</p><h2 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h2><p>在 React Fiber 中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。</p><p>因为一个更新过程可能被打断，所以 React Fiber 一个更新过程被分为两个阶段(Phase)：第一个阶段 协调阶段 和第二阶段 提交阶段。</p><p>在第一阶段协调阶段，React Fiber 会找出需要更新哪些 DOM，这个阶段是可以被打断的；但是到了第二阶段 提交阶段，那就一鼓作气把 DOM 更新完，绝不会被打断。</p><p>这两个阶段大部分工作都是 React Fiber 做，和我们相关的也就是生命周期函数。</p><p>以 render 函数为界，第一阶段可能会调用下面这些生命周期函数，说是“可能会调用”是因为不同生命周期调用的函数不同。</p><blockquote><blockquote><p>第一阶段:<br>componentWillMount<br>componentWillReceiveProps<br>shouldComponentUpdate<br>componentWillUpdate</p></blockquote></blockquote><blockquote><blockquote><p>第二阶段:<br>componentDidMount<br>componentDidUpdate<br>componentWillUnmount</p></blockquote></blockquote><p>因为第一阶段的过程会被打断而且“重头再来”，就会造成意想不到的情况。</p><p>例如已经执行到某个 Fiber 内的生命周期函数 componentWillUpdate，但由于已经到了一个渲染帧的时间，需要把控制权让出，让浏览器查看是否有任务需要执行，若有则废弃当前 Fiber，执行浏览器的任务，等浏览器让出控制权后重新执行这个 Fiber，所以才会出现二次执行生命周期 componentWillUpdate 的情况。</p><p>因此第一阶段中的生命周期函数在一次加载和更新过程中可能会被多次调用！</p><p>但某些使用者在使用生命周期函数时会做一些奇怪的操作上，既违背这个生命周期提供的意义，如果出现二次调用就会出现各种 BUG，所以 react 把某些生命周期在过渡版本提示为废弃钩子，componentWillMount，componentWillReceiveProps，componentWillUpdate。</p><h2 id="fiber-执行单元"><a href="#fiber-执行单元" class="headerlink" title="fiber 执行单元"></a>fiber 执行单元</h2><p>fiber 的实现方式为<strong>时间分片 + 链表结构</strong>，一个组件实例对应有一个 fiber fiber 其实就是虚拟 Dom。</p><p>fiber 维护了一个分片的数据结构，就是可终止可恢复的链表式数据结构。</p><p>如一个<code>&lt;Card /&gt;</code>组件的 fiber:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FiberNode 结构如下：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义fiber节点类型，类组件指向构造函数，dom元素指向标签名称</span></span><br><span class="line">    type: Card,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fiber类型，将React Element映射成对应的Fiber类型，用于说明协调过程中需要完成的工作</span></span><br><span class="line">    <span class="comment">// HostRoot|HostComponent|ClassComponent|FunctionComponent...</span></span><br><span class="line">    tag: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同tag代表不同类型的副作用</span></span><br><span class="line">    effectTag: <span class="number">1</span>,</span><br><span class="line">    firstEffect: <span class="literal">null</span>,</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单链表结构，方便遍历fiber树上有副作用的节点</span></span><br><span class="line">    nextEffect: FiberNode|<span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个子fiber</span></span><br><span class="line">    child: FiberNode|<span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向父fiber，表示当前节点处理完毕后，应该向谁提交自己的结果effect list</span></span><br><span class="line">    <span class="keyword">return</span>: FiberNode|<span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兄弟fiber</span></span><br><span class="line">    slibing: FiberNode|<span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前父fiber中的位置</span></span><br><span class="line">    index: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fiber实例对象，指向当前组件实例</span></span><br><span class="line">    stateNode: Card,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setState待更新状态，回调，DOM更新的队列</span></span><br><span class="line">    updateQueue: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前UI的状态，反映了UI当前在屏幕上的表现状态</span></span><br><span class="line">    memoizedState: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前次渲染中用于决定UI的props</span></span><br><span class="line">    memoizedProps: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即将应用于下一次渲染更新的props</span></span><br><span class="line">    pendingProps: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和组件Element中的key,ref一致</span></span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    ref: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fiber更新时基于当前fiber克隆出的镜像，更新时记录两个fiber diff的变化；更新结束后alternate替换之前的fiber成为新的fiber节点</span></span><br><span class="line">    alternate: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记子树上待更新任务的优先级 （最新版的react做了变更，改由过期时间实现，时间越大，setState越频繁，优先级就越高）</span></span><br><span class="line">    pendingWorkPriority: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 child, slibing, return 的结构关联，可知它是一个单链表结构。</p><h2 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h2><p>实现时间分片的目的只是为了在做一些大批量 DOM 渲染时，让客户端不要给客户出现卡顿的不流畅现象。</p><p>而使用浏览器提供的 API 是最好的，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener">requestIdleCallback</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a>，如果需要兼容低版本浏览器，可以使用 setTimeout 模拟，但可能会出现一瞬间的白屏情况。</p><h3 id="setTimeout-闪屏现象"><a href="#setTimeout-闪屏现象" class="headerlink" title="setTimeout 闪屏现象"></a>setTimeout 闪屏现象</h3><p>在 js 引擎里，setTimeout 的事件处理函数会先等待到目标时间后执行，然后进入事件队列里等待主线程的空闲，因此 setTimeout 的实际执行时间可能会比其设定的时间晚一些。</p><p>那么我们在 setTimeout 设置的时间与浏览器的渲染时间很大可能是不一致的，而且很大可能是 setTimeout 被主线程处理比渲染要晚一些，导致 setTimeout 里的渲染内容只能在下一帧渲染时被渲染，这是丢帧现象。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>没有用时间分片</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录任务开始时间</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">// 插入十万条数据</span></span><br><span class="line"><span class="keyword">const</span> total = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 获取容器</span></span><br><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line"><span class="comment">// 将数据插入容器中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">  li.innerText = ~~(<span class="built_in">Math</span>.random() * total);</span><br><span class="line">  ul.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"JS运行时间："</span>, <span class="built_in">Date</span>.now() - now);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"总运行时间："</span>, <span class="built_in">Date</span>.now() - now);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>十万条数据渲染时会出现很明显的卡顿白屏等现象。</p><ol start="2"><li>requestAnimationFrame 实现时间分片</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要插入的容器</span></span><br><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line"><span class="comment">// 插入十万条数据</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 一次插入 20 条</span></span><br><span class="line"><span class="keyword">let</span> once = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//总页数</span></span><br><span class="line"><span class="keyword">let</span> page = total / once;</span><br><span class="line"><span class="comment">//每条记录的索引</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环加载数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">curTotal, curIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (curTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每页多少条</span></span><br><span class="line">  <span class="keyword">let</span> pageCount = <span class="built_in">Math</span>.min(curTotal, once);</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pageCount; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">      li.innerText = curIndex + i + <span class="string">" : "</span> + ~~(<span class="built_in">Math</span>.random() * total);</span><br><span class="line">      ul.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    loop(curTotal - pageCount, curIndex + pageCount);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">loop(total, index);</span><br></pre></td></tr></table></figure><p>在操作时很顺畅，体验很好。</p><h2 id="宝藏资料"><a href="#宝藏资料" class="headerlink" title="宝藏资料"></a>宝藏资料</h2><p><a href="https://juejin.im/post/5dadc6045188255a270a0f85#%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A" target="_blank" rel="noopener">这可能是最通俗的 React Fiber(时间分片) 打开方式</a><br><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">React Fiber</a><br><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">React Fiber 是什么</a><br><a href="https://blog.csdn.net/sinat_17775997/article/details/93774887" target="_blank" rel="noopener">fiber</a><br><a href="https://yq.aliyun.com/articles/610024" target="_blank" rel="noopener">React Fiber 初探</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;react 在进行组件渲染时，从 setState 开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js 执行会</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法</title>
    <link href="https://793338023.github.io/2020/04/25/LRU%E7%AE%97%E6%B3%95/"/>
    <id>https://793338023.github.io/2020/04/25/LRU%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-25T14:00:24.000Z</published>
    <updated>2020-04-25T14:02:01.954Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://github.com/793338023/my-algorithm/blob/master/src/views/home/LRU.md" target="_blank" rel="noopener">LRU 算法</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/793338023/my-algorithm/blob/master/src/views/home/LRU.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LRU 算法&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
    <category term="算法" scheme="https://793338023.github.io/tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>AST抽象语法树</title>
    <link href="https://793338023.github.io/2020/04/18/AST%E6%8A%BD%E8%B1%A1%E6%A0%91/"/>
    <id>https://793338023.github.io/2020/04/18/AST%E6%8A%BD%E8%B1%A1%E6%A0%91/</id>
    <published>2020-04-18T00:49:52.000Z</published>
    <updated>2020-04-18T00:58:00.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树 AST"></a>抽象语法树 AST</h2><p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。</p><p><strong>(详细查看请 github 例子)[<a href="https://github.com/793338023/ast-tree]" target="_blank" rel="noopener">https://github.com/793338023/ast-tree]</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;抽象语法树-AST&quot;&gt;&lt;a href=&quot;#抽象语法树-AST&quot; class=&quot;headerlink&quot; title=&quot;抽象语法树 AST&quot;&gt;&lt;/a&gt;抽象语法树 AST&lt;/h2&gt;&lt;p&gt;在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>npm安装机制</title>
    <link href="https://793338023.github.io/2020/04/11/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6/"/>
    <id>https://793338023.github.io/2020/04/11/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-11T10:07:36.000Z</published>
    <updated>2020-09-19T07:59:19.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从输入-npm-install-后"><a href="#从输入-npm-install-后" class="headerlink" title="从输入 npm install 后"></a>从输入 npm install 后</h2><ol><li><p>项目下有 package.json，输入<code>npm i</code>,查询 node_modules 是否存在，不存在新增，存在在此下安装模块。</p></li><li><p>根据 package.json 的依赖模块，查询 node_modules 目录之中是否已经存在指定模块，若存在，不再重新安装，若不存在， npm 向 registry 查询模块压缩包的网址，下载压缩包，存放在本地的缓存目录里，解压压缩包到当前项目的 node_modules 目录。</p><p>这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm 目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get cache</span><br></pre></td></tr></table></figure></li><li><p>获取模块，根据 dependencies 和 devDependencies 属性中的模块，递归获取，既工程本身是整棵依赖树的根节点(首层)，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</p><ol><li><p>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 package.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</p></li><li><p>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</p></li><li><p>查找该模块依赖，如果有依赖则回到第 1 步，如果没有则停止。</p></li></ol></li><li><p>当前 npm 工程如果定义了钩子此时会被执行（按照 preinstall、install、postinstall、prepublish、prepare 的顺序），最后一步是生成或更新版本描述文件<code>package-lock.json</code>，npm install 过程完成。</p></li></ol><h2 id="缓存目录"><a href="#缓存目录" class="headerlink" title="缓存目录"></a>缓存目录</h2><p><code>npm install</code>或<code>npm update</code>命令，从 registry 下载压缩包之后，都存放在本地的缓存目录。</p><p>这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm 目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get cache</span><br></pre></td></tr></table></figure><p>缓存目录可以加速某些操作如<code>npm search或npm view</code>都会先去缓存目录里查询，然后查询不符合条件的情况下才会请求远程仓库。</p><p>由于缓存目录的存在，我们可以使用 npm 的下载缓存包来实现离线下载的功能，这个就不描述。</p><p>但由于有了<code>package-lock.json</code>后，我们会经常遇到一些由于缓存问题而无法下载包的问题，因为<code>npm install</code>之后会计算每个包的 sha1 值，然后将包与他的 sha1 值关联保存在 <code>package-lock.json</code> 里面,下次 <code>npm install</code> 的时候会根据 <code>package-lock.json</code> 里面保存的 sha1 值去文件夹 %AppData%/npm-cache 里面寻找包文件，如果存在，就不用再次从远程仓库下载。</p><p>因为 npm 不同版本算出来的 sha1 有可能不完全一样，所以 npm 升级了，直接用不同版本 npm 生成的<code>package-lock.json</code>会报 sha1 不匹配的 error。</p><h4 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h4><p><code>npm cache verify</code><br>重新计算%AppData%/npm-cache 下的文件是否与 sha1 值匹配，如果不匹配可能删除。</p><p><code>npm cache clean --force</code><br>删除所有缓存文件</p><p><strong>注意:</strong><br>npm 5 使用了新的包管理模式，所以在升级之后，请先清空一下本地缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line">// 清除失败，使用这个</span><br><span class="line">npm cache clear --force &amp;&amp; npm install --no-shrinkwrap --update-binary</span><br></pre></td></tr></table></figure><h2 id="模块扁平化"><a href="#模块扁平化" class="headerlink" title="模块扁平化"></a>模块扁平化</h2><p>由于 npm2 安装多级的依赖模块采用嵌套的安装方式，可能造成相同模块大量冗余的问题。<br>所以 npm3 后会<strong>尽量</strong>把逻辑上某个层级的模块在物理结构上<strong>全部</strong>放在项目的第一层级(首层)里。</p><p>具体概括为以下三种情况：</p><ol><li>在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级</li><li>在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块</li><li>在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方，既在当前二级模块下生成一个 node_modules 存放依赖模块。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="2" title="">                </div>                <div class="image-caption">2</div>            </figure><p>实际上：npm3 后 仍然可能出现模块冗余的情况，如因为一级目录下已经有 v1.0 的 C 模块了，所以所有的 v2.0 只能作为二级依赖模块被安装，这样你就会看到如下的情况</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><p>而这种怎么解决了，我们要把依赖 v1.0 的模块更新到 v2.0，然后<code>npm dedupe</code>把 v2.0 放置到一个目录里，去除冗余模块<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.png" alt="3" title="">                </div>                <div class="image-caption">3</div>            </figure></p><h4 id="重复模块定义"><a href="#重复模块定义" class="headerlink" title="重复模块定义"></a>重复模块定义</h4><p>它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。<br>因为<code>package.json</code>里的依赖包默认情况下使用<code>^</code>,这只能确定大版本相同，而这也导致每次根据<code>package.json</code>安装依赖时依赖包有版本偏差的问题，如作者修改一个 BUG，发布了个小版本，而你刚刚好又重新安装了，然后你没有问题，而你同事没有安装，出现 BUG，但从<code>package.json</code>上是无法体现的，在不了解<code>^</code>的情况下是很难排查的，但你可以根据<code>package-lock.json</code>知道你那个包更新了、和你同事不一致或在项目下载依赖时都根据<code>package-lock.json</code>去下载。</p><h2 id="npm-ci"><a href="#npm-ci" class="headerlink" title="npm ci"></a>npm ci</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ci</span><br></pre></td></tr></table></figure><p>该命令与相似 npm-install，不同之处在于它用于自动化环境（例如测试平台，持续集成和部署），或者在任何情况下都要确保干净安装依赖项。通过跳过某些面向用户的功能，它可以比常规的 npm 安装快得多。它也比常规安装更加严格，这可以帮助捕获大多数 npm 用户增量安装的本地环境引起的错误或不一致。</p><p>简而言之，使用 npm install 和之间的主要区别 npm ci 是：</p><ol><li>该项目必须具有现有的 package-lock.json 或 npm-shrinkwrap.json。</li><li>如果程序包锁中的依赖项与中的不匹配 package.json，npm ci 则将退出并显示错误，而不是更新程序包锁。</li><li>npm ci 一次只能安装整个项目：不能使用此命令添加单个依赖项。</li><li>如果 node_modules 已经存在，它将在 npm ci 开始安装之前自动删除。</li><li>它将永远不会写入 package.json 或执行任何软件包锁：安装实际上是冻结的。</li></ol><p><a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noopener">npm 模块安装机制简介</a><br><a href="https://www.zhihu.com/question/66629910" target="_blank" rel="noopener">npm install 的实现原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从输入-npm-install-后&quot;&gt;&lt;a href=&quot;#从输入-npm-install-后&quot; class=&quot;headerlink&quot; title=&quot;从输入 npm install 后&quot;&gt;&lt;/a&gt;从输入 npm install 后&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;项</summary>
      
    
    
    
    
    <category term="npm" scheme="https://793338023.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>webpack之plugin实现与vscode调试方式</title>
    <link href="https://793338023.github.io/2020/04/06/webpack%E4%B9%8Bplugin%E5%AE%9E%E7%8E%B0%E4%B8%8Evscode%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/"/>
    <id>https://793338023.github.io/2020/04/06/webpack%E4%B9%8Bplugin%E5%AE%9E%E7%8E%B0%E4%B8%8Evscode%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/</id>
    <published>2020-04-06T15:09:35.000Z</published>
    <updated>2020-04-07T14:51:29.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>由于 loader 作用范围是很明显的，所以就有了它的边界，那么超出这个边界的事情我们就可以使用 Plugin 去实现，这样 webpack 就可以适用用各种各样的场景，如 loader 很困难直接对多种规则的内容进行最后的整合然后输出，而且 loader 之间有顺序规则之类，如果规则与规则之间有关联且要按某种顺序进行执行，那么就很难实现，而这是使用 Plugin 实现是最好的。</p><p>Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。</p><p>一旦我们打开了 webpack 编译器和每个单独编译的大门，我们可以使用引擎做的事情是无限可能的。我们可以重新格式化存在的文件、创建派生文件、完全伪造一个新文件。</p><h4 id="编一个-Plugin"><a href="#编一个-Plugin" class="headerlink" title="编一个 Plugin"></a>编一个 Plugin</h4><p>TestPlugin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class TestPlugin &#123;</span><br><span class="line">  constructor(doneCallback, failCallback) &#123;</span><br><span class="line">    this.doneCallback = doneCallback;</span><br><span class="line">    this.failCallback = failCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.emit.tapAsync(&quot;生成md&quot;, (compilation, callback) =&gt; &#123;</span><br><span class="line">      var filelist = &quot;构成生成的文件:\n\n&quot;;</span><br><span class="line">      for (var filename in compilation.assets) &#123;</span><br><span class="line">        filelist += &quot;- &quot; + filename + &quot;\n&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      compilation.assets[&quot;filelist.md&quot;] = &#123;</span><br><span class="line">        source: function () &#123;</span><br><span class="line">          return filelist;</span><br><span class="line">        &#125;,</span><br><span class="line">        size: function () &#123;</span><br><span class="line">          return filelist.length;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      callback();</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.hooks.done.tap(&quot;完成成功&quot;, (stats) =&gt; &#123;</span><br><span class="line">      this.doneCallback(stats);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.hooks.failed.tap(&quot;完成失败&quot;, (err) =&gt; &#123;</span><br><span class="line">      this.failCallback(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = TestPlugin;</span><br></pre></td></tr></table></figure><p>webpack.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new TestPlugin(</span><br><span class="line">    (p) =&gt; &#123;</span><br><span class="line">      console.log(&quot;w完成-&quot;, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&quot;w失败-&quot;, p);</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>Webpack 启动后，在读取配置的过程中会先执行 new TestPlugin(options) 初始化一个 TestPlugin 获得其实例。<br>在初始化 compiler 对象后，再调用 TestPlugin.apply(compiler) 给插件实例传入 compiler 对象。<br>插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。<br>并且可以通过 compiler 对象去操作 Webpack。<br>但 Compiler 和 Compilation 都继承自 Tapable，所以我们可以使用 compilation.hooks.someHook.tap(…)等监听到广播出来的事件。<br>但 apply 与 plugin 自定义比较简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 广播出事件</span><br><span class="line">* event-name 为事件名称，注意不要和现有的事件重名</span><br><span class="line">* params 为附带的参数</span><br><span class="line">*/</span><br><span class="line">compiler.apply(&apos;event-name&apos;,params);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。</span><br><span class="line">* 同时函数中的 params 参数为广播事件时附带的参数。</span><br><span class="line">*/</span><br><span class="line">compiler.plugin(&apos;event-name&apos;,function(params) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>不管是 npm 还是 webpack 都是基于 nodejs 的工具。所以最终是调试 node。</p><h3 id="npm-方式调试"><a href="#npm-方式调试" class="headerlink" title="npm 方式调试"></a>npm 方式调试</h3><p>package.json 文件 scripts 项中添加一个 key 为 debug 的配置，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;debug&quot;: &quot;node --inspect-brk=5858 ./node_modules/webpack/bin/webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>vscode <code>Ctrl+shift+D</code>切换为调试，选择<code>Add Configuration</code>。vscode 会自动生成一个 launch.json 文件，将文件的内容调整为以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;build&quot;,</span><br><span class="line">      &quot;stopOnEntry&quot;: false,</span><br><span class="line">      &quot;runtimeExecutable&quot;: &quot;npm&quot;,</span><br><span class="line">      &quot;runtimeArgs&quot;: [&quot;run&quot;, &quot;debug&quot;],</span><br><span class="line">      &quot;port&quot;: 5858</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runtimeExecutable 要运行的 shell,runtimeArgs shell 运行时需要的的参数，这个类似 Node.js 的 <a href="https://iojs.org/api/child_process.html" target="_blank" rel="noopener">child_process</a> 模块的 spawn。</p><p>其中端口 port 配置需要和 inspect-brk 配置的端口保持一致。stopOnEntry 为 true 表示在运行的第一行代码中添加断点,点击开始调试按钮，即可进入如下界面</p><p>然后我们就可以在代码的行数上点击出现小红点，就为打上断点了。</p><h3 id="运行-node-调试"><a href="#运行-node-调试" class="headerlink" title="运行 node 调试"></a>运行 node 调试</h3><p>由于上面的调试方式需要在 package 里配置，program 将要进行调试的程序的路径，但 program 可以把运行路径写入，那么就可以直接触发 webpack 而进入调试，不用在项目加入任何配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;webpack&quot;,</span><br><span class="line">      &quot;stopOnEntry&quot;: false,</span><br><span class="line">      &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/node_modules/webpack/bin/webpack&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们还可以把调试放到 chrome 里，这个就不在这里配置了。</p><p>所谓的调试都是在 node 上进行了，而已都需要 <code>--inspect-brk</code>开启出一个调试服务。</p><h3 id="一些常用配置说明"><a href="#一些常用配置说明" class="headerlink" title="一些常用配置说明"></a>一些常用配置说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 配置名称，将会在启动配置的下拉菜单中显示</span><br><span class="line">    &quot;name&quot;: &quot;C++ Launch (GDB)&quot;,</span><br><span class="line">    // 配置类型，这里只能为cppdbg</span><br><span class="line">    &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">    // 请求配置类型，可以为launch（启动）或attach（附加）</span><br><span class="line">    &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">    // 调试器启动类型，这里只能为Local</span><br><span class="line">    &quot;launchOptionType&quot;: &quot;Local&quot;,</span><br><span class="line">    // 生成目标架构，一般为x86或x64,</span><br><span class="line">    // 可以为x86, arm, arm64, mips, x64, amd64, x86_64</span><br><span class="line">    &quot;targetArchitecture&quot;: &quot;x86&quot;,</span><br><span class="line">        // 将要进行调试的程序的路径</span><br><span class="line">    &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">    // miDebugger的路径，注意这里要与MinGw的路径对应</span><br><span class="line">    &quot;miDebuggerPath&quot;:&quot;D:\\mingw\\bin\\gdb.exe&quot;,</span><br><span class="line">    // 程序调试时传递给程序的命令行参数，一般设为空即可</span><br><span class="line">    &quot;args&quot;: [],</span><br><span class="line">    // 设为true时程序将暂停在程序入口处，一般设置为false</span><br><span class="line">    &quot;stopAtEntry&quot;: false,</span><br><span class="line">    // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录</span><br><span class="line">    &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">    // 调试时是否显示控制台窗口，一般设置为true显示控制台</span><br><span class="line">    &quot;externalConsole&quot;: true,</span><br><span class="line">    // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc</span><br><span class="line">    &quot;preLaunchTask&quot;: &quot;g++&quot;　　</span><br><span class="line">    //传递给运行时可执行文件的可选参数。</span><br><span class="line">    &quot;runtimeArgs&quot;:[]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$&#123;workspaceRoot&#125; VS Code当前打开的文件夹</span><br><span class="line"></span><br><span class="line">$&#123;file&#125; 当前打开的文件</span><br><span class="line"></span><br><span class="line">$&#123;relativeFile&#125; 相对于workspaceRoot的相对路径</span><br><span class="line"></span><br><span class="line">$&#123;fileBasename&#125; 当前打开文件的文件名</span><br><span class="line"></span><br><span class="line">$&#123;fileDirname&#125; 所在的文件夹，是绝对路径</span><br><span class="line"></span><br><span class="line">$&#123;fileExtname&#125; 当前打开文件的拓展名，如.json</span><br></pre></td></tr></table></figure><h2 id="github-例子"><a href="#github-例子" class="headerlink" title="github 例子"></a><a href="https://github.com/793338023/webpack-plugin-test" target="_blank" rel="noopener">github 例子</a></h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol><li><p>这篇资料讲的很详细，上面就不进行详细了。<br><a href="https://segmentfault.com/a/1190000012840742" target="_blank" rel="noopener">Webpack 原理-编写 Plugin</a><br><a href="https://github.com/xiaoxiangdaiyu/w-loader/blob/master/plugin/DOC.md" target="_blank" rel="noopener">如何开发一个 plugin 例子</a></p></li><li><p>以下都是钩子的 API，不懂的可以进行查询<br><a href="https://www.webpackjs.com/api/plugins/#tapable" target="_blank" rel="noopener">webpack 官网-Tapable</a><br><a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener">webpack 官网-compiler API</a><br><a href="https://www.webpackjs.com/api/compilation-hooks/" target="_blank" rel="noopener">webpack 官网-compilation API</a></p></li><li><p>以下都是 vscode 调试相关的，比如怎么调试 webpack 插件或 loader<br><a href="https://www.bbsmax.com/A/D854PWOY5E/" target="_blank" rel="noopener">vscode 调试 webpack</a><br><a href="https://blog.csdn.net/ustczhng2012/article/details/102579346" target="_blank" rel="noopener">vscode 中 launch.json 部分配置项解释</a><br><a href="https://code.visualstudio.com/docs/editor/debugging#_launch-configurations" target="_blank" rel="noopener">VS Code 调试</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Plugin&quot;&gt;&lt;a href=&quot;#Plugin&quot; class=&quot;headerlink&quot; title=&quot;Plugin&quot;&gt;&lt;/a&gt;Plugin&lt;/h2&gt;&lt;p&gt;由于 loader 作用范围是很明显的，所以就有了它的边界，那么超出这个边界的事情我们就可以使用 Plugi</summary>
      
    
    
    
    
    <category term="webpack" scheme="https://793338023.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-externals</title>
    <link href="https://793338023.github.io/2020/04/05/webpack-externals/"/>
    <id>https://793338023.github.io/2020/04/05/webpack-externals/</id>
    <published>2020-04-05T09:21:37.000Z</published>
    <updated>2020-04-05T10:13:43.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>webpack5 出了 federated-modules，对于对微前端有需求的项目来说，无疑是一个好消息，因为它解决跨应用之间的共享模块。<br>而这也是微前端的核心功能之一。</p><p><a href="https://github.com/sorrycc/test-federated-modules" target="_blank" rel="noopener">github 例子</a><br><a href="https://zhuanlan.zhihu.com/p/117252835" target="_blank" rel="noopener">federated-modules 资料</a></p><p>而这个功能还在试行阶段，在这之前一般都是使用 externals 解决这种跨应用问题，当然 externals 不止这些作用，还可以优化编译速度。</p><h2 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h2><p>externals 是 webpack 的外部扩展，例如我们想引用一个库，但是又不想让 webpack 打包，并且又不影响我们在程序中以 CMD、AMD 或者 window/global 全局等方式进行使用，那就可以通过配置 externals。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用，从中可知完全符合微前端糅合项目。</p><p>当然它在优化方面是很棒的。<br>如我们在使用 js 库如 react-dom 或者 react 等的时候，webpack 会将他们一起打包，react 和 react-dom 文件就好几百 k，全部打包成一个文件，可想而知，这个文件会很大，用户在首次打开时往往会出现白屏等待时间过长的问题，这时，我们就需要将这类文件抽离出来，那么我们就可以 externals 的方式引入。也就是说，自己的库本身不打包这个 react-dom、react，需要用户环境提供，也优化了开发与打包的编译速度。</p><ol><li>项目中正常使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>webpack 配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">      react: &quot;React&quot;,</span><br><span class="line">      &quot;react-dom&quot;: &quot;ReactDOM&quot;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ol start="3"><li>需要 html 引入 js</li></ol><p>直接 index.html 引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/react/16.13.1/umd/react.production.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.13.1/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>html-webpack-plugin 方式引入，因为 html-webpack-plugin 可以使用 ejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    //...</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">            filename: &apos;index.html&apos;,</span><br><span class="line">            template: `/public/template.ejs`,</span><br><span class="line">            //...</span><br><span class="line">            // 添加参数SCRIPTS，后面母版页会使用</span><br><span class="line">            SCRIPTS: [</span><br><span class="line">https://cdn.bootcss.com/react/16.13.1/umd/react.production.min.js,</span><br><span class="line">https://cdn.bootcss.com/react-dom/16.13.1/umd/react-dom.production.min.js</span><br><span class="line">            ],</span><br><span class="line">        &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>template.ejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% htmlWebpackPlugin.options.SCRIPTS.forEach(function(url)) &#123; %&gt;</span><br><span class="line">&lt;script src=&quot;&lt;%=url %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br></pre></td></tr></table></figure><p>如果你写的库要支持各种环境，你需要设置 output 中的 libraryTarget 为 umd，也就是将打包的文件，生成为 umd 规范，适用于各种环境。libraryTarget 和 externals 关系紧密，如果出现不符合的，你可以使用 webpack 打包为 umd，webpack 打包出的名称与 externals 的 value 保持一致。</p><p>externals 配置一般都是使用 object，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  &quot;lodash&quot;: &#123;</span><br><span class="line">        commonjs: &quot;lodash&quot;,//如果我们的库运行在Node.js环境中，import _ from &apos;lodash&apos;等价于const _ = require(&apos;lodash&apos;)</span><br><span class="line">        commonjs2: &quot;lodash&quot;,//同上</span><br><span class="line">        amd: &quot;lodash&quot;,//如果我们的库使用require.js等加载,等价于 define([&quot;lodash&quot;], factory);</span><br><span class="line">        root: &quot;_&quot;//如果我们的库在浏览器中使用，需要提供一个全局的变量‘_’，等价于 var _ = (window._) or (_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">externals: &#123;</span><br><span class="line">  react: &quot;React&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="externals-详细资料"><a href="#externals-详细资料" class="headerlink" title="externals 详细资料"></a><a href="https://www.tangshuang.net/3343.html" target="_blank" rel="noopener">externals 详细资料</a></h4><p>externals 是需要网络环境的支持的，如果一定要本地就支持，可以使用 <a href="https://segmentfault.com/a/1190000016567986" target="_blank" rel="noopener">DllPlugin</a><br>只是 DllPlugin 需要在项目里配置符合它的打包配置，项目内有一个专门打包静态不常变的配置与存放它的文件，因为与项目打包文件夹在每次打包都要被删除的，所以不能放在那。</p><h4 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h4><p>webpack 配置 ProvidePlugin 后，在使用时将不再需要 import 和 require 进行引入，直接使用即可。<br>既配置它后我们可以直接在 window 上获取到方法，不用模块导入。</p><p><a href="https://www.webpackjs.com/plugins/provide-plugin/" target="_blank" rel="noopener">webpack ProvidePlugin</a><br><a href="https://www.cnblogs.com/dora-zc/p/10066932.html" target="_blank" rel="noopener">ProvidePlugin 资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;webpack5 出了 federated-modules，对于对微前端有需求的项目来说，无疑是一个好消息，因为它解决跨应用之间的共享模块。</summary>
      
    
    
    
    
    <category term="webpack" scheme="https://793338023.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>超简单的搭建功能完善的组件开发库</title>
    <link href="https://793338023.github.io/2020/04/04/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BA%93/"/>
    <id>https://793338023.github.io/2020/04/04/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BA%93/</id>
    <published>2020-04-04T12:11:56.000Z</published>
    <updated>2020-04-04T12:31:16.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建组件开发库，往往要有很多打包工具知识，从中选择符合当前需求的，如要有 webpack、rollup、gulp、单元测试、eslint、typescript 等等知识，如果想搭建一个理想好用的，还要会使用 node 写命令或脚手架。</p><p>但阿里的前端工具生态已经有很好用工具可开箱即可，免去入门门槛，dumi。</p><p><strong><a href="https://github.com/793338023/components-lib" target="_blank" rel="noopener">详细文档请移步 github 查看，里面有个例子项目</a></strong></p><p><strong>2020/4/4 清明-全国哀悼</strong><br><strong>首先默哀三分钟</strong></p><p>今天看到网站都是灰色的，怎么做到了，使用了 filter 的 grayscale 实现的，只要在顶层 html 使用 filter，就实现了整个网站灰色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    -webkit-filter: grayscale(100%);</span><br><span class="line">    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;搭建组件开发库，往往要有很多打包工具知识，从中选择符合当前需求的，如要有 webpack、rollup、gulp、单元测试、eslint、t</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="https://793338023.github.io/2020/04/01/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://793338023.github.io/2020/04/01/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-01T12:43:07.000Z</published>
    <updated>2020-05-02T03:03:00.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="职责链的定义"><a href="#职责链的定义" class="headerlink" title="职责链的定义"></a>职责链的定义</h2><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h2 id="在以下场景中可以考虑使用责任链模式"><a href="#在以下场景中可以考虑使用责任链模式" class="headerlink" title="在以下场景中可以考虑使用责任链模式"></a>在以下场景中可以考虑使用责任链模式</h2><ol><li>一个系统的审批需要多个对象才能完成处理的情况下，例如报销系统等。</li><li>代码中存在多个 if-else 语句的情况下，此时可以考虑使用责任链模式来对代码进行重构。</li></ol><h2 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">export class Stack &#123;</span><br><span class="line">  next: any = null;</span><br><span class="line">  fn: Function | any = null;</span><br><span class="line">  constructor(fn: Function) &#123;</span><br><span class="line">    this.fn = fn;</span><br><span class="line">  &#125;</span><br><span class="line">  setNextStack = (stack: any) =&gt; &#123;</span><br><span class="line">    this.next = stack;</span><br><span class="line">  &#125;;</span><br><span class="line">  passRequest = (...args: any[]) =&gt; &#123;</span><br><span class="line">    const [status, ret] = this.fn(...args);</span><br><span class="line">    if (typeof status === &quot;boolean&quot; &amp;&amp; status) &#123;</span><br><span class="line">      if (this.next) &#123;</span><br><span class="line">        if (Array.isArray(ret)) &#123;</span><br><span class="line">          this.next.passRequest(...ret);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.next.passRequest(ret);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line">function coupon100(pay: number, num: number) &#123;</span><br><span class="line">  if (pay * num &gt; 100) &#123;</span><br><span class="line">    console.log(`已经优惠了100，实付$&#123;pay * num - 100&#125;`);</span><br><span class="line">    return [false, `已经优惠了100，实付$&#123;pay * num - 100&#125;`];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return [true, [pay, num]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function coupon50(pay: number, num: number) &#123;</span><br><span class="line">  if (pay * num &gt; 50) &#123;</span><br><span class="line">    console.log(`已经优惠了50，实付$&#123;pay * num - 50&#125;`);</span><br><span class="line">    return [false, `已经优惠了50，实付$&#123;pay * num - 50&#125;`];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return [true, [pay, num]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function coupon200(pay: number, num: number) &#123;</span><br><span class="line">  if (pay * num &gt; 200) &#123;</span><br><span class="line">    console.log(`已经优惠了200，实付$&#123;pay * num - 200&#125;`);</span><br><span class="line">    return [false, `已经优惠了200，实付$&#123;pay * num - 200&#125;`];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return [true, [pay, num]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const stack200 = new Stack(coupon200);</span><br><span class="line">const stack100 = new Stack(coupon100);</span><br><span class="line">const stack50 = new Stack(coupon50);</span><br><span class="line"></span><br><span class="line">stack200.setNextStack(stack100);</span><br><span class="line">stack100.setNextStack(stack50);</span><br><span class="line"></span><br><span class="line">stack200.passRequest(43, 2);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;职责链的定义&quot;&gt;&lt;a href=&quot;#职责链的定义&quot; class=&quot;headerlink&quot; title=&quot;职责链的定义&quot;&gt;&lt;/a&gt;职责链的定义&lt;/h2&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://793338023.github.io/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>chrome插件开发与为什么数据埋点请求使用图片</title>
    <link href="https://793338023.github.io/2020/03/29/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/"/>
    <id>https://793338023.github.io/2020/03/29/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/</id>
    <published>2020-03-29T12:52:24.000Z</published>
    <updated>2020-03-29T13:07:32.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="chrome-插件-使用-vue-实现"><a href="#chrome-插件-使用-vue-实现" class="headerlink" title="chrome 插件-使用 vue 实现"></a><a href="https://github.com/793338023/chrome_demo" target="_blank" rel="noopener">chrome 插件-使用 vue 实现</a></h2><h2 id="为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片"><a href="#为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片" class="headerlink" title="为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片"></a>为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片</h2><ol><li><p>避免跨域（img 天然支持跨域）</p></li><li><p>利用空白 gif 或 1x1 px 的 img 是互联网广告或网站监测方面常用的手段，简单、安全、相比 PNG/JPG 体积小，1px 透明图，对网页内容的影响几乎没有影响，这种请求用在很多地方，比如浏览、点击、热点、心跳、ID 颁发等等，</p></li><li><p>图片请求不占用 Ajax 请求限额</p></li><li><p>GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）</p></li><li><p>不会阻塞页面加载，影响用户的体验，只要 new Image 对象就好了，一般情况下也不需要 append 到 DOM 中，通过它的 onerror 和 onload 事件来检测发送状态。</p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><p>首先要在服务器上放一张 1X1 的 gif 图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> var thisPage = location.href;</span><br><span class="line"> var referringPage = (document.referrer) ? document.referrer : &quot;none&quot;;</span><br><span class="line"> var beacon = new Image();</span><br><span class="line"> beacon.src = &quot;http://img.soogif.com/00VBBS2KfqyZJb18GVJyL9jUuw1iSTDF.gif?page=&quot; + encodeURI(thisPage)</span><br><span class="line"> + &quot;&amp;ref=&quot; + encodeURI(referringPage);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;chrome-插件-使用-vue-实现&quot;&gt;&lt;a href=&quot;#chrome-插件-使用-vue-实现&quot; class=&quot;headerlink&quot; title=&quot;chrome 插件-使用 vue 实现&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/7</summary>
      
    
    
    
    
    <category term="chrome" scheme="https://793338023.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>fiddler代理方式</title>
    <link href="https://793338023.github.io/2020/03/25/fiddler%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>https://793338023.github.io/2020/03/25/fiddler%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-25T15:31:05.000Z</published>
    <updated>2020-09-19T07:58:42.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="请求转发到本地文件"><a href="#请求转发到本地文件" class="headerlink" title="请求转发到本地文件"></a>请求转发到本地文件</h2><p>身为一名前端，当为了调试某些情况下请求的返回参数需要人为改动来调试时，可以使用 AutoResponder<br>如:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.PNG" alt="本地转发" title="">                </div>                <div class="image-caption">本地转发</div>            </figure><br>配置规则为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex:https://www.juhe.cn/loginStatus</span><br><span class="line"></span><br><span class="line">C:\Users\M\Desktop\data.json</span><br></pre></td></tr></table></figure><p>带 regex:为正则匹配，否则就是完全匹配。</p><h2 id="使用-fiddlerScript-代理"><a href="#使用-fiddlerScript-代理" class="headerlink" title="使用 fiddlerScript 代理"></a>使用 fiddlerScript 代理</h2><p>fiddlerScript 时 js 代码，灵活度比较高。<br>我们只要操作 oSession 对象即可</p><p>首先我们现在请求前<code>OnBeforeRequest</code>方法添加要修改的地址。<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 电影天堂替换为动漫</span><br><span class="line">if(oSession.url.IndexOf(&quot;www.dytt8.net&quot;)&gt;-1)&#123;</span><br><span class="line">            oSession.url = oSession.url.Replace(&quot;www.dytt8.net&quot;,&quot;www.hkdm688.com&quot;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.PNG" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="4.PNG" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.PNG" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><p>当我们请求<code>www.dytt8.net</code>地址时就会替换为<code>www.hkdm688.com</code>然后再做真正的请求。</p><p>而 fiddlerScript 的<code>OnBeforeRequest</code>是优先于 AutoResponder 的，所以我们在 fiddlerScript 修改的，可以在 AutoResponder 再次调整。</p><p><a href="https://blog.csdn.net/u010142437/article/details/73285964" target="_blank" rel="noopener">资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;请求转发到本地文件&quot;&gt;&lt;a href=&quot;#请求转发到本地文件&quot; class=&quot;headerlink&quot; title=&quot;请求转发到本地文件&quot;&gt;&lt;/a&gt;请求转发到本地文件&lt;/h2&gt;&lt;p&gt;身为一名前端，当为了调试某些情况下请求的返回参数需要人为改动来调试时，可以使用 Au</summary>
      
    
    
    
    
    <category term="调试" scheme="https://793338023.github.io/tags/调试/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="https://793338023.github.io/2020/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://793338023.github.io/2020/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-12T15:11:51.000Z</published>
    <updated>2020-03-12T15:36:40.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂模式的目的是为了创建对象，它通常在类或者类的静态方法中实现，具有以下目标：</p><p>当创建相似对象时执行重复操作<br>当编译时不知道具体类型的情况下，为工厂客户提供一个创建对象的接口<br>与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。</p><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><p>这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类类定义需要创建的对象类型。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var func = (function () &#123;</span><br><span class="line">    const Car = (model, year, miles)=&gt; &#123;</span><br><span class="line">        this.model = model;</span><br><span class="line">        this.year = year;</span><br><span class="line">        this.miles = miles;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const Bus = (color,sign,size)=&gt;&#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">        this.sign = sign;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const obj=&#123;</span><br><span class="line">        car: Car,</span><br><span class="line">        bus: Bus</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        const [type,...rargs] = args;</span><br><span class="line">        const Exa = obj[type];</span><br><span class="line">        return new Exa(...rargs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a = func(&quot;car&quot;,&quot;xom&quot;, 200, 899);</span><br><span class="line">var b = func(&quot;bus&quot;, &quot;red&quot;, &quot;rr&quot;,10);</span><br></pre></td></tr></table></figure><p>上面的是简单工厂模式</p><p>当然还有工厂方法模式与抽象工厂模式，简单工厂模式应该就够实现大部分需要工厂模式的场景。</p><p>设计模式只是为了解决一些问题，其实它们之间有时是比较类似的，只是实现时有点差异，其实工作久了，也会不知不觉就使用上设计模式。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>那么什么时候使用工厂模式呢，以下几种情景下工厂模式特别有用：</li></ol><p>对象的构建十分复杂<br>需要依赖具体环境创建不同实例<br>处理大量具有相同属性的小对象</p><ol start="2"><li>什么时候不该用工厂模式：</li></ol><p>不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂模式的目的是为了创建对象，它通常在类或者类的静态方法中实现，具有以下目标：&lt;/p&gt;
&lt;p&gt;当创建相似对象时执行重复操作&lt;br&gt;当编译时不</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://793338023.github.io/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="https://793338023.github.io/2020/03/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://793338023.github.io/2020/03/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-11T15:09:23.000Z</published>
    <updated>2020-03-12T14:54:44.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>定义一系列算法，把他们各自封装成策略类，然后把不变的部分和变化的部分分离开来，其中包括策略类和环境类(Context)。</p><p>这里的算法可以理解为用于处理逻辑的方法。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>经典例子:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const strategies = &#123;</span><br><span class="line">    &quot;Q2&quot;:(s)=&gt; s*2,</span><br><span class="line">    &quot;Q3&quot;:(s)=&gt; s*3,</span><br><span class="line">    &quot;Q4&quot;:(s)=&gt; s*4,</span><br><span class="line">    &quot;Q5&quot;:(s)=&gt; s*5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const calculateBouns = (name,param)=&gt;&#123;</span><br><span class="line">    return strategies[name](param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(calculateBouns(&quot;Q2&quot;,23));</span><br><span class="line">console.log(calculateBouns(&quot;Q3&quot;,23));</span><br><span class="line">console.log(calculateBouns(&quot;Q4&quot;,23));</span><br></pre></td></tr></table></figure><p>使用<code>calculateBouns</code> 环境类调用对应的策略方法。</p><p>使用前先找到判断的不同点，当参数传入，共同点放在环境类里，然后根据入参值选择对应的策略方法。</p><p>而常用在一些判断规则明确的场景，如表单校验方法，根据场景选择运动算法。</p><p>以上的场景在网上都很容易找到，以下结合实际在 redux 中使用。</p><ol start="2"><li>reducer 使用策略模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 策略类</span><br><span class="line">const makeTitle = (state, action)=&gt;&#123;</span><br><span class="line">    return &#123; ...state, title: action.payload &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const makeTitle2 = (state, action)=&gt;&#123;</span><br><span class="line">    return &#123; ...state, title2: action.payload &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let reducerMap = &#123;&#125;;</span><br><span class="line">reducerMap[actionType.PG_COMMON_TITLE] = makeTitle;</span><br><span class="line">reducerMap[actionType.PG_COMMON_TITLE2] = makeTitle2;</span><br><span class="line"></span><br><span class="line">// 环境类</span><br><span class="line">export default function reducer(state,action) &#123;</span><br><span class="line">  const &#123; type &#125; = action;</span><br><span class="line">  if (reducerMap.hasOwnProperty(type)) &#123;</span><br><span class="line">    return reducerMap[type](state, action);</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用 redux 频繁时会出现<code>switch/case</code>或<code>if/else</code>，那么导致在这里函数庞大且不好理解，圈复杂度很高，但我们把 action 对应的 reduce 处理逻辑分到对应的函数里时，那么处理逻辑清晰且好维护。</p><ol start="3"><li>在的组件的使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Input = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Select = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;select name=&quot;a&quot; id=&quot;a&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;q&quot;&gt;1&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;2&quot;&gt;3&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Empty = () =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;没有选中&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义策略</span><br><span class="line">const COMPONENTS = &#123;</span><br><span class="line">  select: Select,</span><br><span class="line">  text: Input</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义环境类组件</span><br><span class="line">export default class EnvComponent extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const componentType = this.props.type;</span><br><span class="line">    const SelectedComponent = COMPONENTS[componentType] || Empty;</span><br><span class="line">    return &lt;SelectedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class demo extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      components: [</span><br><span class="line">        &#123; type: &quot;text&quot;, value: &quot;123&quot; &#125;,</span><br><span class="line">        &#123; type: &quot;select&quot;, value: &quot;4&quot; &#125;,</span><br><span class="line">        &#123; type: &quot;xxx&quot;, value: &quot;123&quot; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; components &#125; = this.state;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;components.map((item, index) =&gt; &#123;</span><br><span class="line">          return &lt;EnvComponent key=&#123;index&#125; &#123;...item&#125; /&gt;;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式在明确判断规则并且圈复杂度比较高的，可以考虑使用策略模式。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><p>1、利用组合、委托和多态技术和思想，可以避免多重条件选择语句；<br>2、将算法封装在独立的策略类里，使得易于切换，易于理解，易于扩展；<br>3、策略模式可以复用在系统的其他地方，从而避免重复的复制粘贴工作；<br>4、策略模式利用组合和委托让环境类拥有执行算法的能力，从而替代继承。</p><p>缺点：</p><p>1、程序中会增加许多策略类或者策略对象；<br>2、使用策略类必须要对所有的策略类算法了解清楚，否则不知道怎么选择，就是对判断规则有规律可循，那么就可以想出对应的环境类，由经过环境类选择策略类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;h3 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; title=&quot;定义：&quot;&gt;&lt;/a&gt;定义</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://793338023.github.io/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>npm install的坑</title>
    <link href="https://793338023.github.io/2020/03/08/install%E7%9A%84%E5%9D%91/"/>
    <id>https://793338023.github.io/2020/03/08/install%E7%9A%84%E5%9D%91/</id>
    <published>2020-03-08T12:42:58.000Z</published>
    <updated>2020-03-08T13:35:40.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h4 id="package-有两种依赖"><a href="#package-有两种依赖" class="headerlink" title="package 有两种依赖"></a>package 有两种依赖</h4><ol><li>dependencies —— 运行依赖，依赖的项该是正常运行该包时所需要的依赖项，就是开发的项目需要的包，如 ui 框架包，react 包之类的。</li><li>devDependencies —— 开发依赖，开发的时候需要的依赖项，像一些进行单元测试之类的包或 webpack 打包需要的包。</li></ol><h4 id="package-版本号详解"><a href="#package-版本号详解" class="headerlink" title="package 版本号详解"></a>package 版本号详解</h4><p>在 npm 中安装固定的版本号 package，只需要在其后加 <code>@</code>版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-core@7.0.0 -S</span><br></pre></td></tr></table></figure><p>package.json 中库的版本号详解：</p><ol><li><p><code>~</code> 匹配最近的小版本依赖包，比如~7.0.0 会匹配所有 7.0.x 版本，但是不包括 7.1.0，如果 7.0.x 最新的版本是 7.0.8，那么就会安装这个版本</p></li><li><p><code>^</code> 匹配最新的大版本依赖包，比如^7.0.0 会匹配所有 7.x.x 的包，包括 7.9.0，但是不包括 8.0.0，如 7.x.x 最新的版本是 7.8.7，那么就会安装这个版本</p></li><li><p><code>*</code> 意味着安装最新版本的依赖包</p></li></ol><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><p>由于在 package.json 中依赖包大部分都是一个范围的版本，如<code>babel:^7.0.0</code>，那么每个从仓库拉下来的开发者都会遵循装包规则，安装这个范围版本最新的，那么就导致一个现象就是你与同事的依赖包不一致，而你的包有 BUG，但你同事没有，而导致有时难以确认问题所在，或者公司自己搭建了 npm 私仓，但最近在 npm 仓库上有新的包更新，但公司的私仓没有同步到位，导致装包时找不到包，但由于这个包是依赖包的包，导致你也不能固定它的版本而导致你无法正常下载包的问题。</p><p>解决方法:</p><ol><li>那么这些问题其实可以使用<code>package-lock.json</code>解决，因为它记录了整个 <code>node_modules</code> 文件夹的树状结构，甚至连模块的下载地址都记录了，<code>npm install</code>时会根据 <code>package-lock.json</code> 文件指定的结构来下载模块，并不会理会 <code>package.json</code> 文件，而它也提升了装包速度。</li></ol><p>但以后修改 <code>package.json</code> 文件相应模块的版本号，再执行 <code>npm install</code> 不会更新了，只能手动 <code>npm install name@version</code> 指定版本号来安装。</p><ol start="2"><li>若项目里没有<code>package-lock.json</code>，那么我们可以使用 yarn 去解决，因为 yarn 出现就是为了解决 npm 的一些缺陷，它与 npm 功能类似而且完全兼容，在项目中可以切换使用，它们都是一个对包操作的工具而已，而 yarn 对某些不存在的包版本但这个版本范围之类还是有包存在的会出现询问交互操作，那么我们就可以选定某个版本，而 npm 就不行，当版本不存在，它就会报错，让人无法安装包，然后 yarn 生成 yarn.lock，这个和<code>package.json</code>一样的，最早时 yarn 实现的，为了版本一致，提升速度。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn install --non-interactive</span><br><span class="line"></span><br><span class="line">禁用询问交互，比如当没有合适版本的依赖时</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yarn install --flat</span><br><span class="line"></span><br><span class="line">安装所有依赖，但每个依赖只允许有一个版本存在。 第一次运行这个命令时，会提示你在每个依赖包的多个版本范围中选择一个版本。 这会被添加到你的 package.json 文件的 resolutions 字段。</span><br><span class="line"></span><br><span class="line">&quot;resolutions&quot;: &#123;</span><br><span class="line">  &quot;package-a&quot;: &quot;2.0.0&quot;,</span><br><span class="line">  &quot;package-b&quot;: &quot;5.0.0&quot;,</span><br><span class="line">  &quot;package-c&quot;: &quot;1.5.2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将准确地安装yarn.lock中的内容。不更新锁定</span><br><span class="line">yarn install --frozen-lockfile</span><br><span class="line"></span><br><span class="line">不生成 yarn.lock 锁文件，并且，如果需要更新则会报错。</span><br><span class="line"></span><br><span class="line">如果需要可重现的依赖环境（比如在持续集成系统中），应该传入 --frozen-lockfile 标志。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;package&quot;&gt;&lt;a href=&quot;#package&quot; class=&quot;headerlink&quot; title=&quot;package&quot;&gt;&lt;/a&gt;package&lt;/h2&gt;&lt;h4 id=&quot;package-有两种依赖&quot;&gt;&lt;a href=&quot;#package-有两种依赖&quot; class</summary>
      
    
    
    
    
    <category term="npm" scheme="https://793338023.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>npm进阶-node_modules与自动部署装包速度提升</title>
    <link href="https://793338023.github.io/2020/03/03/npm%E8%BF%9B%E9%98%B6-node-modules%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%A3%85%E5%8C%85%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87/"/>
    <id>https://793338023.github.io/2020/03/03/npm%E8%BF%9B%E9%98%B6-node-modules%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%A3%85%E5%8C%85%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87/</id>
    <published>2020-03-03T13:37:57.000Z</published>
    <updated>2020-03-03T15:07:11.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动部署装包速度提升"><a href="#自动部署装包速度提升" class="headerlink" title="自动部署装包速度提升"></a>自动部署装包速度提升</h2><p>现在程序的开发都提倡能用技术放开双手，那就要技术解决，所以现在无论是构建、代码检查、部署或者测试，这些都有一定程度的自动化过程，减少人为操作失误，而这的主题是 npm 装包耗时过长的优化方案。</p><p>当我们本地使用 npm 装包时，因为在本地环境中安装依赖是有状态的，如 node_modules，~/.npmrc，~/.npm 一系列硬盘目录及文件，无不构成状态。而在生产环境中，往往结合 CICD 工具，每次分配的 Runner 不一定是一台服务器(容器)，往往被视为无状态，因而无法有效利用缓存而导致 CI 中部署用时过长。</p><p>但也正因为 CICD Runner 的无状态化，这意味着你只要参考构建脚本，如 .gitlab-ci.yaml，.travis.yaml 或者 .github/workflows/deploy.yaml，就可以从零把项目跑起来，而避免过多在熟悉新项目时求助他人。</p><p>那么我们应该怎么让 npm 在 CICD 上跑的更快呢？</p><p>优化一:<br>使用 –production 可以只安装 package.json 中 dependencies 中的依赖项，只把要安装在 CI 中需要使用到的依赖。在生产环境部署时可以指定 –production。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --production</span><br></pre></td></tr></table></figure><p>但这样以后装包要严格遵守装包的规则，项目使用到的都要装到 dependencies 里，这是一个缺点，会出现人为的失误导致的 BUG。</p><p>优化二:<br>使用私有镜像仓库，既公司自己搭建 npm 仓库，然后包都从公司仓库拉取。<br>对于企业级项目的生产环境来说，在集群内部搭建私有仓库是一个更好的选择，也更能缩短时延。 流量能在局域网完成的，就不需要去互联网中溜圈了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如:</span><br><span class="line">npm config set registry https://registry-npm.sisis.tech/</span><br></pre></td></tr></table></figure><p>优化三:<br>正如 http cache 一样，npm install 也可以充分利用缓存，npm 的缓存在 linux 系统中存在于以下路径:</p><p>命令 npm cache verify 可以校验缓存，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm cache verify</span><br><span class="line">Cache verified and compressed (~/.npm/_cacache):</span><br><span class="line">Content verified: 4415 (156612117 bytes)</span><br><span class="line">Index entries: 6239</span><br><span class="line">Finished in 14.017s</span><br></pre></td></tr></table></figure><p>结合 <code>npm install --prefer-offline</code> 缓存优先策略充分利用缓存</p><p>既</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm cache verify</span><br><span class="line">npm install --prefer-offline</span><br></pre></td></tr></table></figure><p>优化四:<br>使用<code>npm ci</code>装包<br>它安装依赖时，默认是缓存优先的，它会充分利用缓存，从而加速装包。<br><code>npm ci</code> 可以减少将近一半的的依赖安装时间。</p><p>优化五:<br>每次对比上一次 MR 的 package.json 与这次 MR 的 package.json，筛选出不同的地方，如包的版本不一样，新增包等，然后只安装这部分的包</p><h2 id="npm-进阶-node-modules"><a href="#npm-进阶-node-modules" class="headerlink" title="npm 进阶-node_modules"></a>npm 进阶-node_modules</h2><p>nodejs 中 package.json 中的依赖必须每个项目都有自己的 node_modules 文件夹，而无法在多个项目之间共用一套 node_modules（不像 Java 中的 Maven 那样共享一个全居仓库）。</p><p>没法共用一个 node_modules 会导致互相依赖的项目当使用是同一个包时，但由于包保存了数据需要获取出来使用而导致的报错，因为它们不是依赖同一个包，如 redux，react-router-dom 等。</p><p>依赖管理是每个现代语言的标配。在 Java 中，maven 同时兼具 依赖管理 和 打包 两大功能，而前段领域这两个功能是两种不同的工具分别提供：</p><ol><li>npm 负责依赖管理</li><li>webpack 负责打包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">依赖管理最难解决的问题就是版本问题。库A依赖库B，库C也依赖库B，但是库A跟库C所依赖的库B不是同一版本，如果库B的这两个版本兼容还好，如果不兼容就坑大发了，这是无解的问题。</span><br></pre></td></tr></table></figure><p>Java 中的 Maven 仓库在开发者电脑上是全局的，所有项目的依赖都集中存放在本地仓库中。每个项目都有 pom.xml 指明依赖本地仓库中的哪些库，如果本地仓库没有会从局域网仓库或网络仓库下载至本地仓库。<br>Node 中的依赖如果你不写 package.json，那么依赖的就是全局的库；如果写了 package.json，就会把所有依赖下载到 node_modules 文件夹</p><p>Node 这种 node_modules 文件夹的方式有利有弊。</p><p>好处:</p><ol><li>使用 package.json 安装好之后，node_modules 文件夹中没有版本信息，从而 package.json 可以删掉了。</li><li>移动/复制/打包项目比较简单，对于开发、部署都有好处</li><li>对于设计 npm 的人来说，这是最省事的包依赖方法。这就好比 maven 安装依赖之后自动将 jar 包安装到项目的 lib 里面。</li><li>随意改代码。安装在 node_modules 里面的东西，你可以随便改，无需担心对其它项目的影响。在 Java 中使用 maven 管理项目时，如果想要定制某个库，就需要更改这个库的源代码，这时就需要把这个库的源代码复制到项目中，跟 node_modules 是一个道理。npm 的设计者大概认为：前端都是经常修改库的源代码的。</li></ol><p>坏处:</p><ol><li>每次都需要安装依赖，费流量，网速慢时很费时间</li><li>浪费磁盘空间，每个 node_modules 中包含的工具很多，动辄 20M</li></ol><p>但我觉得这些坏处都不是很大的问题，应该也就浪费一些流量和几十分钟的时间，而且也不是经常全量安装包，后续开发就会单独新增包，单独安装包是很快的，并且 npm 或 yarn 之类的工具都在不断的优化，装包只会越来越快，再不济也可以是使用国内镜像或公司搭建私仓下载，这也是对装包速度很大的提升。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自动部署装包速度提升&quot;&gt;&lt;a href=&quot;#自动部署装包速度提升&quot; class=&quot;headerlink&quot; title=&quot;自动部署装包速度提升&quot;&gt;&lt;/a&gt;自动部署装包速度提升&lt;/h2&gt;&lt;p&gt;现在程序的开发都提倡能用技术放开双手，那就要技术解决，所以现在无论是构建、代</summary>
      
    
    
    
    
    <category term="npm" scheme="https://793338023.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>react-微前端</title>
    <link href="https://793338023.github.io/2020/03/02/react-%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <id>https://793338023.github.io/2020/03/02/react-%E5%BE%AE%E5%89%8D%E7%AB%AF/</id>
    <published>2020-03-02T14:59:22.000Z</published>
    <updated>2020-03-02T15:00:52.917Z</updated>
    
    <content type="html"><![CDATA[<p>当前微前端技术栈统一，仓库只有一个。 适用场景: 项目大，工程多，而都是由一个技术团队负责。</p><h2 id="github-项目详情"><a href="#github-项目详情" class="headerlink" title="github 项目详情"></a><a href="https://github.com/793338023/single-demo/blob/master/README.md" target="_blank" rel="noopener">github 项目详情</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当前微前端技术栈统一，仓库只有一个。 适用场景: 项目大，工程多，而都是由一个技术团队负责。&lt;/p&gt;
&lt;h2 id=&quot;github-项目详情&quot;&gt;&lt;a href=&quot;#github-项目详情&quot; class=&quot;headerlink&quot; title=&quot;github 项目详情&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack-离线应用</title>
    <link href="https://793338023.github.io/2020/02/15/webpack-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8/"/>
    <id>https://793338023.github.io/2020/02/15/webpack-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-15T13:23:53.000Z</published>
    <updated>2020-09-19T07:59:47.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离线缓存应用，意思就是没有网络的情况下，被缓存的资源能从本地直接返回，让应用在一定范围内能正常运行。</p><p>离线应用有以下优点：</p><ol><li>在没有网络的情况下也能打开网页。</li><li>由于部分被缓存的资源直接从本地加载，对用户来说可以加速网页加载速度，对网站运营者来说可以减少服务器压力以及传输流量费用。</li></ol><p>实现离线缓存的技术有两种:</p><ol><li>AppCache 又叫 Application Cache，目前已经从 Web 标准中删除，请尽量不要使用它。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">Service Workers</a> 是目前最新的离线缓存技术，是 Web Worker 的一部分。</li></ol><p>Service Workers 通过拦截网络请求实现离线缓存，比 AppCache 更加灵活。它也是构建 PWA 应用的关键技术之一。</p><p>出于安全原因，Service Workers 要求必须在 HTTPS 下才能运行。</p><p>在本地开发中，我们可以在启动 chrome 时让本地应用设置为安全，可以不使用 https，而使用 http，否则会报错。<br>如启动的本地应用地址为<code>http://localhost:8080/</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在终端启动chrome，chrome文件路径</span><br><span class="line">&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; --unsafely-treat-insecure-origin-as-secure=http://localhost:8080/</span><br></pre></td></tr></table></figure><h2 id="Service-Workers-兼容性"><a href="#Service-Workers-兼容性" class="headerlink" title="Service Workers 兼容性"></a>Service Workers 兼容性</h2><p>目前 Chrome、Firefox、Opera 都已经全面支持 Service Workers，但对于移动端浏览器就不太乐观了，只有高版本的 Android 支持。<br>由于 Service Workers 无法通过注入 polyfill 去实现兼容，所以在你打算使用它前请先调查清楚你的网页的运行场景。</p><p>判断浏览器是否支持 Service Workers 的最简单的方法是通过以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果 navigator 对象上存在 serviceWorker 对象，就表示支持</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  // 通过 navigator.serviceWorker 使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>要给网页接入 Service Workers，需要在网页加载后注册一个描述 Service Workers 逻辑的脚本。<br>所以编写一个 sw.js 专门包含 Service Workers 逻辑的脚本，比如缓存内容，sw.js 更新后重新加载缓存内容等等，而 sw.js 文件需要在应用入口文件加载注册。<br>如 main.js 为 webpack 的入口文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./main.css&apos;);</span><br><span class="line"></span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  window.addEventListener(&apos;DOMContentLoaded&apos;,function() &#123;</span><br><span class="line">    // 调用 serviceWorker.register 注册，参数 /sw.js 为脚本文件所在的 URL 路径</span><br><span class="line">    navigator.serviceWorker.register(&apos;sw.js&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.document.getElementById(&apos;app&apos;).innerText = &apos;Hello,Webpack&apos;;</span><br></pre></td></tr></table></figure><p>一旦这个脚本文件被加载，Service Workers 的安装就开始了。这个脚本被安装到浏览器中后，就算用户关闭了当前网页，它仍会存在。<br>也就是说第一次打开该网页时 Service Workers 的逻辑不会生效，因为脚本还没有被加载和注册，但是以后再次打开该网页时脚本里的逻辑将会生效。</p><p>在 Chrome 中可以通过打开网址 chrome://inspect/#service-workers 来查看当前浏览器中所有注册了的 Service Workers。</p><h2 id="使用-Service-Workers-实现离线缓存"><a href="#使用-Service-Workers-实现离线缓存" class="headerlink" title="使用 Service Workers 实现离线缓存"></a>使用 Service Workers 实现离线缓存</h2><p>Service Workers 在注册成功后会在其生命周期中派发出一些事件，通过监听对应的事件在特点的时间节点上做一些事情。</p><p>在 Service Workers 脚本中，引入了新的关键字 self 代表当前的 Service Workers 实例。</p><p>在 Service Workers 安装成功后会派发出 install 事件，需要在这个事件中执行缓存资源的逻辑，实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 当前缓存版本的唯一标识符，用当前时间代替</span><br><span class="line">var cacheKey = new Date().toISOString();</span><br><span class="line"></span><br><span class="line">// 需要被缓存的文件的 URL 列表</span><br><span class="line">var cacheFileList = [</span><br><span class="line">  &apos;/index.html&apos;,</span><br><span class="line">  &apos;/app.js&apos;,</span><br><span class="line">  &apos;/app.css&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 监听 install 事件</span><br><span class="line">self.addEventListener(&apos;install&apos;, function (event) &#123;</span><br><span class="line">  // 等待所有资源缓存完成时，才可以进行下一步</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheKey).then(function (cache) &#123;</span><br><span class="line">      // 要缓存的文件 URL 列表</span><br><span class="line">      return cache.addAll(cacheFileList);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来需要监听网络请求事件去拦截请求，复用缓存，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    // 去缓存中查询对应的请求</span><br><span class="line">    caches.match(event.request).then(function(response) &#123;</span><br><span class="line">        // 如果命中本地缓存，就直接返回本地的资源</span><br><span class="line">        if (response) &#123;</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则就去用 fetch 下载资源</span><br><span class="line">        return fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上就实现了离线缓存。</p><h2 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h2><p>线上的代码有时需要更新和重新发布，如果这个文件被离线缓存了，那就需要 Service Workers 脚本中有对应的逻辑去更新缓存。<br>这可以通过更新 Service Workers 脚本文件做到。<br>浏览器针对 Service Workers 有如下机制：</p><ol><li>每次打开接入了 Service Workers 的网页时，浏览器都会去重新下载 Service Workers 脚本文件（所以要注意该脚本文件不能太大），如果发现和当前已经注册过的文件存在字节差异，就将其视为“新服务工作线程”。</li><li>新 Service Workers 线程将会启动，且将会触发其 install 事件。</li><li>当网站上当前打开的页面关闭时，旧 Service Workers 线程将会被终止，新 Service Workers 线程将会取得控制权。</li><li>新 Service Workers 线程取得控制权后，将会触发其 activate 事件。</li></ol><p>新 Service Workers 线程中的 activate 事件就是最佳的清理旧缓存的时间点，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key</span><br><span class="line">var cacheWhitelist = [cacheKey];</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(function(cacheNames) &#123;</span><br><span class="line">      return Promise.all(</span><br><span class="line">        cacheNames.map(function(cacheName) &#123;</span><br><span class="line">          // 不在白名单的缓存全部清理掉</span><br><span class="line">          if (cacheWhitelist.indexOf(cacheName) === -1) &#123;</span><br><span class="line">            // 删除缓存</span><br><span class="line">            return caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>sw.js 完整代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 当前缓存版本的唯一标识符，用当前时间代替</span><br><span class="line">var cacheKey = new Date().toISOString();</span><br><span class="line"></span><br><span class="line">// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key</span><br><span class="line">var cacheWhitelist = [cacheKey];</span><br><span class="line"></span><br><span class="line">// 需要被缓存的文件的 URL 列表</span><br><span class="line">var cacheFileList = [</span><br><span class="line">  &apos;/index.html&apos;,</span><br><span class="line">  &apos;app.js&apos;,</span><br><span class="line">  &apos;app.css&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 监听 install 事件</span><br><span class="line">self.addEventListener(&apos;install&apos;, function (event) &#123;</span><br><span class="line">  // 等待所有资源缓存完成时，才可以进行下一步</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheKey).then(function (cache) &#123;</span><br><span class="line">      // 要缓存的文件 URL 列表</span><br><span class="line">      return cache.addAll(cacheFileList);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 拦截网络请求</span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function (event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    // 去缓存中查询对应的请求</span><br><span class="line">    caches.match(event.request).then(function (response) &#123;</span><br><span class="line">        // 如果命中本地缓存，就直接返回本地的资源</span><br><span class="line">        if (response) &#123;</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则就去用 fetch 下载资源</span><br><span class="line">        return fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 新 Service Workers 线程取得控制权后，将会触发其 activate 事件</span><br><span class="line">self.addEventListener(&apos;activate&apos;, function (event) &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(function (cacheNames) &#123;</span><br><span class="line">      return Promise.all(</span><br><span class="line">        cacheNames.map(function (cacheName) &#123;</span><br><span class="line">          // 不在白名单的缓存全部清理掉</span><br><span class="line">          if (cacheWhitelist.indexOf(cacheName) === -1) &#123;</span><br><span class="line">            // 删除缓存</span><br><span class="line">            return caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>z 这些都是没有接入 webpack 时实现的。</p><h2 id="接入-Webpack"><a href="#接入-Webpack" class="headerlink" title="接入 Webpack"></a>接入 Webpack</h2><p>使用 webpack 要使用<a href="https://github.com/oliviertassinari/serviceworker-webpack-plugin" target="_blank" rel="noopener">serviceworker-webpack-plugin</a>插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D serviceworker-webpack-plugin webpack-dev-server</span><br></pre></td></tr></table></figure><p>webpack 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line">const &#123; WebPlugin &#125; = require(&quot;web-webpack-plugin&quot;);</span><br><span class="line">const ServiceWorkerWebpackPlugin = require(&quot;serviceworker-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &quot;./main.js&quot; // Chunk app 的 JS 执行入口文件</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &quot;[name].js&quot;,</span><br><span class="line">    publicPath: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css/, // 增加对 CSS 文件的支持</span><br><span class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          use: [&quot;css-loader&quot;] // 压缩 CSS 代码</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 一个 WebPlugin 对应一个 HTML 文件</span><br><span class="line">    new WebPlugin(&#123;</span><br><span class="line">      template: &quot;./template.html&quot;, // HTML 模版文件所在的文件路径</span><br><span class="line">      filename: &quot;index.html&quot; // 输出的 HTML 的文件名称</span><br><span class="line">    &#125;),</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      filename: `[name].css` // 给输出的 CSS 文件名称加上 hash 值</span><br><span class="line">    &#125;),</span><br><span class="line">    new ServiceWorkerWebpackPlugin(&#123;</span><br><span class="line">      // 自定义的 sw.js 文件所在路径</span><br><span class="line">      // ServiceWorkerWebpackPlugin 会把文件列表注入到生成的 sw.js 中</span><br><span class="line">      entry: path.join(__dirname, &quot;sw.js&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // Service Workers 依赖 HTTPS，使用 DevServer 提供的 HTTPS 功能。</span><br><span class="line">    // https: true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>devServer 的 https 可以不开启，如果 chrome 启动设置不禁止 http；<br>使用了 ServiceWorkerWebpackPlugin 后可以在 sw.js 里 global.serviceWorkerOption 下获取 assets，里面包含了 webpack 输出的所有静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Version: webpack 3.12.0</span><br><span class="line">Time: 16ms</span><br><span class="line">     Asset       Size  Chunks             Chunk Names</span><br><span class="line">   app.css   21 bytes       0  [emitted]  app</span><br><span class="line">index.html  332 bytes          [emitted]</span><br><span class="line">     sw.js    7.13 kB          [emitted]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> global.serviceWorkerOption.assets --- [&quot;/app.js&quot;, &quot;/app.css&quot;, &quot;/index.html&quot;]</span><br></pre></td></tr></table></figure><p>而 ServiceWorkerWebpackPlugin 内置了注册启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import runtime from &quot;serviceworker-webpack-plugin/lib/runtime&quot;;</span><br><span class="line">// 调用 serviceWorker.register 注册，参数 /sw.js 为脚本文件所在的 URL 路径</span><br><span class="line">var registration = runtime.register();</span><br></pre></td></tr></table></figure><p>ServiceWorkerWebpackPlugin 事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import registerEvents from &quot;serviceworker-webpack-plugin/lib/browser/registerEvents&quot;;</span><br><span class="line">registerEvents(registration, &#123;</span><br><span class="line">      onInstalled: () =&gt; &#123;</span><br><span class="line">        pushLog(&quot;onInstalled&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      onUpdateReady: () =&gt; &#123;</span><br><span class="line">        pushLog(&quot;onUpdateReady&quot;, true);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      onUpdating: () =&gt; &#123;</span><br><span class="line">        pushLog(&quot;onUpdating&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      onUpdateFailed: () =&gt; &#123;</span><br><span class="line">        pushLog(&quot;onUpdateFailed&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      onUpdated: () =&gt; &#123;</span><br><span class="line">        pushLog(&quot;onUpdated&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>ServiceWorkerWebpackPlugin 更新后手动更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import applyUpdate from &quot;serviceworker-webpack-plugin/lib/browser/applyUpdate&quot;;</span><br><span class="line">// 当为onUpdateReady时，可以使用applyUpdate触发更新操作</span><br><span class="line">applyUpdate().then(() =&gt; &#123;</span><br><span class="line">    window.location.reload();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>通过打开开发者工具的 Application-Service Workers 一栏，就能看到当前页面注册的 Service Workers，正常的效果如图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="01.png" alt="01" title="">                </div>                <div class="image-caption">01</div>            </figure></p><p>通过打开开发者工具的 Application-Cache-Cache Storage 一栏，能看到当前页面缓存的资源列表，正常的效果如图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="02.png" alt="02" title="">                </div>                <div class="image-caption">02</div>            </figure></p><p>为了验证网页在离线时能访问的能力，需要在开发者工具中的 Network 一栏中通过 Offline 选项禁用掉网络，再刷新页面能正常访问，并且网络请求的响应都来自 Service Workers，正常的效果如图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="03.png" alt="03" title="">                </div>                <div class="image-caption">03</div>            </figure></p><p>从图上可以看到红字的为没有缓存的，而有 ServiceWorker 的为有缓存的。</p><h2 id="完整项目例子"><a href="#完整项目例子" class="headerlink" title="完整项目例子"></a><a href="https://github.com/793338023/ServiceWorker-demo" target="_blank" rel="noopener">完整项目例子</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;离线缓存应用，意思就是没有网络的情况下，被缓存的资源能从本地直接返回，让应用在一定范围内能正常运行。&lt;/p&gt;
&lt;p&gt;离线应用有以下优点：&lt;/</summary>
      
    
    
    
    
    <category term="webpack" scheme="https://793338023.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>重温webpack-02</title>
    <link href="https://793338023.github.io/2020/01/18/%E9%87%8D%E6%B8%A9webpack-02/"/>
    <id>https://793338023.github.io/2020/01/18/%E9%87%8D%E6%B8%A9webpack-02/</id>
    <published>2020-01-18T15:03:56.000Z</published>
    <updated>2020-02-22T12:54:12.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>Entry<br>context</p></li><li><p>Output<br>filename<br>chunkFilename<br>path<br>publicPath<br>crossOriginloading<br>libraryTarget<br>library<br>libraryExport</p></li></ol><p>在使用 Babel 的项目中接入 React 框架很简单，只需要加入 React 所依赖的 Presets <code>babel-preset-react</code></p><p>与 Babel 相比， Typescript 的优点在于，它原生支持 JSX 语法，不需要重新安装新的依赖，只需修改一行配置。但 TypeScript 的不同之处在于:</p><ol><li>使用了 JSX 语法的文件后缀必须是 tsx;</li><li>由于 React 不是采用 Typescript 编写的，所以需要安装 react 和 react-dom 对应的 Type Script 接口描述模块＠ types/react 和＠ types/react-dom 才能通过编译。</li></ol><h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><h2 id="react-router-缓存组件"><a href="#react-router-缓存组件" class="headerlink" title="react-router 缓存组件"></a>react-router 缓存组件</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;ol&gt;
&lt;</summary>
      
    
    
    
    
    <category term="webpack" scheme="https://793338023.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>重温webpack-01</title>
    <link href="https://793338023.github.io/2020/01/12/%E9%87%8D%E6%B8%A9webpack-01/"/>
    <id>https://793338023.github.io/2020/01/12/%E9%87%8D%E6%B8%A9webpack-01/</id>
    <published>2020-01-12T03:47:12.000Z</published>
    <updated>2020-01-12T12:03:21.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>webpack 当下最流行的前端架构工具。</p><p>Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。</p><p>一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="重温webpack-01/webpack.png" alt="webpack" title="">                </div>                <div class="image-caption">webpack</div>            </figure><h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><p>模块化是指把一个复杂的系统分解到多个模块以方便编码。<br>在没有出现模块化概念时，解决 js 代码组织问题，比较流行的是命名空间的方式，如 JQuery。<br>但无法解决以下问题:</p><ol><li>命名空间冲突，两个库可能会使用同一个名称，例如 Zepto 也被放在 window.\$ 下；</li><li>无法合理地管理项目的依赖和版本；</li><li>无法方便地控制依赖的加载顺序。</li></ol><p>当项目特别庞大并依赖特别多时，加载的类库就会显得特别笨重，在显示上会出现页面不流畅的情况，在代码上，会出现难以维护的现象。</p><p>而技术的发展就是为了编写更好易懂的代码，减少人为规范，而出现模块化开发，象征的就是 requirejs、CommonJS、seaJs 等等，而后随着 js 发展，ECMA 提出的 JavaScript 模块化规范 <code>ES6 模块化</code>，它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块化例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 导出</span><br><span class="line">export const method = ()=&gt;&quot;ES6 模块化&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    es6:&quot;es6 代码&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 导入</span><br><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br></pre></td></tr></table></figure><p>ES6 模块化虽然是模块化解决方案，但浏览器支持力不高，所以需要架构工具帮助转义为浏览器可识别的代码。</p><h2 id="工具对比"><a href="#工具对比" class="headerlink" title="工具对比"></a>工具对比</h2><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>npm 是在安装 Node.js 时附带的包管理器,Npm Script 则是 Npm 内置的一个功能，允许在 package.json 文件里面使用 scripts 字段定义任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;:&#123;</span><br><span class="line">        &quot;dev&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">        &quot;start&quot;:&quot;node script/index&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的 scripts 字段是一个对象，每个属性对应一段 Shell 脚本，以上代码定义了两个任务 dev 和 pub。 其底层实现原理是通过调用 Shell 去运行脚本命令，如执行<code>npm run start</code>,执行的是<code>node script/index</code> node 程序，但这个功能很单一，没法使用与复杂场景。</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>Gulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面 5 个方法就可以胜任几乎所有构建场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过 gulp.task 注册一个任务；</span><br><span class="line">通过 gulp.run 执行任务；</span><br><span class="line">通过 gulp.watch 监听文件变化；</span><br><span class="line">通过 gulp.src 读取文件；</span><br><span class="line">通过 gulp.dest 写文件。</span><br></pre></td></tr></table></figure><p>它的特点流的方式，而且使用也比较简单，把需要编译内容分成一个个任务<code>gulp.task</code>编写即可，而在任务中使用<code>gulp.src</code>读取文件，而它可以正则，使用方式如 <code>glob</code>,然后使用<code>pipe</code>传递加载到文件内容给插件，而 gulp 的插件编写也比较简单，基本上都是对 node 的使用，最后经过 pipe 传递给<code>gulp.dest</code>进行输出操作，这些是 gulp 基本操作，以下为一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 引入 Gulp</span><br><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">// 引入插件</span><br><span class="line">var jshint = require(&apos;gulp-jshint&apos;);</span><br><span class="line">var sass = require(&apos;gulp-sass&apos;);</span><br><span class="line">var concat = require(&apos;gulp-concat&apos;);</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;);</span><br><span class="line"></span><br><span class="line">// 编译 SCSS 任务</span><br><span class="line">gulp.task(&apos;sass&apos;, function() &#123;</span><br><span class="line">  // 读取文件通过管道传给插件</span><br><span class="line">  gulp.src(&apos;./scss/*.scss&apos;)</span><br><span class="line">    // SCSS 插件把 scss 文件编译成 CSS 文件</span><br><span class="line">    .pipe(sass())</span><br><span class="line">    // 输出文件</span><br><span class="line">    .pipe(gulp.dest(&apos;./css&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 合并压缩 JS</span><br><span class="line">gulp.task(&apos;scripts&apos;, function() &#123;</span><br><span class="line">  gulp.src(&apos;./js/*.js&apos;)</span><br><span class="line">    .pipe(concat(&apos;all.js&apos;))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(&apos;./dist&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 监听文件变化</span><br><span class="line">gulp.task(&apos;watch&apos;, function()&#123;</span><br><span class="line">  // 当 scss 文件被编辑时执行 SCSS 任务</span><br><span class="line">  gulp.watch(&apos;./scss/*.scss&apos;, [&apos;sass&apos;]);</span><br><span class="line">  gulp.watch(&apos;./js/*.js&apos;, [&apos;scripts&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Gulp 的优点是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。其缺点是集成度不高，要写很多配置后才可以用，无法做到开箱即用。<br>还一点就是不会像 webpack 那样把所有文件看作模块打包成一个整体，它是把当前处理的文件看成一个整体，所以处理多少个文件就输入多少个文件。</p><h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p>Rollup 是一个和 Webpack 很类似但专注于 ES6 的模块打包工具。 Rollup 的亮点在于能针对 ES6 源码进行 Tree Shaking 以去除那些已被定义但没被使用的代码，以及 Scope Hoisting 以减小输出文件大小提升运行性能。 然而 Rollup 的这些亮点随后就被 Webpack 模仿和实现。 由于 Rollup 的使用和 Webpack 差不多，而它们的差别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rollup 是在 Webpack 流行后出现的替代品；</span><br><span class="line">Rollup 生态链还不完善，体验不如 Webpack；</span><br><span class="line">Rollup 功能不如 Webpack 完善，但其配置和使用更加简单；</span><br><span class="line">Rollup 不支持 Code Spliting，但好处是打包出来的代码中没有 Webpack 那段模块的加载、执行和缓存的代码。</span><br></pre></td></tr></table></figure><p>Rollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。 但功能不够完善，很多场景都找不到现成的解决方案。</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>前言以对它进行简述了。<br>Webpack 的优点是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">专注于处理模块化的项目，能做到开箱即用一步到位；</span><br><span class="line">通过 Plugin 扩展，完整好用又不失灵活；</span><br><span class="line">使用场景不仅限于 Web 开发；</span><br><span class="line">社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；</span><br><span class="line">良好的开发体验。</span><br></pre></td></tr></table></figure><p>Webpack 的缺点是只能用于采用模块化开发的项目。</p><h2 id="webpack-的简单使用"><a href="#webpack-的简单使用" class="headerlink" title="webpack 的简单使用"></a>webpack 的简单使用</h2><p>安装<br>webpack 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>babel 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/cli @babel/core babel-loader</span><br><span class="line"></span><br><span class="line">// babel 插件</span><br><span class="line">npm i -D @babel/plugin-transform-arrow-functions @babel/plugin-transform-arrow-functions</span><br><span class="line"></span><br><span class="line">// babel presets</span><br><span class="line">npm i -D @babel/preset-env @babel/preset-react</span><br></pre></td></tr></table></figure><p>css 处理安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D css-loader postcss-loader postcss-normalize postcss-preset-env postcss-flexbugs-fixes mini-css-extract-plugin style-loader</span><br></pre></td></tr></table></figure><p>当打包时使用 mini-css-extract-plugin 分离 css 为单独文件，而开发时使用 style-loader 在项目热加载模式下使用，因为 mini-css-extract-plugin 在热加载使用不了。</p><p>html 处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></table></figure><h4 id="完整-package-json"><a href="#完整-package-json" class="headerlink" title="完整 package.json"></a>完整 package.json</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack01&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;w&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/cli&quot;: &quot;^7.8.0&quot;,</span><br><span class="line">    &quot;@babel/core&quot;: &quot;^7.8.0&quot;,</span><br><span class="line">    &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.8.0&quot;,</span><br><span class="line">    &quot;@babel/plugin-transform-arrow-functions&quot;: &quot;^7.8.0&quot;,</span><br><span class="line">    &quot;@babel/preset-env&quot;: &quot;^7.8.0&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;: &quot;^7.8.0&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^8.0.6&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^3.4.2&quot;,</span><br><span class="line">    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;mini-css-extract-plugin&quot;: &quot;^0.9.0&quot;,</span><br><span class="line">    &quot;postcss-flexbugs-fixes&quot;: &quot;^4.1.0&quot;,</span><br><span class="line">    &quot;postcss-loader&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;postcss-normalize&quot;: &quot;^8.0.1&quot;,</span><br><span class="line">    &quot;postcss-preset-env&quot;: &quot;^6.7.0&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.41.5&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/polyfill&quot;: &quot;^7.8.0&quot;,</span><br><span class="line">    &quot;react&quot;: &quot;^16.12.0&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.12.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整-webpack-config-js"><a href="#完整-webpack-config-js" class="headerlink" title="完整 webpack.config.js"></a>完整 webpack.config.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">const postcssNormalize = require(&quot;postcss-normalize&quot;);</span><br><span class="line"></span><br><span class="line">const babel = require(&quot;./babel.config&quot;);</span><br><span class="line"></span><br><span class="line">const moduleFileExtensions = [</span><br><span class="line">  &quot;web.mjs&quot;,</span><br><span class="line">  &quot;mjs&quot;,</span><br><span class="line">  &quot;web.js&quot;,</span><br><span class="line">  &quot;js&quot;,</span><br><span class="line">  &quot;json&quot;,</span><br><span class="line">  &quot;web.jsx&quot;,</span><br><span class="line">  &quot;jsx&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &quot;./src/index.jsx&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // path: &apos;/dist&apos;,</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: moduleFileExtensions.map(ext =&gt; `.$&#123;ext&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.jsx$/,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &quot;babel-loader&quot;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            ...babel</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &quot;css-loader&quot;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: require.resolve(&quot;postcss-loader&quot;),</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &quot;postcss&quot;,</span><br><span class="line">              plugins: () =&gt; [</span><br><span class="line">                require(&quot;postcss-flexbugs-fixes&quot;),</span><br><span class="line">                require(&quot;postcss-preset-env&quot;)(&#123;</span><br><span class="line">                  autoprefixer: &#123;</span><br><span class="line">                    flexbox: &quot;no-2009&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  stage: 3</span><br><span class="line">                &#125;),</span><br><span class="line">                postcssNormalize()</span><br><span class="line">              ],</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &quot;[name].[chunkhash:8].css&quot;,</span><br><span class="line">      chunkFilename: &quot;[id].css&quot;</span><br><span class="line">    &#125;),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      inject: true,</span><br><span class="line">      template: &quot;public/index.html&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>babel.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const presets = [</span><br><span class="line">  &quot;@babel/preset-react&quot;,</span><br><span class="line">  [</span><br><span class="line">    &quot;@babel/preset-env&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      useBuiltIns: &quot;entry&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">];</span><br><span class="line">const plugins = [</span><br><span class="line">  &quot;@babel/plugin-transform-arrow-functions&quot;,</span><br><span class="line">  &quot;@babel/plugin-proposal-class-properties&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;webpack 当下最流行的前端架构工具。&lt;/p&gt;
&lt;p&gt;Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack</summary>
      
    
    
    
    
    <category term="webpack" scheme="https://793338023.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>liunx-pm2与nginx</title>
    <link href="https://793338023.github.io/2020/01/01/liunx-pm2%E4%B8%8Enginx/"/>
    <id>https://793338023.github.io/2020/01/01/liunx-pm2%E4%B8%8Enginx/</id>
    <published>2019-12-31T16:16:23.000Z</published>
    <updated>2020-01-01T15:42:34.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><p>日志管理：应用程序日志保存在服务器的硬盘中~/.pm2/logs/</p><p>负载均衡：PM2 可以通过创建共享同一服务器端口的多个子进程来扩展您的应用程序。这样做还允许您以零秒停机时间重新启动应用程序。</p><p>终端监控：可以在终端中监控您的应用程序并检查应用程序运行状况（CPU 使用率，使用的内存，请求/分钟等）。</p><p>SSH 部署：自动部署，避免逐个在所有服务器中进行 ssh。</p><p>静态服务：支持静态服务器功能</p><p>多平台支持：适用于 Linux（稳定）和 macOS（稳定）和 Windows（稳定）</p><h3 id="pm2-安装"><a href="#pm2-安装" class="headerlink" title="pm2 安装"></a>pm2 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><p>创建软链,进入 node 的安装文件夹下，找到 bin，里面有 pm2 的软链，如果环境变量 path 上已经有 node 的配置，那么可以不创建软链，因为在/usr/local/bin/创建的软链就是为了全局调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 我的node文件目录</span><br><span class="line">ln -s /opt/nodeJs/bin/pm2 /usr/local/bin/</span><br></pre></td></tr></table></figure><h3 id="pm2-使用"><a href="#pm2-使用" class="headerlink" title="pm2 使用"></a>pm2 使用</h3><p>在项目下使用 pm2 替代 node 启动项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js                //启动app.js应用</span><br><span class="line">pm2 start app.js --name demo    //启动应用并设置name</span><br><span class="line">pm2 start app.sh                //脚本启动</span><br><span class="line"></span><br><span class="line">pm2 stop all               //停止所有应用</span><br><span class="line">pm2 stop [AppName]        //根据应用名停止指定应用</span><br><span class="line">pm2 stop [ID]             //根据应用id停止指定应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pm2 delete all               //关闭并删除应用</span><br><span class="line">pm2 delete [AppName]        //根据应用名关闭并删除应用</span><br><span class="line">pm2 delete [ID]            //根据应用ID关闭并删除应用</span><br><span class="line"></span><br><span class="line">pm2 start app.js --watch    //当文件发生变化，自动重启</span><br><span class="line"></span><br><span class="line">//静态服务器</span><br><span class="line">pm2 serve ./dist 9090        //将目录dist作为静态服务器根目录，端口为9090</span><br><span class="line"></span><br><span class="line">pm2 reload app.js        //重新启动所有进程，始终保持至少一个进程在运行</span><br><span class="line">pm2 gracefulReload all   //优雅地以群集模式重新加载所有应用程序</span><br><span class="line"></span><br><span class="line">pm2 logs            //查看所有应用日志</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 查看进程</span><br><span class="line"></span><br><span class="line">pm2 ls</span><br><span class="line"></span><br><span class="line">┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐</span><br><span class="line">│ id  │ name   │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │</span><br><span class="line">├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤</span><br><span class="line">│ 0   │ www    │ default     │ 0.1.0   │ fork    │ 2217     │ 89m    │ 0    │ online    │ 0.8%     │ 32.1mb   │ root     │ disabled │</span><br><span class="line">└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘</span><br></pre></td></tr></table></figure><p>pm2 还可以实现自动部署的能力，在文件下配置 ecosystem 即可。</p><p>如: ecosystem.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    apps : [&#123;</span><br><span class="line">        name      : &apos;API&apos;,      //应用名</span><br><span class="line">        script    : &apos;app.js&apos;,   //应用文件位置</span><br><span class="line">        env: &#123;</span><br><span class="line">            PM2_SERVE_PATH: &quot;.&quot;,    //静态服务路径</span><br><span class="line">            PM2_SERVE_PORT: 8080,   //静态服务器访问端口</span><br><span class="line">            NODE_ENV: &apos;development&apos; //启动默认模式</span><br><span class="line">        &#125;,</span><br><span class="line">        env_production : &#123;</span><br><span class="line">            NODE_ENV: &apos;production&apos;  //使用production模式 pm2 start ecosystem.config.js --env production</span><br><span class="line">        &#125;,</span><br><span class="line">        instances:&quot;max&quot;,          //将应用程序分布在所有CPU核心上,可以是整数或负数</span><br><span class="line">        watch:true,               //监听模式</span><br><span class="line">        output: &apos;./out.log&apos;,      //指定日志标准输出文件及位置</span><br><span class="line">        error: &apos;./error.log&apos;,     //错误输出日志文件及位置，pm2 install pm2-logrotate进行日志文件拆分</span><br><span class="line">        merge_logs: true,         //集群情况下，可以合并日志</span><br><span class="line">        log_type:&quot;json&quot;,          //日志类型</span><br><span class="line">        log_date_format: &quot;DD-MM-YYYY&quot;,  //日志日期记录格式</span><br><span class="line">    &#125;],</span><br><span class="line">    deploy : &#123;</span><br><span class="line">        production : &#123;</span><br><span class="line">            user : &apos;node&apos;,                      //ssh 用户</span><br><span class="line">            host : &apos;212.83.163.1&apos;,              //ssh 地址</span><br><span class="line">            ref  : &apos;origin/master&apos;,             //GIT远程/分支</span><br><span class="line">            repo : &apos;git@github.com:repo.git&apos;,   //git地址</span><br><span class="line">            path : &apos;/var/www/production&apos;,       //服务器文件路径</span><br><span class="line">            post-deploy : &apos;npm install &amp;&amp; pm2 reload ecosystem.config.js --env production&apos;  //部署后的动作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/cs380637384/article/details/82682799" target="_blank" rel="noopener">参考资料 01</a><br><a href="https://www.cnblogs.com/bjgua/p/7656833.html" target="_blank" rel="noopener">参考资料 02</a></p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。</p><p>作用：集群（提高吞吐量，减轻单台服务器压力），反向代理（不暴露真实 IP 地址），虚拟服务器，静态服务器（动静分离）。解决跨域问题，使用 nginx 搭建企业级 api 接口网关</p><p><a href="https://www.jianshu.com/p/d8bd75c0fb1b" target="_blank" rel="noopener">nginx 的功能强大</a></p><h3 id="nginx-安装"><a href="#nginx-安装" class="headerlink" title="nginx 安装"></a>nginx 安装</h3><ol><li>安装依赖包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 一键安装上面四个依赖</span><br><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><ol start="2"><li>下载并解压安装包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个文件夹</span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br><span class="line">//下载tar包</span><br><span class="line">wget http://nginx.org/download/nginx-1.13.7.tar.gz</span><br><span class="line">tar -zxvf nginx-1.13.7.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>安装 nginx</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//进入nginx目录</span><br><span class="line">cd /usr/local/nginx</span><br><span class="line">//执行命令</span><br><span class="line">./configure</span><br><span class="line">//执行make命令</span><br><span class="line">make</span><br><span class="line">//执行make install命令</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ol start="4"><li>配置 nginx.conf</li></ol><p>进入配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>修改端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  3100;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginx: [alert] could not open error log file: open() &quot;/usr/local/nginx/logs/error.log&quot; failed (2: No such file or directory)</span><br><span class="line">2016/09/13 19:08:56 [emerg] 6996#0: open() &quot;/usr/local/nginx/logs/access.log&quot; failed (2: No such file or directory)</span><br><span class="line"></span><br><span class="line">在nginx/目录下没有logs文件夹</span><br><span class="line">解决方法：</span><br><span class="line">mkdir logs</span><br><span class="line">chmod 700 logs</span><br></pre></td></tr></table></figure><p>创建软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/</span><br><span class="line"></span><br><span class="line">/usr/local/bin/就是环境变量目录</span><br></pre></td></tr></table></figure><p>测试是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line">正常情况的信息输出：</span><br><span class="line"></span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">启动 nginx:</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line">查看 nginx 进程：</span><br><span class="line">ps -ef | grep  nginx</span><br><span class="line"></span><br><span class="line">关闭：</span><br><span class="line">nginx  -s  stop</span><br><span class="line"></span><br><span class="line">配置文件修改重装载命令：</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">正常停止或关闭Nginx:</span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="location-模块"><a href="#location-模块" class="headerlink" title="location 模块"></a>location 模块</h3><p>location 在 nginx 是比较常用的，所以需要有所了解。<br><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" target="_blank" rel="noopener">官方文档</a></p><p>location 分为两类 普通 location 和 正则 location<br>普通 location 既不带任何修饰符，如<code>/app</code>,它是前缀匹配，也在正则的范围内，但它是从根路径开始匹配的。</p><p>正则 location 带[ = | ~ | ~ * | ^~ ]这些前缀的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">= 表示精确匹配，只有完全匹配上才能生效</span><br><span class="line">location = /uri</span><br><span class="line"></span><br><span class="line">^~ 开头对URL路径进行前缀匹配，并且在正则之前</span><br><span class="line">location ^~ /uri</span><br><span class="line"></span><br><span class="line">开头表示区分大小写的正则匹配</span><br><span class="line">location ~ pattern</span><br><span class="line"></span><br><span class="line">开头表示不区分大小写的正则匹配</span><br><span class="line">location ~* pattern</span><br><span class="line"></span><br><span class="line">不带任何修饰符，也表示前缀匹配，但是在正则匹配之后</span><br><span class="line">location /uri</span><br><span class="line"></span><br><span class="line">通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default</span><br><span class="line">location /</span><br></pre></td></tr></table></figure><p>多个 location 配置的情况下匹配顺序为:</p><ol><li>首先精确匹配 =</li><li>其次前缀匹配 如:^~</li><li>其次是按文件中顺序的正则匹配</li><li>然后匹配不带任何修饰的前缀匹配。</li><li>最后是交给 / 通用匹配</li><li>当有匹配成功时候，停止匹配，按当前匹配规则处理请求</li></ol><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">前缀匹配，如果有包含关系时，按最大匹配原则进行匹配。比如在前缀匹配：</span><br><span class="line">location /app 与 location /app/goods</span><br><span class="line"></span><br><span class="line">如有请求</span><br><span class="line">http://localhost/app/goods/file</span><br><span class="line">将最终匹配到</span><br><span class="line">location /app/goods 这个location上</span><br><span class="line"></span><br><span class="line">如果在正则表达式里面有&#123;&#125;，这会与location模块的&#123;&#125;冲突，这时候需要将正则表达式用单引号或者双引号起来。</span><br><span class="line"></span><br><span class="line">如:</span><br><span class="line">location ~ &quot;/([\S]&#123;8&#125;)&quot; &#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:3000/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h4 id="加载静态资源"><a href="#加载静态资源" class="headerlink" title="加载静态资源"></a>加载静态资源</h4><p>配置 nginx 的静态文件有两个指令，一个 root 和一个 alias。</p><p>root 是指定项目的根目录，适用与 server 和 location。可以指定多个，如果 locaiton 没有指定，会往其外层的 server 或 http 中寻找继承。</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /static &#123;</span><br><span class="line">    root   /root/webapp/sourceCode/sell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http://localhost:3100/static/aa.jpg</span><br><span class="line">经过nginx等于</span><br><span class="line">http://localhost:3100//root/webapp/sourceCode/sell/static/aa.jpg</span><br></pre></td></tr></table></figure><p>alias 它并不是替换匹配后的 url 地址，而是替换匹配部分的 url。alias 指令也可以有多个。<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /static &#123;</span><br><span class="line">    alias   /root/webapp/sourceCode/sell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http://localhost:3100/static/aa.jpg</span><br><span class="line">经过nginx等于</span><br><span class="line">http://localhost:3100/root/webapp/sourceCode/sell/aa.jpg</span><br></pre></td></tr></table></figure><p>通常最佳实际是配置一个项目的根 root，其他的文件夹则使用 alias，毕竟 alias 更加灵活。</p><h5 id="index-指令的作用"><a href="#index-指令的作用" class="headerlink" title="index 指令的作用"></a>index 指令的作用</h5><p>在前后端分离的基础上，通过 Nginx 配置，指定网站初始页。<br>该指令拥有默认值，index index.html ，即，如果没有给出 index，默认初始页为 index.html。</p><p>在没有给出明确的文件名称，index 才会启动，index 的作用就是在你没有给出一个明确名称，会自动分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /root/webapp/sourceCode/sell;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h4><p>在 nginx 中配置 proxy_pass 代理转发时，如果在 proxy_pass 后面的 url 加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也加到代理路径上。</p><p>如:<br><a href="http://localhost:3100/proxy/bb.html" target="_blank" rel="noopener">http://localhost:3100/proxy/bb.html</a> 进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">    proxy_pass http://localhost:8080/;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://localhost:8080/bb.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二种（相对于第一种，最后少一个 / ）</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">    proxy_pass http://localhost:8080;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://localhost:8080/proxy/bb.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">    proxy_pass http://localhost:8080/aaa/;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://localhost:8080/aaa/bb.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第四种（相对于第三种，最后少一个 / ）</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">    proxy_pass http://localhost:8080/aaa;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://localhost:8080/aaabb.html</span><br></pre></td></tr></table></figure><p>以上有四种情况，但实际就两种情况，第一种与其他三种，只是其他三种有点迷惑性，其实都是一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nginx实现反向代理，使用Module ngx_http_proxy_module模块，proxy_pass指令，设置请求头为真正的客户端地址proxy_set_header X-Real-IP $remote_addr;</span><br></pre></td></tr></table></figure><p>报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] &quot;proxy_pass&quot; cannot have URI part in location given by regular expression</span><br></pre></td></tr></table></figure><p>这是由于使用了正则 location，但 proxy_pass 的 ip+host 后面有路经，正则匹配后无法拼接上而报错。</p><p>解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /proxy/aaa/ &#123;</span><br><span class="line">    proxy_pass http://localhost:8080;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">    proxy_pass http://localhost:8080/aaa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 nginx 还有很多配置使用，按照自己需要一点一点的查。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pm2&quot;&gt;&lt;a href=&quot;#pm2&quot; class=&quot;headerlink&quot; title=&quot;pm2&quot;&gt;&lt;/a&gt;pm2&lt;/h2&gt;&lt;p&gt;日志管理：应用程序日志保存在服务器的硬盘中~/.pm2/logs/&lt;/p&gt;
&lt;p&gt;负载均衡：PM2 可以通过创建共享同一服务器端口的</summary>
      
    
    
    
    
    <category term="liunx" scheme="https://793338023.github.io/tags/liunx/"/>
    
  </entry>
  
  <entry>
    <title>npm、nrm与npx</title>
    <link href="https://793338023.github.io/2019/12/25/npm%E4%B8%8Enpx/"/>
    <id>https://793338023.github.io/2019/12/25/npm%E4%B8%8Enpx/</id>
    <published>2019-12-25T15:00:00.000Z</published>
    <updated>2020-09-19T07:59:33.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>NPM 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题，如允许用户从 NPM 服务器下载别人编写的第三方包到本地使用、允许用户从 NPM 服务器下载并安装别人编写的命令行程序到本地使用、允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。</p><p>以下的操作系统都已 window 的为主，且主要介绍一些我觉得有意思的东西，如简化命令，package.json 里的属性作用等，还有 npm 周边的辅助工具 npx 与 nrm,</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="npm-安装与初始化"><a href="#npm-安装与初始化" class="headerlink" title="npm 安装与初始化"></a>npm 安装与初始化</h3><p>npm 随着 node 一起安装了，但有时由于 npm 版本不够而需要更新，可以直接更新 npm。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看版本</span><br><span class="line">npm -v</span><br><span class="line">// 更新版本</span><br><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure><p>如果我们初始化一个模块，那么就会执行 npm init，但这样要填写一些信息，然后输出一个初始化的 package.json，我们可以简化它，然后后面有必要再手动填入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 快速创建</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="依赖包安装"><a href="#依赖包安装" class="headerlink" title="依赖包安装"></a>依赖包安装</h3><p>依赖管理是 npm 的核心功能，原理就是执行 npm install 从 package.json 中的 dependencies, devDependencies 将依赖包安装到当前目录的 ./node_modules 文件夹中。</p><p>而单独安装一个包时，执行 <code>npm install &lt;package&gt;</code> 命令即可，但在 npm 里，除了简单的指定包名, package 还可以是一个指向有效包名的 http(网上资源)、url/git(git 上资源，如 github 或私仓的 gitlab 之类)、url/文件夹路径(本地资源)。</p><p>其实只要符合 package 的规则就可以安装到 node_modules 里使用。<br><a href="https://docs.npmjs.com/about-packages-and-modules" target="_blank" rel="noopener">package</a>的规则有:</p><ul><li>a) 包含由 package.json 文件描述的程序的文件夹。</li><li>b) 含有（a）的压缩的压缩文件，如 module.tar.gz。</li><li>c) 解析为（b）的 URL(通常是 http(s) url)。</li><li>d) 一个格式为 <code>&lt;name&gt;@&lt;version&gt;</code> 的字符串，可指向 npm 源(通常是官方源 npmjs.org)上已发布的可访问 url，且该 url 满足条件 (c)。</li><li>e) 一个格式为 <code>&lt;name&gt;@&lt;tag&gt;</code> 的字符串，在 npm 源上该<code>&lt;tag&gt;</code>指向某 <code>&lt;version&gt;</code> 得到 <code>&lt;name&gt;@&lt;version&gt;</code>，后者满足条件 (d)。</li><li>f) <code>&lt;name&gt;</code>具有 latest 满足（e）的标签的模块。</li><li>g) 一个 git/url, 该 url 所指向的代码库满足条件 (a)。</li></ul><h4 id="本地包-git-上的包的安装"><a href="#本地包-git-上的包的安装" class="headerlink" title="本地包/git 上的包的安装"></a>本地包/git 上的包的安装</h4><p>这对于私有的不方便 publish 到远程源（即使是私有源），或者需要对某官方源的包进行改造，但依然需要把包共享出去的场景来说非常实用。</p><ol><li>如场景一:本地模块引用<br>nodejs 应用开发中不可避免有模块间调用，例如在实践中经常会把需要被频繁引用的配置模块放到应用根目录；于是在创建了很多层级的目录、文件后，很可能会遇到这样的代码:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const config = require(&apos;../../../../config.js&apos;);</span><br></pre></td></tr></table></figure><p>除了看上去很丑以外，这样的路径引用也不利于代码的重构。并且身为程序员的自我修养告诉我们，这样重复的代码多了也就意味着是时候把这个模块分离出来供应用内其他模块共享了。例如这个例子里的 config.js 非常适合封装为 package 放到 node_modules 目录下，共享给同应用内其他模块。<br>无需手动拷贝文件或者创建软链接到 node_modules 目录，npm 有更优雅的解决方案。</p><p>实践方式:<br>创建 config 包:</p><ul><li><ol><li>新增 config 文件夹; 重命名 config.js 为 config/index.js 文件; 创建 package.json 定义 config 包;</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;config&quot;,</span><br><span class="line">    &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>在应用层 package.json 文件中新增依赖项，然后执行 npm install; 或直接执行第 3 步</li></ol></li><li><ol start="3"><li>（等价于第 2 步）直接在应用目录执行 npm install file:../config<br>此时，查看 node_modules 目录我们会发现多出来一个名为 config，指向同级 config/ 文件夹的软链接(可以看作快捷文件夹)。这是因为 npm 识别 file: 协议的 url，得知这个包需要直接从文件系统中获取，会自动创建软链接到 node_modules 中，完成“安装”过程。<br>相比手动软链，我们既不需要关心 windows 和 linux 命令差异，又可以显式地将依赖信息固化到 dependencies 字段中，开发团队其他成员可以执行 npm install 后直接使用。</li></ol></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">项目目录结构</span><br><span class="line">├─project</span><br><span class="line">    ├─package.json</span><br><span class="line">    ├─index.js</span><br><span class="line">    ├─packages</span><br><span class="line">        ├─config</span><br><span class="line">            ├─package.json</span><br><span class="line">            ├─index.js</span><br><span class="line">        ├─demo</span><br><span class="line">            ├─package.json</span><br><span class="line">            ├─index.js</span><br><span class="line"></span><br><span class="line">当前demo关联config</span><br><span class="line"></span><br><span class="line">npm i ../config</span><br><span class="line"></span><br><span class="line">当demo安装上config后就不必再安装，因为是软链接，所以config的改变，demo里的node_modules/config也会一起改变，就像对象引用关系一样，</span><br><span class="line">他们都是同一个地址，互相影响</span><br><span class="line">而在使用webpack的热加载时，node_modules的包的变化也会触发热加载的，所以当node_modules/config被引用后，如果有修改，那么热加载也会触发。</span><br><span class="line">但如果出现包里的文件被引用，然而文件改变为删除后重新创建，那么热加载可能有出问题，就是会出现无法找到文件的报错</span><br></pre></td></tr></table></figure><ol start="2"><li>场景二:私有 git 共享 package<br>有些时候，我们一个团队内会有一些代码/公用库需要在团队内不同项目间共享，但可能由于包含了敏感内容，或者代码太烂拿不出手等原因，不方便发布到源。</li></ol><p>这种情况下，我们可以简单地将被依赖的包托管在私有的 git 仓库中，然后将该 git/url 保存到 dependencies 中. npm 会直接调用系统的 git 命令从 git 仓库拉取包的内容到 node_modules 中。</p><p><a href="https://docs.npmjs.com/files/package.json#git-urls-as-dependencies" target="_blank" rel="noopener">npm 支持的 git url 格式:</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span><br><span class="line">// 一般使用http(s),使用ssh需要设置ssh信息，比较麻烦</span><br><span class="line"></span><br><span class="line">npm i https://github.com/facebook/react.git</span><br></pre></td></tr></table></figure><ol start="3"><li>场景 3: 开源 package 问题修复<br>使用某个 npm 包时发现它有某个严重 bug，但也许最初作者已不再维护代码了，也许我们工作紧急，没有足够的时间提 issue 给作者再慢慢等作者发布新的修复版本到 npm 源。<br>而私自修改 node_modules 里包的内容是很容易出现覆盖等现象，再根源上没有解决而导致问题重现。</li></ol><p>解决正确方式:<br>最好的办法应当是 fork 原作者的 git 库，在自己所属的 repo 下修复问题后，将 dependencies 中相应的依赖项更改为自己修复后版本的 git/url 即可解决问题。（Fork 代码库后，也便于向原作者提交 PR 修复问题。上游代码库修复问题后，再次更新我们的依赖配置也不迟。）</p><h3 id="npm5-与-package-lock"><a href="#npm5-与-package-lock" class="headerlink" title="npm5 与 package-lock"></a>npm5 与 package-lock</h3><p>npm5 这一版本最大的变化是增加了 package-lock.json 文件。<br>package-lock.json 的作用是锁定依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件层级结构是一一对应的。</p><p>以依赖关系为:webpack 构建项目为例, 其 package-lock 文件包含了这样的片段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;react-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;lockfileVersion&quot;: 1,</span><br><span class="line">  &quot;requires&quot;: true,</span><br><span class="line">    &quot;dependencies&quot;:&#123;</span><br><span class="line">        //...其他依赖包</span><br><span class="line">        &quot;webpack-dev-middleware&quot;: &#123;</span><br><span class="line">            &quot;version&quot;: &quot;3.7.0&quot;,</span><br><span class="line">            &quot;resolved&quot;: &quot;https://registry.npmjs.org/webpack-dev-middleware/-/webpack-dev-middleware-3.7.0.tgz&quot;,</span><br><span class="line">            &quot;integrity&quot;: &quot;sha512-qvDesR1QZRIAZHOE3iQ4CXLZZSQ1lAUsSpnQmlB1PBfoN/xdRjmge3Dok0W4IdaVLJOGJy3sGI4sZHwjRU0PCA==&quot;,</span><br><span class="line">            &quot;dev&quot;: true,</span><br><span class="line">            &quot;requires&quot;: &#123;</span><br><span class="line">                &quot;memory-fs&quot;: &quot;^0.4.1&quot;,</span><br><span class="line">                &quot;mime&quot;: &quot;^2.4.2&quot;,</span><br><span class="line">                &quot;range-parser&quot;: &quot;^1.2.1&quot;,</span><br><span class="line">                &quot;webpack-log&quot;: &quot;^2.0.0&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;dependencies&quot;: &#123;</span><br><span class="line">                &quot;mime&quot;: &#123;</span><br><span class="line">                &quot;version&quot;: &quot;2.4.4&quot;,</span><br><span class="line">                &quot;resolved&quot;: &quot;https://registry.npmjs.org/mime/-/mime-2.4.4.tgz&quot;,</span><br><span class="line">                &quot;integrity&quot;: &quot;sha512-LRxmNwziLPT828z+4YkNzloCFC2YM4wrB99k+AV5ZbEyfGNWfG8SO1FUXLmLDBSo89NrJZ4DIWeLjy1CHGhMGA==&quot;,</span><br><span class="line">                &quot;dev&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //...其他依赖包</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package-lock 其主要字段是 version, resolved, integrity, requires, dependencies 这几个字段而已。<br>version, integrity, resolved 用来记录包的准确版本号、内容 hash、安装源的，决定了要安装的包的准确“身份”信息。</p><p>从 dependencies: {} 里的内容我们会发现，整个文件的 JSON 配置里的 dependencies 层次结构与文件系统中 node_modules 的文件夹层次结构是完全对照的，除最外层的 requires 属性为 true 以外, 其他层的 requires 属性都对应着这个包的 package.json 里记录的自己的依赖项 dependencies 属性，而 dependencies 对应既这个包里 node_modules 所拥有的文件。<br>如图:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="node_module.png" alt="node" title="">                </div>                <div class="image-caption">node</div>            </figure><br>因为这个文件记录了 node_modules 里所有包的结构、层级和版本号甚至安装源，它也就事实上提供了 “保存” node_modules 状态的能力。只要有这样一个 lock 文件，不管在那一台机器上执行 npm install 都会得到完全相同的 node_modules 结果。</p><p>package-lock 文件致力于优化的场景:<br>在从前仅仅用 package.json 记录依赖，由于 包依赖的版本范围的机制；一个月前由 A 生成的 package.json 文件，B 在一个月后根据它执行 npm install 所得到的 node_modules 结果很可能许多包都存在不同的差异，虽然这个机制的限制使得同一份 package.json 不会得到大版本不同的依赖包，但同一份代码在不同环境安装出不同的依赖包，依然是可能导致意外的潜在因素。</p><p>而禁止它在.npmrc 设置或命令设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在当前项目新建 .npmrc</span><br><span class="line">package-lock=false</span><br><span class="line">// 命令设置，会禁用所有项目package-lock.json</span><br><span class="line">npm config set package-lock false</span><br></pre></td></tr></table></figure><h3 id="npm-scripts"><a href="#npm-scripts" class="headerlink" title="npm scripts"></a>npm scripts</h3><p>npm scripts 是 npm 另一个很重要的特性。通过在 package.json 中 scripts 字段定义一个脚本，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;echo&quot;: &quot;echo hello world&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就可以通过 npm run echo 命令来执行这段脚本，像在 shell 中执行该命令 echo hello world 一样，看到终端输出 hello world.<br>npm scripts 的基本使用就是这么简单，它提供了一个简单的接口用来调用工程相关的脚本。</p><p>简单的总结一下:</p><ol><li>npm run 命令执行时，会把 ./node_modules/.bin/ 目录添加到执行环境的 PATH 变量中，因此如果某个命令行包未全局安装，而只安装在了当前项目的 node_modules 中，通过 npm run 一样可以调用该命令。</li><li>执行 npm 脚本时要传入参数，需要在命令后加 – 标明, 如 npm run test – –grep=”pattern” 可以将 –grep=”pattern” 参数传给 test 命令。</li><li>npm 提供了 pre 和 post 两种钩子机制，可以定义某个脚本前后的执行脚本。</li><li>运行时变量：在 npm run 的脚本执行环境内，可以通过环境变量的方式获取许多运行时相关信息，以下都可以通过 process.env 对象访问获得：</li></ol><ul><li>npm_lifecycle_event - 正在运行的脚本名称</li><li><code>npm_package_&lt;key&gt;</code> - 获取当前包 package.json 中某个字段的配置值：如 npm_package_name 获取包名</li><li><code>npm_package_&lt;key&gt;_&lt;sub-key&gt;</code> - package.json 中嵌套字段属性：如 npm_pacakge_dependencies_webpack 可以获取到 package.json 中的 dependencies.webpack 字段的值，即 webpack 的版本号。</li></ul><h3 id="npm-bin"><a href="#npm-bin" class="headerlink" title="npm bin"></a>npm bin</h3><p>上面所说的 node_modules/.bin 目录，保存了依赖目录中所安装的可供调用的命令行包。<br>何谓命令行包？例如 webpack 就属于一个命令行包。当我们把 webpack 安装到项目的 node_modules 里时当前包里 package.json 的 bin 字段就会配置的 node_modules/.bin 目录里，让我们可以在局部执行避免全局包版本不一致导致的问题。</p><p>webpack 在 package.json 文件中定义了 bin 字段为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;bin&quot;: &#123;</span><br><span class="line">        &quot;webpack&quot;: &quot;./bin/webpack.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而安装在 node_modules/.bin 里的一般通过 npm scripts，否则只能安装到全局里，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack -g</span><br></pre></td></tr></table></figure><p>这样就可以直接在 cmd 命令行工具使用。</p><p>但 npm 也提供了别的方式调用项目里的命令行包，为 npx，下面会单独描述。</p><h3 id="npm-发布"><a href="#npm-发布" class="headerlink" title="npm 发布"></a>npm 发布</h3><ol><li>你需要一个 npm<a href="https://www.npmjs.com/" target="_blank" rel="noopener">账号</a>。这是流程的一部分。</li><li>在当前项目打开终端输入:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><p>你会得到一个让你输入 username、password 和 email 的提示。把它们填在相应的位置吧！</p><ol start="3"><li>在当前项目打开终端输入:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>npm 不许发布已有的包名与相同的版本的包，所以每次发布都需要修改 package.json 的 version。</p><p>修改 version 的命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// version x.y.z</span><br><span class="line">// 自增z</span><br><span class="line">npm version patch</span><br><span class="line">// 自增y</span><br><span class="line">npm version minor</span><br><span class="line">// 自增x</span><br><span class="line">npm version major</span><br></pre></td></tr></table></figure><p>发布到私仓里，需要 package.json 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;publishConfig&quot;:&#123;</span><br><span class="line">        &#123;&quot;registry&quot;:&quot;私仓地址&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而发布的时注意 devDependencies 与 dependencies 里的依赖，因为安装在 dependencies 的包会在项目下载这个包时一并下载，而安装到 devDependencies 里的依赖就不会被下载，因为 devDependencies 是开发使用的依赖，而 dependencies 是包需要的依赖，所以在开发 npm 包时需要注意这样的区别，否则包下载会因为不必要的依赖而导致下载缓慢。</p><ol start="4"><li>撤销发的包<br>其实发的包,可能会有人下载了,并在使用,所以撤销包,需要慎重。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//撤销发布,需要在24小时内完成操作,下一次再发包,不能发同名的了</span><br><span class="line">$ npm unpublish</span><br><span class="line"></span><br><span class="line">//更好的一个做法,是声明遗弃</span><br><span class="line">$ npm deprecate &lt;pkgname&gt;</span><br></pre></td></tr></table></figure><h3 id="基本快捷方式与命令"><a href="#基本快捷方式与命令" class="headerlink" title="基本快捷方式与命令"></a>基本快捷方式与命令</h3><p>我们从最基本的开始,学习最常见的 npm 快捷方式从长远来将会节省很多时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">安装  —  常规：npm install，简写：npm i。</span><br><span class="line"></span><br><span class="line">测试  —  常规：npm test，简写：npm t。</span><br><span class="line"></span><br><span class="line">帮助  —  常规：npm --help，简写：npm -h。</span><br><span class="line"></span><br><span class="line">全局标志 —  常规：--global，简写：-g。</span><br><span class="line"></span><br><span class="line">保存为开发依赖 - 常规： --save-dev，简写：-D。</span><br><span class="line"></span><br><span class="line">保存为项目依赖 - 常规: --save，简：-S。</span><br><span class="line"></span><br><span class="line">包更新 - 常规: npm update ,简写: npm up</span><br><span class="line"></span><br><span class="line">包删除 - 常规: npm uninstall,简写: npm un</span><br><span class="line"></span><br><span class="line">npm init 默认值 - 常规：npm init --yes 或 npm init --force，简写：npm init -y 或 npm init -f</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看项目中模块所在的目录</span><br><span class="line">npm root</span><br><span class="line">查看全局安装的模块所在目录</span><br><span class="line">npm root -g</span><br><span class="line"></span><br><span class="line">查看某个包的信息</span><br><span class="line">npm view 包名&lt;指定版本&gt;</span><br><span class="line"></span><br><span class="line">若不指定版本，则为最新版本</span><br><span class="line"></span><br><span class="line">如:</span><br><span class="line">npm view chalk</span><br><span class="line"></span><br><span class="line">查看本地下载包的版本信息</span><br><span class="line">如:查看项目内的react</span><br><span class="line">npm ls react</span><br><span class="line"></span><br><span class="line">查看全局的react</span><br><span class="line">npm ls react -g</span><br><span class="line"></span><br><span class="line">检查包里所有的过期依赖</span><br><span class="line">npm outdated</span><br><span class="line"></span><br><span class="line">查看npm使用的所有文件夹，就是npm的帮助文档，基本上npm的使用都有，了解使用npm很有用</span><br><span class="line">npm help folders</span><br><span class="line"></span><br><span class="line">访问package.json的字段文档，package.json帮助文档，了解使用package.json很有用</span><br><span class="line">npm help json</span><br><span class="line"></span><br><span class="line">发布一个npm包的时候，需要检验某个包名是否已经存在</span><br><span class="line">npm search 模块名</span><br><span class="line"></span><br><span class="line">清除npm的缓存，没必要，最好不要使用，具体可以使用npm help folders了解</span><br><span class="line">npm cache clean</span><br><span class="line"></span><br><span class="line">查看某个模块的bugs列表界面,打开包的github仓库的issue</span><br><span class="line">npm bugs 模块名</span><br><span class="line"></span><br><span class="line">如:</span><br><span class="line">npm bugs react</span><br><span class="line"></span><br><span class="line">打开包的github仓库界面</span><br><span class="line">npm repo 模块名</span><br><span class="line"></span><br><span class="line">如:</span><br><span class="line">npm repo antd</span><br><span class="line"></span><br><span class="line">打开某个模块的文档，如打开readme.md文档或打开官网</span><br><span class="line">npm docs 模块名</span><br><span class="line"></span><br><span class="line">打开某个模块的主页，如打开readme.md文档或打开官网</span><br><span class="line">npm home 模块名</span><br><span class="line"></span><br><span class="line">清除未被使用到的模块</span><br><span class="line">npm prune</span><br><span class="line"></span><br><span class="line">NPM 5.7.0 引入了一种新的安装依赖的方式</span><br><span class="line">npm ci</span><br></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/section/1490280" target="_blank" rel="noopener">npm ci 资料一</a><br><a href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable" target="_blank" rel="noopener">npm ci 资料二</a><br><a href="https://segmentfault.com/a/1190000020585683" target="_blank" rel="noopener">npm view 更多资料</a></p><p>根的快捷方式<br>. 符号通常用于表示应用程序的根目录，npm 术语中的应用程序入口点，即 package.json 中指定为“main”的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要发布一个包时，直接引用包名就可以使用包，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i react</span><br><span class="line">// 当前项目就可以使用</span><br><span class="line">import react from &apos;react&apos;</span><br><span class="line">// 会直接查看package.json的main字段路径</span><br></pre></td></tr></table></figure><h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p>这个是在 npmv5.2.0 引入的一条命令，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。</p><p>举个例子，我们开发中要运行 webpack 命令来打包，以前有这么几种方式：</p><ol><li>全局安装 webpack，但有时不同项目使用不同版本，不允许使用全局包，只能考虑下面一些方法</li><li>使用 npm scripts，在 package.json 加一个 script</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;webpack&quot;: &quot;webpack&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行 npm run webpack</p><ol start="3"><li>将 node_modules 的可执行目录(.bin)加到 PATH 中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias npmx=PATH=$(npm bin):$PATH</span><br></pre></td></tr></table></figure><p>然后执行 npmx webpack</p><ol start="4"><li>指定可执行命令路径</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack</span><br></pre></td></tr></table></figure><p>现在我们有了 npx 命令，就不在需要考虑以上方法了（其实 npx 是对方法 3 的封装）。当我们执行 webpack 时，会自动去./node_modules/.bin 目录下搜索。<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>-p 参数用于指定 npx 所要安装的模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx -p node@0.12.8 node -v</span><br></pre></td></tr></table></figure><p>上面命令先指定安装 <a href="mailto:node@0.12.8" target="_blank" rel="noopener">node@0.12.8</a>，然后再执行 node -v 命令。</p><h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><p>开发的 npm registry 管理工具 nrm, 能够查看和切换当前使用的 registry,一个比较废的功能，因为我们可以使用<code>npm config edit</code>修改配置文件的 registry 达到同样的效果，但可以了解一下。</p><p>nrm 的安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure><p>nrm 命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nrm ls　　// 查看所有的支持源（有*号的表示当前所使用的源,以下[name]表示源的名称）</span><br><span class="line"></span><br><span class="line">nrm use [name]　　// 将npm下载源切换成指定的源</span><br><span class="line"></span><br><span class="line">nrm help　　// 查看nrm帮助</span><br><span class="line"></span><br><span class="line">nrm home [name]　　// 跳转到指定源的官网</span><br></pre></td></tr></table></figure><p>当切换源后使用 npm 下载时就会从当前源下载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;NPM 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题，如允许用户从 NPM 服务器下载别人编写的第</summary>
      
    
    
    
    
    <category term="npm" scheme="https://793338023.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>liunx-虚拟机使用</title>
    <link href="https://793338023.github.io/2019/12/21/liunx-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8/"/>
    <id>https://793338023.github.io/2019/12/21/liunx-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8/</id>
    <published>2019-12-21T03:13:11.000Z</published>
    <updated>2019-12-21T05:36:19.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>virtualBox + CentOS-6.8</p><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">virtualBox 官网下载即可</a>。</p><p>CentOS-6.8 这个镜像有点旧，网上下载一个最新版的镜像，否则在安装一些环境时会出现 libc.so.6 与 GLIBCXX<em>\</em>* 的错误，比如在安装 node 时我就出现这些错误，但此类的问题在网上都可以搜索到解决方法，都是下载 libc.so.6 与 GLIBCXX<em>\</em>*的适合版本，然后安装，重新建立软链，但在删除/lib64/libc.so.6，后 LD_PRELOAD 执行与 ln 软链要一起执行，否则会出现无法执行软链的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 先删除先前的 libc.so.6 软链</span><br><span class="line">rm -rf /lib64/libc.so.6</span><br><span class="line"></span><br><span class="line">// 在执行 LD_PRELOAD 与 ln</span><br><span class="line">LD_PRELOAD=/lib64/libc.2.4.so ln -s  libc.2.4.so  libc.so.6</span><br></pre></td></tr></table></figure><p>linux 调用 so 的库文件时，搜素路径为当前路径，再是系统 lib 目录。<br>但是提供了一个 LD_PRELOAD 系统变量来改变这个顺序。设置 LD_PRELOAD 了后，库加载的顺序就改为：<br>搜素路径为： LD_PRELOAD ，当前路径，再是系统 lib 目录。</p><p><a href="http://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">glibc 版本下载</a></p><p><a href="https://blog.csdn.net/onlyxinye/article/details/77171493" target="_blank" rel="noopener">virtualbox-CentOS 安装</a></p><p><a href="https://blog.csdn.net/u012732259/article/details/70172704" target="_blank" rel="noopener">virtualbox-Ubuntu 安装</a></p><p>其实 CentOS 与 Ubuntu 安装区别不大，主要 Ubuntu 的操作方便，界面优美。</p><p>注意:<br><strong>安装好后使用 root 用户登陆,由于是自己测试的尽量使用最大权限，否则安装一些环境之类的就无法操作</strong></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>虚拟机连接网络有好几种，作用也不一样，而我这里使用的时 NAT 连接，而 virtualbox 可以设置局部的 NAT，也可以设置全局的 NAT，<br>NAT 是虚拟机与主机之间共用网络，所以可以设置为同一网段即可互相通信。</p><p>具体操作可以看<a href="https://www.jianshu.com/p/47f2a756015e" target="_blank" rel="noopener">VirtualBox 在 NAT 模式下主机连接虚拟机的方法</a></p><p>如果不了解自己的设置后为什么不能直接使用 liunx 的 ip:端口被主机访问，可以使用端口转发功能，设置主机 ip 与被转发的端口、liunx 的 ip 与转发端口。</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.92.1 22 10.0.2.4 22</span><br></pre></td></tr></table></figure><p>重启网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h2 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h2><p><a href="https://nodejs.org/download/release/" target="_blank" rel="noopener">node 下载地址:https://nodejs.org/download/release/</a></p><p>选择适合版本下载<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/download/release/latest/node-v13.5.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>wget 是一个下载文件的工具，它用在命令行下。对于 Linux 用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。</p><p>wget 支持 HTTP，HTTPS 和 FTP 协议，可以使用 HTTP 代理。所谓的自动下载是指，wget 可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个 wget 下载任务，然后退出系统，wget 将在后台执行直到任务完成。</p><h3 id="node-安装过程"><a href="#node-安装过程" class="headerlink" title="node 安装过程"></a>node 安装过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解压</span><br><span class="line">tar -xvf node-v13.5.0-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">重命名</span><br><span class="line">mv node-v13.5.0-linux-x64.tar.xz nodeJs</span><br><span class="line"></span><br><span class="line">移动到/opt目录</span><br><span class="line">mv nodeJs /opt</span><br></pre></td></tr></table></figure><p>/opt 主机额外安装软件所摆放的目录。默认是空的。<br>一般安装软件的时候，可以自己指定安装到这个目录下，便于查找和管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">添加环境变量</span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">并在文件的末尾添加三行</span><br><span class="line">NODE_PATH=/opt/nodeJs</span><br><span class="line">PATH=$NODE_PATH/bin:$PATH</span><br><span class="line">export PATH NODE_PATH</span><br><span class="line"></span><br><span class="line">配置完成后执行,否则配置不起效果</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/lh03061238/p/9952659.html" target="_blank" rel="noopener">/etc/profile</a>文件的改变会涉及到系统的环境,也就是有关 Linux 环境变量的东西。</p><p><a href="https://www.cnblogs.com/guojun-junguo/p/9855356.html" target="_blank" rel="noopener">export 设置或显示环境变量。</a></p><p><a href="https://www.cnblogs.com/youyoui/p/10680329.html" target="_blank" rel="noopener">Linux 环境变量配置资料</a></p><h2 id="主机访问-liunx-的部署项目"><a href="#主机访问-liunx-的部署项目" class="headerlink" title="主机访问 liunx 的部署项目"></a>主机访问 liunx 的部署项目</h2><p>新建 webapp 文件夹，在当前目录下执行，创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npx koa-generator -e project(项目名称)</span><br><span class="line">cd project</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>如果 NAT 模式下不能直接访问的，先添加端口转发，然后进行访问项目</p><p>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">端口转发配置</span><br><span class="line">192.168.92.1 3000 10.0.2.4 3000</span><br><span class="line"></span><br><span class="line">然后主机浏览器访问即可</span><br><span class="line">http://192.168.92.1:3000/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;p&gt;virtualBox + CentOS-6.8&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.virtualbox.org/wik</summary>
      
    
    
    
    
    <category term="liunx" scheme="https://793338023.github.io/tags/liunx/"/>
    
  </entry>
  
  <entry>
    <title>koa例子</title>
    <link href="https://793338023.github.io/2019/12/07/koa%E4%BE%8B%E5%AD%90/"/>
    <id>https://793338023.github.io/2019/12/07/koa%E4%BE%8B%E5%AD%90/</id>
    <published>2019-12-07T07:06:16.000Z</published>
    <updated>2019-12-07T08:07:58.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p><h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.安装 cli：</span><br><span class="line">npm install -g koa-generator</span><br><span class="line"></span><br><span class="line">2.新建项目</span><br><span class="line">koa2 [name]</span><br><span class="line"></span><br><span class="line">3.安装依赖</span><br><span class="line">cd [name]</span><br><span class="line">npm i</span><br><span class="line"></span><br><span class="line">4.运行</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 koa 脚手架搭建的，基本上已经满足开发了，但为了方便开发，可以把路由调整一下，因为每次添加路由都操作 app.js 文件，有点麻烦。<br><a href="https://www.koajs.com.cn/#application" target="_blank" rel="noopener">koa 官网</a></p><p>app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&quot;koa&quot;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">const views = require(&quot;koa-views&quot;);</span><br><span class="line">const json = require(&quot;koa-json&quot;);</span><br><span class="line">const onerror = require(&quot;koa-onerror&quot;);</span><br><span class="line">const bodyparser = require(&quot;koa-bodyparser&quot;);</span><br><span class="line">const logger = require(&quot;koa-logger&quot;);</span><br><span class="line"></span><br><span class="line">const routes = require(&quot;./router&quot;);</span><br><span class="line"></span><br><span class="line">// error handler</span><br><span class="line">onerror(app);</span><br><span class="line"></span><br><span class="line">// middlewares</span><br><span class="line">app.use(</span><br><span class="line">  bodyparser(&#123;</span><br><span class="line">    enableTypes: [&quot;json&quot;, &quot;form&quot;, &quot;text&quot;]</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.use(json());</span><br><span class="line">app.use(logger());</span><br><span class="line">app.use(require(&quot;koa-static&quot;)(__dirname + &quot;/public&quot;));</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  views(__dirname + &quot;/views&quot;, &#123;</span><br><span class="line">    extension: &quot;pug&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// logger</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  const start = new Date();</span><br><span class="line">  await next();</span><br><span class="line">  const ms = new Date() - start;</span><br><span class="line">  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// routes</span><br><span class="line">routes(app);</span><br><span class="line"></span><br><span class="line">// error-handling</span><br><span class="line">app.on(&quot;error&quot;, (err, ctx) =&gt; &#123;</span><br><span class="line">  console.error(&quot;server error&quot;, err, ctx);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = app;</span><br></pre></td></tr></table></figure><p>router.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routesArr = [&quot;index&quot;, &quot;users&quot;];</span><br><span class="line"></span><br><span class="line">const baseUrl = &quot;./routes&quot;;</span><br><span class="line"></span><br><span class="line">function routes(app) &#123;</span><br><span class="line">  const newRouters = routesArr.map(url =&gt; &#123;</span><br><span class="line">    return `$&#123;baseUrl&#125;/$&#123;url&#125;`;</span><br><span class="line">  &#125;);</span><br><span class="line">  newRouters.forEach(url =&gt; &#123;</span><br><span class="line">    const router = require(url);</span><br><span class="line">    app.use(router.routes(), router.allowedMethods());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = routes;</span><br></pre></td></tr></table></figure><p>但还可以弄得更加方便，就是使用 fs，读取出所有的路由文件，自动注册路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">const baseUrl = &quot;./routes&quot;;</span><br><span class="line"></span><br><span class="line">// 递归目录 读取文件</span><br><span class="line">function readFileList(dir, filesList = []) &#123;</span><br><span class="line">  const files = fs.readdirSync(dir);</span><br><span class="line">  files.forEach((item, index) =&gt; &#123;</span><br><span class="line">    var fullPath = path.join(dir, item);</span><br><span class="line">    const stat = fs.statSync(fullPath);</span><br><span class="line">    if (stat.isDirectory()) &#123;</span><br><span class="line">      readFileList(path.join(dir, item), filesList); //递归读取文件</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      filesList.push(fullPath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return filesList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function routes(app) &#123;</span><br><span class="line">  let filesList = [];</span><br><span class="line">  readFileList(path.resolve(process.cwd(), baseUrl), filesList);</span><br><span class="line">  filesList.forEach(url =&gt; &#123;</span><br><span class="line">    const router = require(url);</span><br><span class="line">    app.use(router.routes(), router.allowedMethods());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = routes;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通</summary>
      
    
    
    
    
    <category term="node" scheme="https://793338023.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>react与rc-form</title>
    <link href="https://793338023.github.io/2019/11/30/react%E4%B8%8Erc-form/"/>
    <id>https://793338023.github.io/2019/11/30/react%E4%B8%8Erc-form/</id>
    <published>2019-11-30T08:00:58.000Z</published>
    <updated>2019-12-02T14:32:40.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在选择使用 react 技术栈的时，往往都会选择一套成熟好用而且自己熟悉的 UI 框架，而我使用比较多的<a href="https://ant.design/index-cn" target="_blank" rel="noopener">ant Design</a>,这样可以减少开发成本与风险，因为自己开发的组件总会有考虑不周的 BUG，而 antd 里有很多优秀的组件，但我觉得在表单方面，antd 的这个组件做的很优秀，也很灵活，它的核心也在校验，这篇主要是 Form 校验。</p><h2 id="表单作用"><a href="#表单作用" class="headerlink" title="表单作用"></a>表单作用</h2><p>真正需要表单的时候，一般都因为以下功能：</p><ol><li>收集各表单项的数据。</li><li>按照要求，对表单项数据进行校验，并显示校验结果。</li><li>最总获取所有的表单数据，并表单中所有数据进行校验。</li></ol><p>而这些功能 antd 都可以直接按官网案例使用，简单快速，但 antd 实现这些功能也是很简单的，主要是因为它把数据收集与校验都交给了 rc-form 去实现，剩下的 UI 展示才是 antd 实现的。</p><h2 id="antd-的-Form-实现"><a href="#antd-的-Form-实现" class="headerlink" title="antd 的 Form 实现"></a>antd 的 Form 实现</h2><p>Form.tsx</p><p>在 form 的 Form.tsx 只是简单的实现了 Form 的 UI 与 rc-form 的 create 表单，使用 createReactContext 传递了通用布局属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 此处为Form.create的实现，主要调用了createBaseForm</span><br><span class="line">// fieldMetaProp规定了重造组件里存储的表单规则，如校验等，fieldDataProp规定了表单的数据，所以获取到react组件，就可以知道表单属性设置与数据</span><br><span class="line"></span><br><span class="line">  static create = function create&lt;TOwnProps extends FormComponentProps&gt;(</span><br><span class="line">    options: FormCreateOption&lt;TOwnProps&gt; = &#123;&#125;,</span><br><span class="line">  ): FormWrappedProps&lt;TOwnProps&gt; &#123;</span><br><span class="line">    return createDOMForm(&#123;</span><br><span class="line">      fieldNameProp: &apos;id&apos;,</span><br><span class="line">      ...options,</span><br><span class="line">      fieldMetaProp: FIELD_META_PROP,</span><br><span class="line">      fieldDataProp: FIELD_DATA_PROP,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">// 创建表单与createReactContext传递UI布局属性</span><br><span class="line"></span><br><span class="line">   render() &#123;</span><br><span class="line">    const &#123; wrapperCol, labelAlign, labelCol, layout, colon &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;FormContext.Provider</span><br><span class="line">        value=&#123;&#123; wrapperCol, labelAlign, labelCol, vertical: layout === &apos;vertical&apos;, colon &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;ConfigConsumer&gt;&#123;this.renderForm&#125;&lt;/ConfigConsumer&gt;</span><br><span class="line">      &lt;/FormContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>FormItem.tsx</p><p>实现了需要校验组件的布局与校验信息显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// 通过这两个方法获取到组件上的所有表单信息，如值、校验信息，获取的方式就是在组件的props的FIELD_META_PROP与FIELD_DATA_PROP上。</span><br><span class="line"> getMeta() &#123;</span><br><span class="line">    return this.getChildProp(FIELD_META_PROP);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getField() &#123;</span><br><span class="line">    return this.getChildProp(FIELD_DATA_PROP);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 通过getValidateStatus获取校验的状态</span><br><span class="line"></span><br><span class="line">  getValidateStatus() &#123;</span><br><span class="line">    const onlyControl = this.getOnlyControl();</span><br><span class="line">    if (!onlyControl) &#123;</span><br><span class="line">      return &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    const field = this.getField();</span><br><span class="line">    if (field.validating) &#123;</span><br><span class="line">      return &apos;validating&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (field.errors) &#123;</span><br><span class="line">      return &apos;error&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    const fieldValue = &apos;value&apos; in field ? field.value : this.getMeta().initialValue;</span><br><span class="line">    if (fieldValue !== undefined &amp;&amp; fieldValue !== null &amp;&amp; fieldValue !== &apos;&apos;) &#123;</span><br><span class="line">      return &apos;success&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// renderValidateWrapper根据校验状态，选择html结构与css类名，显示校验信息</span><br><span class="line"></span><br><span class="line">  renderValidateWrapper(</span><br><span class="line">    prefixCls: string,</span><br><span class="line">    c1: React.ReactNode,</span><br><span class="line">    c2: React.ReactNode,</span><br><span class="line">    c3: React.ReactNode,</span><br><span class="line">  ) &#123;</span><br><span class="line">    const &#123; props &#125; = this;</span><br><span class="line">    const onlyControl = this.getOnlyControl;</span><br><span class="line">    const validateStatus =</span><br><span class="line">      props.validateStatus === undefined &amp;&amp; onlyControl</span><br><span class="line">        ? this.getValidateStatus()</span><br><span class="line">        : props.validateStatus;</span><br><span class="line"></span><br><span class="line">    let classes = `$&#123;prefixCls&#125;-item-control`;</span><br><span class="line">    if (validateStatus) &#123;</span><br><span class="line">      classes = classNames(`$&#123;prefixCls&#125;-item-control`, &#123;</span><br><span class="line">        &apos;has-feedback&apos;: props.hasFeedback || validateStatus === &apos;validating&apos;,</span><br><span class="line">        &apos;has-success&apos;: validateStatus === &apos;success&apos;,</span><br><span class="line">        &apos;has-warning&apos;: validateStatus === &apos;warning&apos;,</span><br><span class="line">        &apos;has-error&apos;: validateStatus === &apos;error&apos;,</span><br><span class="line">        &apos;is-validating&apos;: validateStatus === &apos;validating&apos;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let iconType = &apos;&apos;;</span><br><span class="line">    switch (validateStatus) &#123;</span><br><span class="line">      case &apos;success&apos;:</span><br><span class="line">        iconType = &apos;check-circle&apos;;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;warning&apos;:</span><br><span class="line">        iconType = &apos;exclamation-circle&apos;;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;error&apos;:</span><br><span class="line">        iconType = &apos;close-circle&apos;;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;validating&apos;:</span><br><span class="line">        iconType = &apos;loading&apos;;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        iconType = &apos;&apos;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const icon =</span><br><span class="line">      props.hasFeedback &amp;&amp; iconType ? (</span><br><span class="line">        &lt;span className=&#123;`$&#123;prefixCls&#125;-item-children-icon`&#125;&gt;</span><br><span class="line">          &lt;Icon type=&#123;iconType&#125; theme=&#123;iconType === &apos;loading&apos; ? &apos;outlined&apos; : &apos;filled&apos;&#125; /&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      ) : null;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&#123;classes&#125;&gt;</span><br><span class="line">        &lt;span className=&#123;`$&#123;prefixCls&#125;-item-children`&#125;&gt;</span><br><span class="line">          &#123;c1&#125;</span><br><span class="line">          &#123;icon&#125;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &#123;c2&#125;</span><br><span class="line">        &#123;c3&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以使用 antd Form 需要把组件放到 Form 与 FormItem 里,否则会出现 UI 问题。</p><h2 id="rc-form"><a href="#rc-form" class="headerlink" title="rc-form"></a>rc-form</h2><p>rc-form 的实现是使用了高阶组件，这里不说高阶组件，然后利用闭包的收集数据，类似与全局变量，创建一个对象，根据 ID 收集放到对应的 ID 里，简单就是这样。<br>源码主要看 createBaseForm 与 createFieldsStore，createBaseForm 主要是实现功能，如校验，获取数据等等，而 createFieldsStore 主要实现数据收集与处理，然后让 createBaseForm 使用。</p><p>createBaseForm 数据的更新是使用了 <a href="https://blog.csdn.net/milyoo/article/details/79068199" target="_blank" rel="noopener">forceUpdate</a>，这是 react 强制更新组件的方法，可以在没有触发 setState 时触发 render 来实现数据更新，它的实现与 setState 差不多。</p><p>mapPropsToFields 的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">getInitialState() &#123;</span><br><span class="line">        const fields = mapPropsToFields &amp;&amp; mapPropsToFields(this.props);</span><br><span class="line">        this.fieldsStore = createFieldsStore(fields || &#123;&#125;);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">// 父组件state变化</span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        if (mapPropsToFields) &#123;</span><br><span class="line">          this.fieldsStore.updateFields(mapPropsToFields(nextProps));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>由于在创建组件时都用 Form 包含，所以组件之间需要经过 Form，那么就可以利用这个实现数据映射关系。</p><p>所有的校验都会统一走 validateFieldsInternal 方法，而一般的回填与映射是不会触发校验的，只有符合事件的或手动调用校验才会触发校验，而校验使用的<a href="https://www.npmjs.com/package/async-validator" target="_blank" rel="noopener">async-validator</a>这个包。</p><p>注意事项:</p><ol><li>由于 rc-form 的 ID 允许嵌套，所以 ID 避免实现”.”与[,如 abc.mm,abc[0]</li><li>rc-form 校验的 type 为 Array 时，避免 ID 带数字，如 abc111m1</li></ol><p>具体实现可以查看<a href="https://blog.csdn.net/chencl1986/article/details/102326854" target="_blank" rel="noopener">资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在选择使用 react 技术栈的时，往往都会选择一套成熟好用而且自己熟悉的 UI 框架，而我使用比较多的&lt;a href=&quot;https://a</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>git提交前代码检查</title>
    <link href="https://793338023.github.io/2019/11/19/git%E6%8F%90%E4%BA%A4%E5%89%8D%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/"/>
    <id>https://793338023.github.io/2019/11/19/git%E6%8F%90%E4%BA%A4%E5%89%8D%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/</id>
    <published>2019-11-19T13:19:24.000Z</published>
    <updated>2020-05-08T15:28:46.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当项目在团队上开发时，总要遵循一些规范，就算使用了 tslint 或 eslint 等，但上交代码时由于没有禁止不良代码，有些人在不遵守规范时，还是会提交那么很坑的代码，让我们的项目挂了，这个时候，所以一切的代码在不经过检查，都不能信任，而这一层的把关，我交给 git 的钩子。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当我们使用 git 时，都会有一个.git 的文件夹，而它底下有所有的钩子，在 hooks 目录下，我们可以看到目录下有 commit-msg.sample、pre-commit.sample 等文件，这些都是案例文件，不会执行，要想执行的话把后面的.sample 后缀去掉就可以了。<br>钩子执行顺序是有先后的</p><ol><li>前置（pre）钩子，在动作完成前调用</li><li>后置（post）钩子，在动作完成后执行</li></ol><p>而我们利用这个钩子实现提交前检查代码，不符合的，就停止提交。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm  install husky lint-staged --D</span><br><span class="line"></span><br><span class="line">检查代码使用eslint或tslint</span><br><span class="line">npm  install eslint  --D</span><br><span class="line">npm  install tslint  --D</span><br></pre></td></tr></table></figure><ol><li>eslint：进行 JavaScript 代码检查的基础包；</li><li>tslint: TypeScript 代码检查的基础包；</li><li><a href="https://www.npmjs.com/package/husky" target="_blank" rel="noopener">husky</a>：在 .git/4 hooks 中写入 pre-commit 等脚本激活钩子，在 Git 操作时触发；</li><li><a href="https://www.npmjs.com/package/lint-staged" target="_blank" rel="noopener">lint-staged</a>：参考 Git 中 staged 暂存区概念，在每次提交时只检查本次提交的文件。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在 package.json 配置 husky 与 lint-staged。</p><p>tslint:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">    &quot;hooks&quot;: &#123;</span><br><span class="line">      &quot;pre-commit&quot;: &quot;lint-staged&quot; // pre-commit，提交前的钩子</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    // 此处可以配置文件夹和文件类型的范围</span><br><span class="line">    &quot;src/**/*.&#123;txs,ts&#125;&quot;: [</span><br><span class="line">      &quot;tslint&quot;, // 再使用tslint</span><br><span class="line">      &quot;git add&quot; // 所有通过的话执行git</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>eslint:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">    &quot;hooks&quot;: &#123;</span><br><span class="line">      &quot;pre-commit&quot;: &quot;lint-staged&quot; // pre-commit，提交前的钩子</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    // 此处可以配置文件夹和文件类型的范围</span><br><span class="line">    &quot;src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125;&quot;: [</span><br><span class="line">      &quot;eslint --fix&quot;, // 再使用eslint进行自动修复</span><br><span class="line">      &quot;git add&quot; // 所有通过的话执行git</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至于 eslint 或 tslint 的配置，这个就需要自己百度。</p><p>tslint 例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;tslint&quot;,</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;no-parameter-properties&quot;:false, // 禁止给类的构造函数的参数添加修饰符</span><br><span class="line">    &quot;triple-equals&quot;:false,</span><br><span class="line">    &quot;no-debugger&quot;: true,</span><br><span class="line">    // 禁止行尾有空格</span><br><span class="line">    &quot;no-trailing-whitespace&quot;: false,</span><br><span class="line">    &quot;member-ordering&quot;:false,</span><br><span class="line">    &quot;no-this-assignment&quot;: [true, &#123;&quot;allowed-names&quot;: [&quot;^self$&quot;,&quot;^that$&quot;], &quot;allow-destructuring&quot;: true&#125;],</span><br><span class="line">    // 必须使用箭头函数，除非是单独的函数声明或是命名函数</span><br><span class="line">    &quot;only-arrow-functions&quot;: [</span><br><span class="line">      false,</span><br><span class="line">      &quot;allow-declarations&quot;,</span><br><span class="line">      &quot;allow-named-functions&quot;</span><br><span class="line">    ],</span><br><span class="line">    // 禁止出现空代码块，允许 catch 是空代码块</span><br><span class="line">    &quot;no-empty&quot;: [</span><br><span class="line">      false,</span><br><span class="line">      &quot;allow-empty-catch&quot;</span><br><span class="line">    ],</span><br><span class="line">    // 禁止无用的类型断言</span><br><span class="line">    &quot;no-unnecessary-type-assertion&quot;: false,</span><br><span class="line">    // 使用 return; 而不是 return undefined;</span><br><span class="line">    &quot;return-undefined&quot;: false,</span><br><span class="line">    // 禁止对 array 使用 for in 循环</span><br><span class="line">    &quot;no-for-in-array&quot;: false,</span><br><span class="line">    &quot;comment-format&quot;: [true, &quot;check-space&quot;] // 单行注释格式化规则</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eslint 例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: [&quot;airbnb&quot;, &quot;plugin:prettier/recommended&quot;], // eslint扩展规则</span><br><span class="line">  &quot;parserOptions&quot;: &#123;</span><br><span class="line">    &quot;ecmaVersion&quot;: 7,</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;,</span><br><span class="line">    &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">      &quot;jsx&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;parser&quot;: &quot;babel-eslint&quot;,// 解决ES6 improt会报错</span><br><span class="line">  &quot;env&quot;: &#123; // eg如果不配置browser，window就会被eslint报undefined的错</span><br><span class="line">    &quot;es6&quot;: true,</span><br><span class="line">    &quot;browser&quot;: true,</span><br><span class="line">    &quot;node&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;plugins&quot;: [&quot;react&quot;, &quot;jsx-a11y&quot;, &quot;import&quot;],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;class-methods-use-this&quot;: 0,</span><br><span class="line">    &quot;import/no-named-as-default&quot;: 0,</span><br><span class="line">    &quot;react/jsx-filename-extension&quot;: [</span><br><span class="line">      &quot;error&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们还可以使用 prettier 美化提交的代码。<br>prettier 配置资料(<a href="https://blog.csdn.net/visionke/article/details/92817269" target="_blank" rel="noopener">https://blog.csdn.net/visionke/article/details/92817269</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当项目在团队上开发时，总要遵循一些规范，就算使用了 tslint 或 eslint 等，但上交代码时由于没有禁止不良代码，有些人在不遵守规范</summary>
      
    
    
    
    
    <category term="代码规范" scheme="https://793338023.github.io/tags/代码规范/"/>
    
  </entry>
  
  <entry>
    <title>微前端之systemJS与lerna</title>
    <link href="https://793338023.github.io/2019/11/13/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8BsystemJS%E4%B8%8Elerna/"/>
    <id>https://793338023.github.io/2019/11/13/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8BsystemJS%E4%B8%8Elerna/</id>
    <published>2019-11-13T15:06:29.000Z</published>
    <updated>2019-11-17T16:13:19.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微前端架构是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</p><p>由此带来的变化是，这些前端应用可以独立运行、独立开发、独立部署。以及，它们应该可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p><p>可以解决的问题:拆分工程，解决打包速度的问题，减少一个工程太多人开发出现的互相冲突的问题，降低项目的复杂度，提高项目可维护性与修改性的问题，无论在管理上还是代码上都大大提高工作效率。</p><p>这里只是描述一下微前端，最要还是 systemJS 与 lerna，因为他们在微前端上是核心。</p><h2 id="微前端实现的方式"><a href="#微前端实现的方式" class="headerlink" title="微前端实现的方式"></a>微前端实现的方式</h2><ol><li>使用 HTTP 服务器的路由来重定向多个应用</li><li>在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA</li><li>通过组合多个独立应用、组件来构建一个单体应用</li><li>iFrame。使用 iFrame 及自定义消息传递机制</li><li>使用 Web Components 构建应用</li></ol><p>第一种是目前比较传统的方式，如 A 项目与 B 项目互相跳转，那么我们只要在 URL 上带上个项目需要参数即可，就是很简单的页面跳转方式，也是很通用的方式，就是会页面刷新并且互相之间不能嵌套或复用。</p><p>第二种方式，是符合现在单页面应用的方式，而且可以互相复用，但需要基于 webpack 等打包工具。</p><p>第三种其实就是一个应用，只是把它分开开发，所以必须使用同一个框架，统一依赖，规范应用的组件及路由，共享通用代码，制定代码规范，比如使用 lerna 管理项目。</p><p>第四种 iFrame 其实与第一种差不多，只是它可以嵌套在别的项目里，实现互相嵌套的模式。</p><p>第五种 Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 Web 应用中使用它们，它的引用方式与 iframe 类似，组件拥有自己独立的 Scripts 和 Styles，以及对应的用于单独部署组件的域名，但它不成熟，不过它很有可能是以后微前端的技术方向，因为它很适合，且将来浏览器应该都支持，而不需要构建工具，浏览器支持才是最 nice 的。</p><h2 id="systemJS"><a href="#systemJS" class="headerlink" title="systemJS"></a>systemJS</h2><p>systemJS 其实就是一个模块化加载器，本意是解决项目在运行时加载模块的问题，因为 webpack 等打包工具都是编译好后再到客户端上，而想在客户端上加载时不可能的。<br>但 systemJS 无法直接使用 import 加载后使用，只能在 html 里 script 引入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/system.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/amd.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/named-exports.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/named-register.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/use-default.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  System.import(</span><br><span class="line">    &quot;http://localhost:8000/static/js/main-bundle-11a3188c.js&quot;</span><br><span class="line">  ).then(() =&gt; &#123;</span><br><span class="line">    // console.log($);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但可以 npm 安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i systemjs</span><br></pre></td></tr></table></figure><p>webpack 打包的，要让 systemjs 可以加载，那么就要设置 libraryTarget 为 umd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &quot;static/js/[name]-bundle-[hash:8].js&quot;,</span><br><span class="line">    library: &quot;app&quot;, //类库名称</span><br><span class="line">    libraryTarget: &quot;umd&quot; //类库加载方式</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>而微服务里比较流行的是 single-Spa，它其实就是一个顶级的路由，只是它是以项目为维度的，而且它兼容很多目前比较流行的技术的项目的路由，如 react，vue，angular 等等，他可以糅合它们，而且不需要前期考虑是否使用微前端，之后后期需要，就可以使用它进行重新改造，且付出代价也是最小的，可能就是需要修改一个路由的层级，因为一级路由以为项目使用。</p><p><a href="https://www.npmjs.com/package/systemjs" target="_blank" rel="noopener">资料</a></p><p><a href="https://www.cnblogs.com/xhy-steve/p/6655603.html" target="_blank" rel="noopener">基本使用</a></p><p><a href="https://single-spa.js.org/docs/getting-started-overview/" target="_blank" rel="noopener">single-Spa</a></p><p><a href="https://www.cnblogs.com/scdisplay/p/11648701.html" target="_blank" rel="noopener">single-Spa 使用</a></p><h2 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h2><p>lerna 是 GitHub 上面开源的一款 js 代码库管理软件， 用来对一系列相互耦合比较大、又相互独立的 js git 库进行管理。解决各个库之间修改混乱、难以跟踪的问题。lerna 可以优化这种情形下的工作流。</p><p>代码库结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my-lerna-repo/</span><br><span class="line">  package.json</span><br><span class="line">  packages/</span><br><span class="line">    package-1/</span><br><span class="line">      package.json</span><br><span class="line">    package-2/</span><br><span class="line">      package.json</span><br></pre></td></tr></table></figure><p>由于微前端也是多个项目模块，而且也会互相耦合且独立，所以使用 lerna 管理，在某些场景下，可能会出现意想不到的优势，比如个项目之间的依赖包统一，各项目之间依赖简单，且快速统一更新包等，且只要在外层就可管理到所有的项目。</p><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i -g lerna</span><br><span class="line">mkdir lerna-repo</span><br><span class="line">cd ./lerna-repo</span><br><span class="line">lerna init</span><br></pre></td></tr></table></figure><p>常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 安装</span><br><span class="line">lerna bootstrap</span><br><span class="line">使用这个指令代替 npm install</span><br><span class="line">相当于在每个 package 下面执行 npm install</span><br><span class="line">根据各个 package 下 package.json 里面的 dependencies 和 devDependencies 配置，使用 symlink 在各个 package 的 node_modules 下面建立引用关系</span><br><span class="line"></span><br><span class="line">2. 添加依赖</span><br><span class="line">lerna add &lt;pkg&gt; [globs..]</span><br><span class="line"></span><br><span class="line">如给  package-1 添加 依赖 vue，scope后要跟package.json里面的名字，而不是文件夹名。如果全部安装，去掉scope即可。</span><br><span class="line"></span><br><span class="line">lerna add vue --scope=@abc/package-1</span><br><span class="line"></span><br><span class="line">3. 指定源</span><br><span class="line">例如使用yarn管理包 lerna bootstrap --npm-client=yarn</span><br><span class="line">例如使用cnpm发布包 lerna publish --npm-client=cnpm</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/8b7e6025354b" target="_blank" rel="noopener">lerna 的基础使用</a></p><p><a href="https://www.jianshu.com/p/2f9c05b119c9" target="_blank" rel="noopener">lerna 项目中使用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;微前端架构是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>webpack之实现loader</title>
    <link href="https://793338023.github.io/2019/10/26/webpack%E4%B9%8B%E5%AE%9E%E7%8E%B0loader/"/>
    <id>https://793338023.github.io/2019/10/26/webpack%E4%B9%8B%E5%AE%9E%E7%8E%B0loader/</id>
    <published>2019-10-26T03:59:30.000Z</published>
    <updated>2019-10-26T05:58:54.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 webpack 时，我们一般都会知道 loader 与 plugin,因为在使用 webpack 时，必不可少，而这边主要了解和知道怎么实现 loader。<br>loader 是一种对指定内容的打包方案，如在 webpack 中的 rules 某一条配置的规则 test 是匹配 css 类的文件，当遇到这类 css 格式文件，webpack 就会执行这条 rules 里的 loader,实现我们期望的内容打包处理。而 Npm 上有各种各样的 loader 供我们使用，一般情况下，直接下载使用即可，没有必要自己动手实现，但由于项目的特殊性，npm 无法找到适合的包，那么只能自己实现。</p><h2 id="什么是-Loader"><a href="#什么是-Loader" class="headerlink" title="什么是 Loader"></a>什么是 Loader</h2><p>本质上来说，loader 就是一个 node 模块，既然是 node 模块，那就一定会导出点什么。在 webpack 的定义中，loader 导出一个函数，loader 会在转换源模块（resource）的时候调用该函数。在这个函数内部，我们可以通过传入 this 上下文给 <a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">Loader API </a>来使用它们。<br>简单说，就是与写 node 没有很大区别，只是 webpack 那些 Loader API 都使用需要使用 this 调用。</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(content) &#123;</span><br><span class="line">  if (this.query.isAdd) &#123;</span><br><span class="line">    return content+&quot;isAdd&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="在-webpack-config-里怎么使用自定-loader"><a href="#在-webpack-config-里怎么使用自定-loader" class="headerlink" title="在 webpack config 里怎么使用自定 loader"></a>在 webpack config 里怎么使用自定 loader</h2><p>一般有三种方式:</p><ol><li>把编写好的 loader 模块发布到 npm 上或放到 package.json 能把包引入到 node_mudules 的地址上。</li><li>npm link 方式关联起来。</li><li>使用 require.resolve 或 path.resolve 方式引入。<br>如</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.resolve(&quot;../loader/add-body-css-loader&quot;)</span><br><span class="line">----</span><br><span class="line">path.resolve(__dirname, &quot;../loader/add-body-css-loader&quot;)</span><br></pre></td></tr></table></figure><p>而 loader 的加载调用顺序是自下而上或自右到左的方式，而 source 是一层层 loader 去处理的，就像加工厂一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:  /\.module\.(scss|sass)$/,</span><br><span class="line">    use: [</span><br><span class="line">        require.resolve(&quot;style-loader&quot;),</span><br><span class="line">        require.resolve(&quot;postcss-loader&quot;),</span><br><span class="line">        require.resolve(&quot;../loader/add-body-css-loader&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 add-body-css-loader-&gt;postcss-loader-&gt;style-loader 然后输出到文件里。</p><h2 id="用正确的姿势开发-Loader"><a href="#用正确的姿势开发-Loader" class="headerlink" title="用正确的姿势开发 Loader"></a>用正确的姿势开发 Loader</h2><ol><li><p>单一职责<br>一个 loader 只做一件事，这样不仅可以让 loader 的维护变得简单，还能让 loader 以不同的串联方式组合出符合场景需求的搭配。</p></li><li><p>链式组合<br>这一点是第一点的延伸。好好利用 loader 的链式组合的特型，可以收获意想不到的效果。具体来说，写一个能一次干 5 件事情的 loader ，不如细分成 5 个只能干一件事情的 loader，也许其中几个能用在其他你暂时还没想到的场景。</p></li></ol><h2 id="Loader-实用工具"><a href="#Loader-实用工具" class="headerlink" title="Loader 实用工具"></a>Loader 实用工具</h2><p><a href="https://juejin.im/post/5c9d8539f265da60d95fd590" target="_blank" rel="noopener">loader-utils</a><br><a href="https://www.npmjs.com/package/schema-utils" target="_blank" rel="noopener">schema-utils</a> 使用来校验 Options。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>sass、less 等简单的生成主题处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">const log4js = require(&quot;../config/log4js&quot;),</span><br><span class="line">  logger = log4js.getLogger(&quot;info&quot;);</span><br><span class="line"></span><br><span class="line">function replace(source) &#123;</span><br><span class="line">  const theme = this.query.theme;</span><br><span class="line">  let isBody = false;</span><br><span class="line">  let content = source;</span><br><span class="line">  let loader = this.query.loader;</span><br><span class="line">  Object.keys(theme).forEach(item =&gt; &#123;</span><br><span class="line">    Object.keys(theme[item]).forEach(item =&gt; &#123;</span><br><span class="line">      if (~source.indexOf(item)) &#123;</span><br><span class="line">        isBody = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  if (isBody) &#123;</span><br><span class="line">    if (~loader.indexOf(&quot;less&quot;)) &#123;</span><br><span class="line">      content = createThemeLessVar(theme, source, loader);</span><br><span class="line">    &#125; else if (~loader.indexOf(&quot;sass&quot;)) &#123;</span><br><span class="line">      content = createThemeSassVar(theme, source, loader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createThemeSassVar(theme, source, loader) &#123;</span><br><span class="line">  let prefix = &quot;$&quot;;</span><br><span class="line">  let reg = /(@import[^\n]*)/g;</span><br><span class="line">  let importCss = source.match(reg) || &quot;&quot;;</span><br><span class="line">  if (importCss) &#123;</span><br><span class="line">    importCss = importCss.join(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  let newSource = source.replace(reg, &quot;&quot;);</span><br><span class="line">  let content = `$&#123;importCss&#125;`;</span><br><span class="line">  Object.keys(theme).forEach(item =&gt; &#123;</span><br><span class="line">    let allVar =</span><br><span class="line">      Object.entries(theme[item])</span><br><span class="line">        .map(item =&gt; &#123;</span><br><span class="line">          return prefix + item[0] + &quot;:&quot; + item[1];</span><br><span class="line">        &#125;)</span><br><span class="line">        .join(&quot;;&quot;) + &quot;;&quot;;</span><br><span class="line"></span><br><span class="line">    content += `</span><br><span class="line">      body[data-theme=&quot;$&#123;item&#125;&quot;]&#123;</span><br><span class="line">        $&#123;allVar&#125;</span><br><span class="line">        $&#123;newSource&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    `;</span><br><span class="line">  &#125;);</span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createThemeLessVar(theme, source, loader) &#123;</span><br><span class="line">  let prefix = &quot;@&quot;;</span><br><span class="line">  let reg = /(@import[^\n]*)/g;</span><br><span class="line">  let importCss = source.match(reg).join(&quot;\n&quot;);</span><br><span class="line">  let newSource = source.replace(reg, &quot;&quot;);</span><br><span class="line">  let content = `$&#123;importCss&#125;`;</span><br><span class="line"></span><br><span class="line">  Object.keys(theme).forEach(item =&gt; &#123;</span><br><span class="line">    let allVar =</span><br><span class="line">      Object.entries(theme[item])</span><br><span class="line">        .map(item =&gt; &#123;</span><br><span class="line">          return prefix + item[0] + &quot;:&quot; + item[1];</span><br><span class="line">        &#125;)</span><br><span class="line">        .join(&quot;;&quot;) + &quot;;&quot;;</span><br><span class="line">    let cssFn = `</span><br><span class="line">      .$&#123;item&#125;()&#123;</span><br><span class="line">        $&#123;allVar&#125;</span><br><span class="line">        $&#123;newSource&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    `;</span><br><span class="line"></span><br><span class="line">    content += `</span><br><span class="line">      $&#123;cssFn&#125;</span><br><span class="line">      body[data-theme=&quot;$&#123;item&#125;&quot;]&#123;</span><br><span class="line">        .$&#123;item&#125;();</span><br><span class="line">      &#125;</span><br><span class="line">    `;</span><br><span class="line">  &#125;);</span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = function(content) &#123;</span><br><span class="line">  if (this.query.isAdd) &#123;</span><br><span class="line">    return replace.call(this, content);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当内部有异步处理时可以使用 this.async(),会返回一个 callback 函数，调用它，代表当前 loader 已经处理完，到下一个或结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import path from &apos;path&apos;;</span><br><span class="line"></span><br><span class="line">export default function(source) &#123;</span><br><span class="line">    var callback = this.async();</span><br><span class="line">    var headerPath = path.resolve(&apos;header.js&apos;);</span><br><span class="line"></span><br><span class="line">    this.addDependency(headerPath);</span><br><span class="line"></span><br><span class="line">    fs.readFile(headerPath, &apos;utf-8&apos;, function(err, header) &#123;</span><br><span class="line">        if(err) return callback(err);</span><br><span class="line">        //这里的 callback 相当于异步版的 return</span><br><span class="line">        callback(null, header + &quot;\n&quot; + source);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>async 返回的 callback 入参:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.callback(</span><br><span class="line">  err: Error | null,</span><br><span class="line">  content: string | Buffer,</span><br><span class="line">  sourceMap?: SourceMap,</span><br><span class="line">  meta?: any</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">第一个参数必须为Error或null</span><br><span class="line">第二个参数是string或Buffer,既处理后的内容。</span><br><span class="line">可选：第三个参数必须是可由此模块解析的源映射。</span><br><span class="line">可选：webpack忽略的第四个选项可以是任何内容（例如某些元数据）。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/793338023/react-skin" target="_blank" rel="noopener">例子项目地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在使用 webpack 时，我们一般都会知道 loader 与 plugin,因为在使用 webpack 时，必不可少，而这边主要了解和知道</summary>
      
    
    
    
    
    <category term="webpack" scheme="https://793338023.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>create-react-app无法在IE下运行</title>
    <link href="https://793338023.github.io/2019/09/14/create-react-app%E6%97%A0%E6%B3%95%E5%9C%A8IE%E4%B8%8B%E8%BF%90%E8%A1%8C/"/>
    <id>https://793338023.github.io/2019/09/14/create-react-app%E6%97%A0%E6%B3%95%E5%9C%A8IE%E4%B8%8B%E8%BF%90%E8%A1%8C/</id>
    <published>2019-09-14T12:49:26.000Z</published>
    <updated>2019-09-14T13:25:33.448Z</updated>
    
    <content type="html"><![CDATA[<p>由于 ie 浏览器需要兼容的需求在现在已经越来越少了，所以 react 脚手架对这部分不进行兼容了，但我们可以安装 polyfill 解决。</p><p>而目前解决方法就是安装 create-react-app，然后使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-app-polyfill</span><br></pre></td></tr></table></figure><p>然后<code>src/index.js</code>里添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 注意一定要在最顶部添加，否则无效</span><br><span class="line">import &apos;react-app-polyfill/ie11&apos;;</span><br><span class="line">import &apos;react-app-polyfill/stable&apos;;</span><br></pre></td></tr></table></figure><p>再然后修改 package.json 里面的 browserslist 就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: &#123;</span><br><span class="line">    &quot;production&quot;: [</span><br><span class="line">      &quot;&gt;0.2%&quot;,</span><br><span class="line">      &quot;not dead&quot;,</span><br><span class="line">      &quot;not op_mini all&quot;,</span><br><span class="line">      &quot;ie 11&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;development&quot;: [</span><br><span class="line">      &quot;last 1 chrome version&quot;,</span><br><span class="line">      &quot;last 1 firefox version&quot;,</span><br><span class="line">      &quot;last 1 safari version&quot;,</span><br><span class="line">      &quot;ie 11&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这个需要在<code>ie 11</code>一定要添加，并且建议加到数组的最后。</p><p>还有就是最好把 node<em>modules 里的所有包都重新安装一次，因为可能我们的配置并没有生效，这是因为 babel-loader 没有检测到 package.json 中的改变，一个最简单的解决方式就是直接删除掉 node_modules/.cache</em> 文件夹，重新编译。</p><p>这样我们就可以兼容 ie11 的版本了。</p><p>当然，如果 ie11 还报错,可以试一下把<code>babel-polyfill</code>也安装上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-polyfill -S</span><br></pre></td></tr></table></figure><p>然后在 webpack 的配置文件的 entry 里添加<code>&quot;babel-polyfill&quot;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry:[</span><br><span class="line">    &quot;babel-polyfill&quot;,</span><br><span class="line">    &quot;src/index.js&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于 ie 浏览器需要兼容的需求在现在已经越来越少了，所以 react 脚手架对这部分不进行兼容了，但我们可以安装 polyfill 解决。&lt;/p&gt;
&lt;p&gt;而目前解决方法就是安装 create-react-app，然后使用。&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react与typescript</title>
    <link href="https://793338023.github.io/2019/08/28/react%E4%B8%8Etypescript/"/>
    <id>https://793338023.github.io/2019/08/28/react%E4%B8%8Etypescript/</id>
    <published>2019-08-28T15:15:52.000Z</published>
    <updated>2019-09-28T07:24:50.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TypeScript 是 JS 类型的超集，并支持了泛型、类型、命名空间、枚举等特性，弥补了 JS 在大型应用开发中的不足。<br>使用 TypeScript 的编程体验最直观的是当在键盘上敲下 <code>.</code> 时，后面这一大串的提示真的是很方便，代码质量和效率提升十分明显，习惯后真的会使用不惯 JavaScript。<br>但是 TypeScript 和一些框架结合使用的话坑还是比较多的，例如使用 antd 框架的时候需要去查看框架提供的 .d.ts 的声明文件中一些复杂类型的定义，或者一些没有使用 TypeScript 插件结合起来使用会出现障碍等等。</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>在使用 React 时需要把 React 的 TypeScript 模块的声明包安装一下，否则会在使用 React 时无法找到某些模块而报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @types/react @types/react-dom -S</span><br></pre></td></tr></table></figure><h3 id="使用-class-类名开发组件"><a href="#使用-class-类名开发组件" class="headerlink" title="使用 class 类名开发组件"></a>使用 class 类名开发组件</h3><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  color: string,</span><br><span class="line">  size?: string,</span><br><span class="line">&#125;</span><br><span class="line">interface IState &#123;</span><br><span class="line">  count: number,</span><br><span class="line">&#125;</span><br><span class="line">class App extends React.Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  public state = &#123;</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;</span><br><span class="line">  public render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;Hello world&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript 可以对 JSX 进行解析，充分利用其本身的静态检查功能，使用泛型进行 Props、 State 的类型定义。定义后在使用 this.state 和 this.props 时可以在编辑器中获得更好的智能提示，并且会对类型进行检查。<br>Component 的泛型如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Component&lt;P, S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    state: Readonly&lt;S&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 只列举了props与state的定义</span><br><span class="line">// Component 这个泛型类， P 代表 Props 的类型， S 代表 State 的类型。</span><br></pre></td></tr></table></figure><p>Readonly 泛型把传入的值变为只读，如以上 props 定义的类型都变为只读。<br>Readonly 实现源码 node_modules/typescript/lib/lib.es5.d.ts ，是 typescript 自带的。</p><p>由于 props 属性被设置为只读，所以通过 this.props.size = ‘sm’ 进行更新时候 TS 检查器会进行错误提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(23, 16) TS2540: Cannot assign to &apos;size&apos; because it is a constant or a read-only property</span><br></pre></td></tr></table></figure><p>state 也一样为只读，而 React 的 state 更新需要使用 setState 方法，直接修改 state TS 检查器会进行错误提示。</p><h2 id="使用-Function-开发组件"><a href="#使用-Function-开发组件" class="headerlink" title="使用 Function 开发组件"></a>使用 Function 开发组件</h2><p>在 React 的声明文件中 已经定义了一个 SFC 类型，使用这个类型可以避免我们重复定义 children、 propTypes、 contextTypes、 defaultProps、displayName 的类型。</p><p>使用 SFC 进行无状态组件开发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SFC &#125; from &apos;react&apos;</span><br><span class="line">import &#123; MouseEvent &#125; from &apos;react&apos;</span><br><span class="line">import * as React from &apos;react&apos;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  onClick (event: MouseEvent&lt;HTMLDivElement&gt;): void,</span><br><span class="line">&#125;</span><br><span class="line">const Button: SFC&lt;IProps&gt; = (&#123;onClick, children&#125;) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class="line">      &#123; children &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default Button;</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>我们在进行事件注册时经常会在事件处理函数中使用 event 事件对象，比如 input 输入后需要获取它的 value 值，那么就要使用<code>event.target.value</code>,但没有定义 ts 就无法通过 ts 检查，而定义 any 会失去静态检查的意义，还有一个问题就是对 event 定义 any，那么获取 event.target 下的属性也会报错，因为 any 只对 event 的属性定义的，而自已通过 interface 对 event 对象进行类型声明编写的话又十分浪费时间，幸运的是 React 的声明文件提供了 Event 对象的类型声明。</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  change = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">    console.log(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  public render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; onChange=&#123;this.change&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Event-事件对象类型"><a href="#Event-事件对象类型" class="headerlink" title="Event 事件对象类型"></a>Event 事件对象类型</h3><p>常用 Event 事件对象类型：</p><ol><li><p>ClipboardEvent<t =="" element=""> 剪贴板事件对象</t></p></li><li><p>DragEvent<t =="" element=""> 拖拽事件对象</t></p></li><li><p>ChangeEvent<t =="" element=""> Change 事件对象</t></p></li><li><p>KeyboardEvent<t =="" element=""> 键盘事件对象</t></p></li><li><p>MouseEvent<t =="" element=""> 鼠标事件对象</t></p></li><li><p>TouchEvent<t =="" element=""> 触摸事件对象</t></p></li><li><p>WheelEvent<t =="" element=""> 滚轮事件对象</t></p></li><li><p>AnimationEvent<t =="" element=""> 动画事件对象</t></p></li><li><p>TransitionEvent<t =="" element=""> 过渡事件对象</t></p></li></ol><p>实现源码的 node_modules/@types/react/index.d.ts</p><h3 id="事件处理函数类型"><a href="#事件处理函数类型" class="headerlink" title="事件处理函数类型"></a>事件处理函数类型</h3><p>当我们定义事件处理函数时有没有更方便定义其函数类型的方式呢？答案是使用 React 声明文件所提供的 EventHandler 类型别名，通过不同事件的 EventHandler 的类型别名来定义事件处理函数的类型。</p><p>EventHandler 类型实现源码 node_modules/@types/react/index.d.ts 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; = &#123; bivarianceHack(event: E): void &#125;[&quot;bivarianceHack&quot;];</span><br><span class="line">type ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;</span><br><span class="line">type ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;</span><br><span class="line">type DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;;</span><br><span class="line">type FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;;</span><br><span class="line">type FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;;</span><br><span class="line">type ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;</span><br><span class="line">type KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;</span><br><span class="line">type MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;;</span><br><span class="line">type TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;;</span><br><span class="line">type PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;;</span><br><span class="line">type UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;;</span><br><span class="line">type WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;;</span><br><span class="line">type AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;</span><br><span class="line">type TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>EventHandler 接收 E ，其代表事件处理函数中 event 对象的类型。<br>bivarianceHack 为事件处理函数的类型定义，函数接收一个 event 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  onClick: React.MouseEventHandler&lt;HTMLInputElement&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&lt;IProps, &#123;&#125;&gt; &#123;</span><br><span class="line"></span><br><span class="line">  public render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          onClick=&#123;this.props.onClick&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-类型"><a href="#Promise-类型" class="headerlink" title="Promise 类型"></a>Promise 类型</h3><p>在做异步操作时我们经常使用 async 函数，函数调用时会 return 一个 Promise 对象，可以使用 then 方法添加回调函数。</p><p><code>Promise&lt;T&gt;</code> 是一个泛型类型，T 泛型变量用于确定使用 then 方法时接收的第一个回调函数的参数类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface IResponse&lt;T&gt; &#123;</span><br><span class="line">  message: string,</span><br><span class="line">  result: T,</span><br><span class="line">  success: boolean,</span><br><span class="line">&#125;</span><br><span class="line">async function getResponse (): Promise&lt;IResponse&lt;number[]&gt;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    message: &apos;获取成功&apos;,</span><br><span class="line">    result: [1, 2, 3],</span><br><span class="line">    success: true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getResponse()</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(response.result)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>我们首先声明 IResponse 的泛型接口用于定义 response 的类型，通过 T 泛型变量来确定 result 的类型。</p><p>然后声明了一个 异步函数 getResponse 并且将函数返回值的类型定义为 <code>Promise&lt;IResponse&lt;number[]&gt;&gt;</code> 。</p><p>最后调用 getResponse 方法会返回一个 promise 类型，通过 then 调用，此时 then 方法接收的第一个回调函数的参数 response 的类型为，<code>{ message: string, result: number[], success: boolean}</code>。</p><p>Promise<t> 实现源码 node_modules/typescript/lib/lib.es5.d.ts。</t></p><h2 id="工具与泛型的使用技巧"><a href="#工具与泛型的使用技巧" class="headerlink" title="工具与泛型的使用技巧"></a>工具与泛型的使用技巧</h2><p>ts 提供的一些实用的泛型。<br>实现源码 node_modules/typescript/lib/lib.es5.d.ts</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>一般我们都是先定义类型，再去赋值使用，但是使用 typeof 我们可以把使用顺序倒过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const options = &#123;</span><br><span class="line">  result: &#123;</span><br><span class="line">    abc:&quot;xxx&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">type Options = typeof options</span><br></pre></td></tr></table></figure><h3 id="使用字面量类型限制值为固定的参数"><a href="#使用字面量类型限制值为固定的参数" class="headerlink" title="使用字面量类型限制值为固定的参数"></a>使用字面量类型限制值为固定的参数</h3><p>如限制 props.pick 的值只可以是字符串 a、b、c ，不一定是字符串，当然也可以是数字 number。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  pick: &apos;a&apos; | &apos;b&apos; | &apos;c&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Partial-将所有的-props-属性都变为可选值"><a href="#使用-Partial-将所有的-props-属性都变为可选值" class="headerlink" title="使用 Partial 将所有的 props 属性都变为可选值"></a>使用 Partial 将所有的 props 属性都变为可选值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  pick: string;</span><br><span class="line">  mouu: string;</span><br><span class="line">  abc: number;</span><br><span class="line">&#125;</span><br><span class="line">let p:Partial&lt;IProps&gt;;</span><br><span class="line"></span><br><span class="line">等价于==&gt;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  pick?: string;</span><br><span class="line">  mouu?: string;</span><br><span class="line">  abc?: number;</span><br><span class="line">&#125;</span><br><span class="line">let p:IProps;</span><br></pre></td></tr></table></figure><p>源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;</span><br><span class="line"></span><br><span class="line">上面代码的意思是 keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P , 最后 T[P] 取得相应属性的值，中间的 ? 用来进行设置为可选值。</span><br></pre></td></tr></table></figure><h3 id="使用-Required-将所有-props-属性都设为必填项"><a href="#使用-Required-将所有-props-属性都设为必填项" class="headerlink" title="使用 Required 将所有 props 属性都设为必填项"></a>使用 Required 将所有 props 属性都设为必填项</h3><p>效果与 Partial 相反<br>源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span><br><span class="line"></span><br><span class="line">-? 的功能就是把可选属性的 ? 去掉使该属性变成必选项，对应的还有 +? ，作用与 -? 相反，是把属性变为可选项。</span><br></pre></td></tr></table></figure><h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><p>条件类型可以根据其他类型的特性做出类型的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends U ? X : Y</span><br></pre></td></tr></table></figure><p>如传入 T 与 U，当 T 中的内容在 U 中，那么就 true，返回 X，否则返回 U。</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 之前条件的判断方法</span><br><span class="line">interface Id &#123; id: number&#125;</span><br><span class="line">interface Name &#123; name: string &#125;</span><br><span class="line">declare function createLabel(id: number): Id;</span><br><span class="line">declare function createLabel(name: string): Name;</span><br><span class="line">declare function createLabel(name: string | number): Id | Name;</span><br><span class="line"></span><br><span class="line">// 使用条件类型</span><br><span class="line">type IdOrName&lt;T extends number | string&gt; = T extends number ? Id : Name;</span><br><span class="line">declare function createLabel&lt;T extends number | string&gt;(idOrName: T): T extends number ? Id : Name;</span><br></pre></td></tr></table></figure><p>它是包含关系，如果包含怎么处理，不包含怎么处理，一般如下使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type aa = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;;</span><br><span class="line">type bb = &quot;a&quot; | &quot;c&quot; | &quot;f&quot;;</span><br><span class="line"></span><br><span class="line">type Inter&lt;T,U&gt; = T extends U ? T : never;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let ceshi:Inter&lt;bb,aa&gt;;</span><br><span class="line">等价于===</span><br><span class="line">let ceshi:&quot;b&quot; | &quot;d&quot;;</span><br></pre></td></tr></table></figure><ol><li>Exclude&lt;T,U&gt;<br>从 T 中排除那些可以赋值给 U 的类型。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type T = Exclude&lt;1|2|3|4|5, 3|4&gt;  // T = 1|2|5</span><br></pre></td></tr></table></figure><ol start="2"><li>Extract&lt;T,U&gt;<br>从 T 中提取那些可以赋值给 U 的类型。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type T = Extract&lt;1|2|3|4|5, 3|4&gt;  // T = 3|4</span><br></pre></td></tr></table></figure><ol start="3"><li>Pick&lt;T,K&gt;<br>从 T 中取出一系列 K 的属性。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  sex: string;</span><br><span class="line">&#125;</span><br><span class="line">let person: Pick&lt;Person, &apos;name&apos; | &apos;age&apos;&gt; = &#123;  // &#123;name: string;age: number;&#125;</span><br><span class="line">  name: &apos;小王&apos;,</span><br><span class="line">  age: 21,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Record&lt;K,T&gt;<br>将 K 中所有的属性的值转化为 T 类型。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let person: Record&lt;&apos;name&apos; | &apos;age&apos;, string&gt; = &#123; // &#123;name: string;age: string;&#125;</span><br><span class="line">  name: &apos;小王&apos;,</span><br><span class="line">  age: &apos;12&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Omit&lt;T,K&gt;<br>从对象 T 中排除 key 是 K 的属性。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> interface Person &#123;</span><br><span class="line"> name: string,</span><br><span class="line"> age: number,</span><br><span class="line"> sex: string,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 排除 name 属性。</span><br><span class="line">let person: Omit&lt;Person, &apos;name&apos;&gt; = &#123;</span><br><span class="line"> age: 1,</span><br><span class="line"> sex: &apos;男&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>NonNullable <t><br>排除 T 为 null 、undefined。</t></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type T = NonNullable&lt;string | string[] | null | undefined&gt;; // string | string[]</span><br></pre></td></tr></table></figure><ol start="7"><li>ReturnType<t><br>获取函数 T 返回值的类型。</t></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</span><br><span class="line"></span><br><span class="line">// infer R 相当于声明一个变量，接收传入函数的返回值类型。</span><br><span class="line"></span><br><span class="line">type T1 = ReturnType&lt;() =&gt; string&gt;; // string</span><br><span class="line">type T2 = ReturnType&lt;(s: string) =&gt; void&gt;; // void</span><br></pre></td></tr></table></figure><p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">ts 官网</a></p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>由于使用了高阶组件是把原来的组件包一层然后返回，但对于使用了 typescript 后传入到组件里的值经过包的那一层是没有组件的传入值的定义的，所以会报错，<br>那么我们就要对其进行处理。<br>这里我们使用泛型：P 表示传递到 HOC 的组件的 props。React.ComponentType</p><p> 是 React.FunctionComponent</p><p> | React.ClassComponent</p><p>的别名，表示传递到 HOC 的组件可以是类组件或者是函数组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export const useInfo = &lt;P extends object&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P&gt;</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  // ...TODO</span><br><span class="line">  const useTest: React.SFC&lt;P &amp; &#123;&#125;&gt; = props =&gt; &#123;</span><br><span class="line">    // ...TODO</span><br><span class="line">    return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return useTest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;TypeScript 是 JS 类型的超集，并支持了泛型、类型、命名空间、枚举等特性，弥补了 JS 在大型应用开发中的不足。&lt;br&gt;使用 T</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>使用gulp制作组件化工具</title>
    <link href="https://793338023.github.io/2019/07/10/%E4%BD%BF%E7%94%A8gulp%E5%88%B6%E4%BD%9C%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <id>https://793338023.github.io/2019/07/10/%E4%BD%BF%E7%94%A8gulp%E5%88%B6%E4%BD%9C%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B7%A5%E5%85%B7/</id>
    <published>2019-07-10T14:22:57.000Z</published>
    <updated>2019-08-28T15:14:28.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在组件化是流行的一种方式，但一般我们都是只是制作适用于当前项目的组件，如使用 react、vue、angular 等前端架构项目，然后把当前复用性比较高的功能抽取出来封装成组件，然后组件有可能是可以使用到另外一个类似项目中去，但目前我们抽取的组件只是限制于在当前项目中，别的项目是没有办法引用这个组件的，那么另外的项目就要重新开发这部分的组件，那么就会做了重复工作了，而且以后同步更新也要修改两套代码，而这时把组件打包放到 npm 上就是可以解决这个重复工作，因为组件的维护都在组件化的项目包里，项目只要使用就行了。</p><h2 id="webpack、rollup-与-gulp-选择"><a href="#webpack、rollup-与-gulp-选择" class="headerlink" title="webpack、rollup 与 gulp 选择"></a>webpack、rollup 与 gulp 选择</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>WebPack 是一种模块化的解决方案。<br>Webpack 的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为浏览器可识别的 JavaScript 文件，但没有抽离公共 js 的情况下都打包到一个 js 文件，但为了更加完美兼容，打包文件里添加了很多代码使文件的可读性很差。</p><p>webpack 兼容性等完善，在应用上开发很适合。</p><h3 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h3><p>rollup 的功能与 webpack 类似，rollup 相对 webpack 而言，要小巧、代码干净利落一些，但不具备 webpack 的一些强大的功能，如热更新，代码分割，公共依赖提取等。<br>而 vue、react 等使用它进行打包，但它的插件、loader 之类比较少，使用的人也比较少，遇到问题难以从网上寻到答案。</p><p>在熟悉它的情况开发类库是不错的选择。</p><h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><p>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），除非使用插件实现合并操作，而我们可以通过给 gulp 配置不同的 task（通过 Gulp 中的 gulp.task()方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程，而 gulp 的 API 简单且少，学习成本很低，基本可以说会使用 node 就可以了。</p><p>而 gulp 不会根据文件的引入别的文件而把引入文件也打包了，它只会根据当前文件打包，而代码合并之类的都需要自己实现 task 来实现。<br>所以在打包多文件时会简单很多且自由度高，因为 gulp 以文件流的形式输入输出，可以对此进行一些操作来实现添加一些逻辑达到某些需要的目标，而 webpack 在这方面就复杂很多，需要自己实现插件来完成某些特殊要求。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>目前标准:</p><ol><li>打包出干净的代码，可读性号</li><li>根据组件打包出多个组件文件夹与多个组件文件，包含 ts 文件</li><li>可以被 babel-plugin-import 或 ts-import-plugin 实现组件的按需引入</li><li>样式文件抽离</li><li>打包后的为 es 与 lib 模块</li><li>第三方包排除打包</li></ol><p>实现起来简单且符合以上条件，webpack 不符合，rollup 勉强符合，但实现多文件与排除第三方等需要多次执行 rollup 配置，遍历的执行，重复执行很多没有必要的重复内容等等，gulp 对多文件打包友好，且可操作流程内容。</p><p>gulp 适合，当然也可以别的,如 typescript 或 babel 的命令行工具之类的，但这样如果需要操作文件里的一些信息还要自己写 node 实现一些额外的功能，如遍历目录、过滤、写入某些内容之类等等。</p><p>如 babel:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli</span><br><span class="line">// 编译整个 src 目录下的文件并输出到 lib 目录</span><br><span class="line">npx babel src --out-dir lib</span><br></pre></td></tr></table></figure><p><a href="https://www.babeljs.cn/docs/babel-cli" target="_blank" rel="noopener">babel 命令行工具资料</a><br>以下的以 gulp 为准。</p><h2 id="gulp-实现打包"><a href="#gulp-实现打包" class="headerlink" title="gulp 实现打包"></a>gulp 实现打包</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">|-- gulp打包文件目录</span><br><span class="line">    |-- package.json</span><br><span class="line">    |-- bin                 // 安装后可执行的命令文件夹</span><br><span class="line">    |   |-- rzzc-tool-run.js</span><br><span class="line">    |   |-- rzzc-tool.js</span><br><span class="line">    |-- demo               // 例子文件夹</span><br><span class="line">    |   |-- components</span><br><span class="line">    |       |-- index.tsx</span><br><span class="line">    |       |-- an-test</span><br><span class="line">    |       |   |-- index.tsx</span><br><span class="line">    |       |   |-- style</span><br><span class="line">    |       |       |-- index.scss</span><br><span class="line">    |       |       |-- index.tsx</span><br><span class="line">    |       |-- style</span><br><span class="line">    |       |   |-- index.scss</span><br><span class="line">    |       |   |-- index.tsx</span><br><span class="line">    |       |-- t-ainamte</span><br><span class="line">    |           |-- index.tsx</span><br><span class="line">    |           |-- tAnimateUtil.tsx</span><br><span class="line">    |           |-- img</span><br><span class="line">    |           |   |-- 123.jpg</span><br><span class="line">    |           |-- style</span><br><span class="line">    |               |-- index.scss</span><br><span class="line">    |               |-- index.tsx</span><br><span class="line">    |-- gulpConfig           // gulp 配置文件夹</span><br><span class="line">        |-- babel.js</span><br><span class="line">        |-- gulpfile.js</span><br><span class="line">        |-- postcssConfig.js</span><br><span class="line">        |-- utils.js</span><br></pre></td></tr></table></figure><h3 id="使用到的插件"><a href="#使用到的插件" class="headerlink" title="使用到的插件"></a>使用到的插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br><span class="line"></span><br><span class="line">// typescript转换es6</span><br><span class="line">gulp-typescript</span><br><span class="line">typescript</span><br><span class="line"></span><br><span class="line">// es6 转换成符合浏览器执行版本的js，如es5</span><br><span class="line">gulp-babel</span><br><span class="line">@babel/core</span><br><span class="line">@babel/plugin-proposal-class-properties // class类属性转换</span><br><span class="line">@babel/plugin-proposal-decorators  // 装饰器转换</span><br><span class="line">@babel/plugin-transform-runtime</span><br><span class="line">@babel/preset-env</span><br><span class="line">@babel/preset-react // react转换</span><br><span class="line"></span><br><span class="line">// sass转换css</span><br><span class="line">gulp-sass</span><br><span class="line">node-sass</span><br><span class="line">// css3兼容性处理</span><br><span class="line">gulp-postcss</span><br><span class="line">rucksack-css</span><br><span class="line">autoprefixer</span><br><span class="line"></span><br><span class="line">// react与react-dom的typescript类型</span><br><span class="line">@types/react</span><br><span class="line">@types/react-dom</span><br><span class="line"></span><br><span class="line">// 其他</span><br><span class="line">merge2 // 合并gulp任务，按顺序执行</span><br><span class="line">rimraf // 删除文件或文件夹</span><br><span class="line">through2 // 流输出的封装处理</span><br><span class="line">colorful // 颜色</span><br><span class="line">commander // 自定义指令</span><br></pre></td></tr></table></figure><h3 id="gulp-配置文件目录分析"><a href="#gulp-配置文件目录分析" class="headerlink" title="gulp 配置文件目录分析"></a>gulp 配置文件目录分析</h3><ol><li>babel.js 相当于 .babelrc 文件</li><li>postcssConfig.js css 的转换处理文件</li><li>utils.js 工具文件，如获取执行路径之类</li><li>gulpfile.js gulp 的配置文件</li></ol><p>require.resolve 输入的 path 会以 node_modules 里为起点查询，然后输出绝对路径，不存在会报错。</p><p>process.cwd() 当前执行 node 的路径</p><p>through2 函数接受的三个参数 file-文件流, encoding-字符编码, next-触发执行下一步流程<br>文件内容在 file.content 里，对 file.content 转换字符编码就可以正常操作，如 file.content.toString(encoding)<br>操作完后使用 Buffer.from 转换为二进制内容，既文件流格式</p><h3 id="按需加载与组件文件夹"><a href="#按需加载与组件文件夹" class="headerlink" title="按需加载与组件文件夹"></a>按需加载与组件文件夹</h3><p>typescript 按需加载: ts-import-plugin<br>babel 按需加载: babel-plugin-import<br>由于使用的是 antd 的配套按需加载插件，那么一般按一定的目录结构开发才能很好的便利使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">an-test</span><br><span class="line">    |-- index.tsx // 组件入口</span><br><span class="line">    |-- style     // 组件样式文件夹</span><br><span class="line">    |-- index.scss// 组件样式</span><br><span class="line">    |-- index.tsx // 按需加载时加载的样式文件引用</span><br></pre></td></tr></table></figure><p>以上的结构是最好兼容开发的，但也可以自定义,只是只能自定义 css。</p><p>自定义按需加载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    libraryName: &apos;antd&apos;,</span><br><span class="line">    libraryDirectory: &apos;es&apos;,</span><br><span class="line">    style: importPath=&gt;&#123;</span><br><span class="line">        return importPath+&quot;/style.css&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">importPath  组件问价夹路径</span><br><span class="line">拼接上组件css路径</span><br></pre></td></tr></table></figure><h2 id="配置打包目录与清除目录"><a href="#配置打包目录与清除目录" class="headerlink" title="配置打包目录与清除目录"></a>配置打包目录与清除目录</h2><p>在 package.json 中自定义一个 customParams 字段;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;customParams&quot;: &#123;</span><br><span class="line">    &quot;scanRoot&quot;: &quot;demo/components&quot;,</span><br><span class="line">    &quot;typeRoot&quot;: &quot;demo/typings&quot;,</span><br><span class="line">    &quot;clean&quot;: [</span><br><span class="line">      &quot;es&quot;,</span><br><span class="line">      &quot;lib&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据 scanRoot 与 typeRoot 把组件打包到 es 与 lib<br>根据 clean 清除目标目录</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>在 package.json 的 bin 里定义自定义指令名称与入口文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;rzzc-tool&quot;: &quot;./bin/rzzc-tool.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用 commander 在代码里执行 node 的命令，如 cli 脚手架之类的指令。</p><p>首先定义解析语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">只能文件顶部加才能生效</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  .version(packageInfo.version)</span><br><span class="line">  .command(&apos;run [name]&apos;, &apos;run specified task&apos;)</span><br><span class="line">  .parse(process.argv);</span><br></pre></td></tr></table></figure><p>执行子命令，会找到当前文件名加上 run,如 rzzc-tool.js，那么子命令文件就是 rzzc-tool-run.js,然后执行它。<br>[name] 为参数,这里为 gulp 执行任务的名称，可以从 program.args 中获取。<br>加载 gulp 配置文件，然后使用 gulp.task(name)返回值再调用就会执行当前任务。<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const c=gulp.task(&apos;clean&apos;);</span><br><span class="line">c(); // 就执行清除任务</span><br></pre></td></tr></table></figure><h2 id="npm-发布"><a href="#npm-发布" class="headerlink" title="npm 发布"></a>npm 发布</h2><ol><li>登陆账号</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login # 输入用户名 密码</span><br></pre></td></tr></table></figure><ol start="2"><li>publish</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish # 需要确保 package.json version 与上一个版本不一样</span><br></pre></td></tr></table></figure><p>版本的更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 小版本更改 如从1.0.1-&gt;1.0.2</span><br><span class="line">npm version patch</span><br><span class="line">// 中版本更改 如从1.0.1-&gt;1.1.0</span><br><span class="line">npm version minor</span><br><span class="line">// 大版本更改 如从1.0.1-&gt;2.0.1</span><br><span class="line">npm version major</span><br></pre></td></tr></table></figure><p>注:<br>可以 npm 下载下来配置环境然后打包，也可以 github 下载下来 webpack 与 gulp 配合打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm install --save-dev rzzc-tool</span><br></pre></td></tr></table></figure><p><a href="https://github.com/793338023/npm-rzzc-tool" target="_blank" rel="noopener">具体代码查看 github</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在组件化是流行的一种方式，但一般我们都是只是制作适用于当前项目的组件，如使用 react、vue、angular 等前端架构项目，然后把当</summary>
      
    
    
    
    
    <category term="gulp" scheme="https://793338023.github.io/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>linux001</title>
    <link href="https://793338023.github.io/2019/06/29/linux001/"/>
    <id>https://793338023.github.io/2019/06/29/linux001/</id>
    <published>2019-06-29T07:29:33.000Z</published>
    <updated>2019-07-03T15:46:19.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="linux的软件使用"><a href="#linux的软件使用" class="headerlink" title="linux的软件使用"></a>linux的软件使用</h2><p>安装VMware,配置虚拟机，加载镜像，使用NAT网络链接，安装VMTOOls，这样就是使用共享文件夹。<br>远程登陆，安装xshell与xftp，xshell操作命令，xftp传输文件，使用sftp。<br>sshd:守护进程，端口号为22<br>一般ftp与远程登陆xshell都使用sshd的端口号22<br>如果出现登陆不了远程的linux，可以查看一下sshd是否开启，命令setup，网络服务<br>查看ip地址ifconfig</p><h2 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h2><p>所有的linux系统都会内建vi文本编辑器。<br>vim具有程序编辑能力，是vi的增强版，对程序编辑友好，可以代码补全等功能。</p><p>三个模式:<br>1) 正常模式<br>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』 按键来移动光标，你可以使用『删除字符』 或『删除整行』 来处理档案内容，也可以使用『复制、贴上』 来处理你的文件数据。</p><p>2) 插入模式<br>按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可。</p><p>3) 命令行模式<br>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！</p><p>使用vim进入一般为正常模式，然后按下i等进入插入模式，退出插入模式就是命令行模式。</p><p>常用操作:<br>1)vim 进入或创建文件，按下i进入编辑模式，编辑完，按ESC退出编辑模式，按下:wq保存修改，:q 在没有修改情况退出正常模式，:q! 强制退出。<br>2) 正常模式,拷贝当前行 yy , 拷贝当前行向下的5行 5yy，并粘贴 p。<br>3) 正常模式,删除当前行 dd , 删除当前行向下的5行 5dd<br>4) 正常模式,在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]<br>5) 正常模式,设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]<br>6) 正常模式,使用快捷键到底文档的最末行[G]和最首行[gg]<br>7) 插入模式，在一个文件中输入 “hello” ,然后正常模式撤销这个动作 u<br>8) 正常模式,并将光标移动到 20行 shift+g</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;linux的软件使用&quot;&gt;&lt;a href=&quot;#linux的软件使用&quot; class=&quot;headerlink&quot; title=&quot;linux</summary>
      
    
    
    
    
    <category term="linux" scheme="https://793338023.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IOS对FormData、File兼容性</title>
    <link href="https://793338023.github.io/2019/06/05/IOS%E5%AF%B9FormData%E3%80%81File%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <id>https://793338023.github.io/2019/06/05/IOS%E5%AF%B9FormData%E3%80%81File%E5%85%BC%E5%AE%B9%E6%80%A7/</id>
    <published>2019-06-05T15:09:32.000Z</published>
    <updated>2019-06-07T12:12:24.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IOS对FormData、File兼容性都不是很好，比如IOS8、9就不支持，但按市场的占比来说，可以忽略这部分，但能处理还是要处理的。</p><h2 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h2><p>FormData主要是模拟表单数据，以便用XMLHttpRequest来发送数据，而FormData下有几个方法调用，如添加数据，设置数据，获取数据等，但它们有很一部分在IOS上是不兼容的，而append()这个方法一定是兼容的，其他API如果要使用就要留意他们的兼容性，如has、get都是不兼容的。</p><p>FormData添加进入的值不是blob、File，就会转换为String类型。</p><p>append第三个参数为文件名,不送第三个参数即为默认blob。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var content = &apos;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&apos;; // 新文件的正文...</span><br><span class="line">var blob = new Blob([content], &#123; type: &quot;text/xml&quot;&#125;);</span><br><span class="line"></span><br><span class="line">formData.append(&quot;webmasterfile&quot;, blob);</span><br></pre></td></tr></table></figure><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>IOS8、9度无法兼容File,虽然这个版本的IOS用户已经很少了，但能兼容还是兼容一下。</p><p>一个Blob对象表示一个不可变的, 原始数据的类似文件对象。<br>File接口基于Blob，继承 blob功能并将其扩展为支持用户系统上的文件。<br>所以我们可以使用Blob替代File对象，只要在lastModifiedDate与name就和File对象差不多了，而且可以使用FileReader读取数据，因此在某些场景下是可以替换的。<br>而且上传到后台的时Blob与File是一样的，因为File继承于Blob。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function blobToFile(blob, fileName)&#123;</span><br><span class="line">        blob.lastModifiedDate =new Date();</span><br><span class="line">        blob.name = fileName;</span><br><span class="line">        return blob;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;IOS对FormData、File兼容性都不是很好，比如IOS8、9就不支持，但按市场的占比来说，可以忽略这部分，但能处理还是要处理的。&lt;/</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>移动端调试</title>
    <link href="https://793338023.github.io/2019/06/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <id>https://793338023.github.io/2019/06/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/</id>
    <published>2019-06-01T03:28:05.000Z</published>
    <updated>2020-09-19T07:57:20.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大前端时代，移动互联网是大趋势，而偏向移动开发，但前端开发的功能在移动上调试是比较困难的，因为无法像 PC 浏览器那样有各种各样的内置调试工具，而出现问题时只从页面上效果判断具体问题，这是不太可能的，如样式，在 IOS 和安卓上展示的效果不一致，而在开发浏览器上一点问题都没有，这就只能猜测和不断尝试，但如果对需要部署的环境且频繁拜托别人部署是很浪费时间，效率也低下，还要看别人是否愿意陪你折腾，因为你也在浪费他的时间，因此能自己一个人解决就绝对不要浪费别人的时间，而对移动开发的调试，我一般都是 vConsole、weinre、fiddler。</p><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p>主要使用在需要打印 console 的内容而能像 pc 浏览器一样有控制台，当然它也有其他的功能，但对我而言 Log 是最重要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install vconsole</span><br><span class="line">import VConsole from &apos;vconsole/dist/vconsole.min.js&apos; //import vconsole</span><br><span class="line">let vConsole = new VConsole() // 初始化</span><br><span class="line"></span><br><span class="line">console.log(&apos;test.....&apos;);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="v1.PNG" alt="vConsole" title="">                </div>                <div class="image-caption">vConsole</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="v2.PNG" alt="vConsole" title="">                </div>                <div class="image-caption">vConsole</div>            </figure><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p>weinre 是一款还不错的远程调试工具。功能与网页浏览器的开发者工具基本类似，适合用于移动端 web 的调试，但可能会用起来不顺手，因为它只是实现了浏览器调式的一部分功能，而且它的调式界面有点简陋，功能运用上没有浏览器调试那么便捷，但它比 VConsole 功能强大一些，也包含了它的功能。<br>而它最好的地方在于可以在 Elements 对样式的修改可以动态的修改到远端的样式，这就和在浏览器上调式样式一样，很不错的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm -g install weinre</span><br><span class="line">weinre --httpPort 8081 --boundHost -all-</span><br><span class="line"></span><br><span class="line">主要参数解析：</span><br><span class="line">httpPort调试服务器运行的端口，默认8080</span><br><span class="line">boundHost调试服务器绑定的IP地址或域名，默认localhost</span><br></pre></td></tr></table></figure><p>运行后打开 localhost:8081 调式界面<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="w1.PNG" alt="weinre" title="">                </div>                <div class="image-caption">weinre</div>            </figure></p><p>Elements 的 tab 页里可以对元素进行样式调整，而选中样式也会在移动出现被选中的效果，如果没有重新刷新一下，因为它实现与远端同步是使用轮询方式实现的，如果请求有问题了，只能重新来，就是刷新，这一点我觉得体验效果很差。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="w2.PNG" alt="weinre" title="">                </div>                <div class="image-caption">weinre</div>            </figure><h2 id="fiddler"><a href="#fiddler" class="headerlink" title="fiddler"></a>fiddler</h2><p>Fiddler 是强大的抓包工具，它的原理是以 web 代理服务器的形式进行工作的。<br>而且 Fiddler 的用途很广，但这里就介绍一下怎么进行移动端的调式。<br>Fiddler 它的简单原理就是拦截请求，伪造请求返回给客户端。</p><h3 id="远程抓取手机数据配置"><a href="#远程抓取手机数据配置" class="headerlink" title="远程抓取手机数据配置"></a>远程抓取手机数据配置</h3><ol><li>配置 fiddler 允许监听到 https（fiddler 默认只抓取 http 格式的）<br>打开 Fiddler 菜单项 Tools-&gt;Options-&gt;HTTPS<br>勾选 CaptureHTTPS CONNECTs,勾选 Decrypt HTTPS traffic 和 Ignore servercertificate errors 两项,点击 OK（首次点击会弹出是否信任 fiddler 证书和安全提示，直接点击 yes 就行）</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="f1.PNG" alt="fiddler" title="">                </div>                <div class="image-caption">fiddler</div>            </figure><ol start="2"><li>配置 fiddler 允许远程连接</li></ol><p>Tools-&gt;Options-&gt;Connections，勾选 allow remote computers to connect，默认监听端口为 8888（下图 Fiddler listens on port 就是端口号），若端口被占用可以设置成其他的，配置好后要重新启动 fiddler</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="f2.PNG" alt="fiddler" title="">                </div>                <div class="image-caption">fiddler</div>            </figure><ol start="3"><li>对手机端进行参数配置</li></ol><p>首先要保证手机和电脑都处于同一个 WIFI 网络；</p><p>然后要知道电脑的 ip 地址（当然这个电脑是安装 fiddler 的电脑），电脑 ip 地址可通过 cmd，输入 ipconfig 查询，或网络共享中 ipv4 找到，我的是 192.168.0.103。</p><p>再者要知道 fiddler 的端口号，Tools-&gt;Options-&gt;Connections，port 中值就是端口号，一般默认为 8888；接下来开始操作手机；</p><p>手机打开浏览器输入 <a href="http://ip:端口号，如http://192.168.0.103:8888，会打开https证书下载地址，点击FiddlerRootcertificate下载证书。" target="_blank" rel="noopener">http://ip:端口号，如http://192.168.0.103:8888，会打开https证书下载地址，点击FiddlerRootcertificate下载证书。</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="f3.png" alt="fiddler" title="">                </div>                <div class="image-caption">fiddler</div>            </figure><p>找到手机上证书安装设置，记住证书下载地址，然后在证书安装设置找到证书安装,由于手机不一样，证书安装设置也不一样，需要自己百度自己的手机证书怎么安装。<br><a href="https://blog.csdn.net/qq_39720249/article/details/81069929" target="_blank" rel="noopener">具体参考</a></p><ol start="4"><li>更改手机无线网的代理<br>在手机的 WiFi 那里的高级设置，代理选择手动，主机名就是 fiddler 的电脑 ip 地址，端口号，就是 fiddler 的端口号，与浏览器中 ip：端口号保持一致，点击确定即可。</li></ol><p>这个无线代理设置也是手机不一样设置也有些不一样，需要自己百度查看自己的手机类型怎么设置。</p><p><a href="https://www.jb51.net/article/136052.htm" target="_blank" rel="noopener">具体参考</a></p><h3 id="fiddler-使用"><a href="#fiddler-使用" class="headerlink" title="fiddler 使用"></a>fiddler 使用</h3><p>目前经常使用的 Inspectors 与 AutoResponse。</p><p>Inspectors 可以查看到请求中所有报文数据，如 header，报文体，返回数据，而且可以查看不同数据类型的数据，如 json，图片等</p><p>AutoResponse 可以拦截转发预期的请求然后返回客户端，这是一个很强大的功能。<br>要勾选上 Enable rules 与 Unmatched requests passthrough<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="f4.PNG" alt="fiddler" title="">                </div>                <div class="image-caption">fiddler</div>            </figure></p><p>这样我们可以把请求转发到本地的某个文件，然后实现类似如 mock 数据那样，但不对代码进行调正，只是把请求转发，而我们就可以修改本地的数据，实现到请求数据为我们修改的预期数据，如样式修改，我们把样式文件的请求转发的本地目标样式文件，然后修改本地样式文件就可以刷新查看到重新请求的样式可进行了调整。</p><p>如果拦截不生效，是缓存问题或者配置问题，所以要注意。</p><p>正则匹配可以使用$1\$2…等选中匹配中的第几个子串，这和正则一样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="f5.PNG" alt="fiddler" title="">                </div>                <div class="image-caption">fiddler</div>            </figure><br>资料:<br><a href="https://www.cnblogs.com/frostbelt/archive/2012/08/24/2654658.html" target="_blank" rel="noopener">Fiddler AutoResponse</a><br><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6601363.html" target="_blank" rel="noopener">AutoResponder 正则匹配</a><br><a href="https://blog.csdn.net/chniccs/article/details/79640498" target="_blank" rel="noopener">fiddler 正则匹配 2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大前端时代，移动互联网是大趋势，而偏向移动开发，但前端开发的功能在移动上调试是比较困难的，因为无法像 PC 浏览器那样有各种各样的内置调试工</summary>
      
    
    
    
    
    <category term="调试" scheme="https://793338023.github.io/tags/调试/"/>
    
  </entry>
  
  <entry>
    <title>认识TCP</title>
    <link href="https://793338023.github.io/2019/05/14/%E8%AE%A4%E8%AF%86TCP/"/>
    <id>https://793338023.github.io/2019/05/14/%E8%AE%A4%E8%AF%86TCP/</id>
    <published>2019-05-14T14:27:39.000Z</published>
    <updated>2020-09-19T07:58:05.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用过 webSocket 的，应该都知道它是使用 TCP 来实现客户端与服务端双工通道，而且连接方式是 ip+端开口号，这为端到端的模式，而由于它的确认方式与断开方式多次确认避免了错误重发导致的错误连接之类的且各种方式保证了它的可靠的交付能力，而 UDP 在这方面就差了些，是不可靠的交付，它只负责发送，不负责确认，所以省去了很多的确认开销，可以很大的提高传送的速度，提高性能，对要求高性能的服务，一般都会使用到 UDP，所以两者有得有失，看需求的倾向。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="三次握手.png" alt="三次握手" title="">                </div>                <div class="image-caption">三次握手</div>            </figure><p>第一次握手，建立连接，客户端会把 SYN 发给服务器，进入 SYN_SEND 状态，等待服务器确认，第二次握手，会确认 SYN 包信息，然后在接受信息上添加 SYN+ACK 报文段，发送给客户端，进入 SYN_RECV 状态，第三次握手，客户端接受到报文后向服务器发送 ACK 包，客户端和服务器端都进入 ESTABLISHED 状态。</p><p>TCP 进入三次握手是因为预防客户端与服务器端出现丢失包而双方的一方不知道而以为可以正常进入连接状态，这样会会出现 BUG 问题，就好比收快递，如果快递员只送到目的地而不告知或确认是否收到，那么快递丢失，收件员就无法收到快递而损失或不知道快递在哪，这个很不可靠的，而三次握手就会保证连接无误，因为第一次为请求连接，而服务器回应为确认连接，再到客户端的答复为已经收到确认连接，这样是不是就能明确三次握手的必要性。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="四次挥手.png" alt="四次挥手" title="">                </div>                <div class="image-caption">四次挥手</div>            </figure><p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。<br>6）服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p><p>四次挥手是因为客户端的关闭与服务器端关闭都要关闭，每个都有一个请求一个回应，所以就四次。<br>在服务器关闭时客户端的 TINE_WAIT 是为了确认服务器端是否接受客户端的应答，如若收到，那么服务器端就不会再发送关闭请求，那么客户端在 2<a href="https://baike.baidu.com/item/MSL/13975171?fr=aladdin" target="_blank" rel="noopener">MSL</a>时间后就自动认为服务器端关闭了，结束本次的 TCP 连接，如若收到再次请求关闭，那么就是重置时间再等待 2MSL 时间。</p><p>MSL 指一个片段在网络中最大的存活时间</p><p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="可靠交付的手段"><a href="#可靠交付的手段" class="headerlink" title="可靠交付的手段"></a><a href="https://www.jianshu.com/p/4fbb48c4285d" target="_blank" rel="noopener">可靠交付的手段</a></h2><p>TCP 是一种提供可靠性交付的协议。<br>也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>TCP 报文段在传输的过程中，下面的情况都是有可能发生的：</p><p>数据包中途丢失；<br>数据包顺利到达，但对方发送的 ACK 报文中途丢失；<br>数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；</p><p>当出现这些异常情况时，TCP 就会超时重传。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。<br>TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。<br>滑动窗口分为「接收窗口」和「发送窗口」<br>因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。</p><p>滑动窗口就是在存储有序的内容，当当前的某段内容都确认后就滑动到确认区域内，而某段内容之前有丢失的，那么后面的只能等待丢失的确认后才能有序滑到确认区域。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用过 webSocket 的，应该都知道它是使用 TCP 来实现客户端与服务端双工通道，而且连接方式是 ip+端开口号，这为端到端的模式，</summary>
      
    
    
    
    
    <category term="tcp" scheme="https://793338023.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>前端安全问题</title>
    <link href="https://793338023.github.io/2019/05/02/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://793338023.github.io/2019/05/02/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2019-05-02T14:25:13.000Z</published>
    <updated>2019-05-08T16:01:42.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着前端的发展，现在应用越来越庞大，而大前端的时代，也让前端独立起来，复杂起来，重要起来，而前端信息被盗用，很容易就出现严重的情况，比如信息泄露，资金损失等等，所以前端安全也是必不可少的。</p><h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h2><p>xss跨站脚本攻击，是目前也是一直最流行的攻击方式，而它主要对html或js注入恶意代码，被执行后向目标服务器发送内容或篡改内容，以达到攻击的效果。</p><p>xss攻击又分三种，DOM xss、反射型XSS、存储型XSS。<br>而他们的最终目的都是向html或js注入代码，所以只要防御好注入代码不被执行即可。</p><p>防御:</p><ol><li>前端在解析html时对外部来源的代码进行<a href="http://www.cnblogs.com/lovesong/p/5211667.html" target="_blank" rel="noopener">HtmlEncode</a>既实体字符转换，对js进行<a href="http://www.cnblogs.com/lovesong/p/5211667.html" target="_blank" rel="noopener">JavaScriptEncode</a>既特殊字符进行16进制转换，以达到外部来源的代码不能以代码自执行的方式被使用。</li><li>前后端通讯时后台也要对数据的特殊字符进行处理，以免回传到前端时被自动使用执行而入侵。</li><li>cookie信息安全，由于cookie在前端很容易被获取，而权限泄露，所以对cookie设置HttpOnly属性，让前端无法获取到cookie，从而无法泄露出去。</li></ol><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>iframe框架，一般都是为了让第三方的页面功能可以正常的嵌套在自己项目的页面里，以达到添加的功能，典型的例子是使用iframe在页面上添加第三方提供的广告、天气预报、社交分享插件等等。</p><p>防御:<br>html5对iframe提供了sandbox的安全属性，实现“最小权限“原则，这样就可以最大限制各方面的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe sandbox src=&quot;...&quot;&gt; ... &lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener">sandbox</a></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF跨站点请求伪造,冒充用户进行一些违背用户操作行为的事。<br>可能会造成以下影响：</p><ol><li>利用已通过认证的用户权限更新设定信息等；</li><li>利用已通过认证的用户权限购买商品；</li><li>利用已通过的用户权限在留言板上发表言论。</li></ol><p>CSRF就是劫持http上的登陆权限，然后冒充用户进行非法操作。</p><p>防御:</p><ol><li>验证码:强制用户进行交互行为，以达到在终端使用。</li><li>使用post方法传递参数，get方法参数在url上很容易被劫持。</li><li>Referer来源限制，这个方法有缺陷，比如Referer丢失之类的，所以有点没有保障，而且也有可能被伪造。</li><li>Token这是最优的解决方式，现在比较流行JWT。</li></ol><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>利用透明的按钮或连接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个连接访问内容的一种攻击手段。也叫界面伪装。<br>就是把目标页面放到iframe里，然后顶层为透明层，诱惑用户点击，触发透明层。</p><p>防御:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="noopener">X-FRAME-OPTIONS</a>；<br>X-FRAME-OPTIONS HTTP 响应头是用来给浏览器指示允许一个页面可否在\&lt;frame>, \&lt;iframe> 或者 \&lt;object> 中展现的标记。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。</p><h2 id="错误MIME-types被执行"><a href="#错误MIME-types被执行" class="headerlink" title="错误MIME types被执行"></a>错误MIME types被执行</h2><p>有些攻击会用上传文件之类的，然后在后台里储存，当被前端终端读取后，由于终端的智能手段，把把它转换为可执行的类型进行执行，想想就可怕，如某网站允许用户在评论里上传图片，攻击者在上传图片的时候，看似提交的是个图片文件，实则是个含有JavaScript的脚本文件。该文件逃过了文件类型校验（这涉及到了恶意文件上传这个常见安全问题，但是由于和前端相关度不高因此暂不详细介绍），在服务器里存储了下来。接下来，受害者在访问这段评论的时候，浏览器会去请求这个伪装成图片的JavaScript脚本，而此时如果浏览器错误的推断了这个响应的内容类型（MIME types），那么就会把这个图片文件当做JavaScript脚本执行，于是攻击也就成功了。</p><p>防御:<br>通过设置<a href="https://www.jianshu.com/p/0e28d54e927b" target="_blank" rel="noopener">X-Content-Type-Options</a>这个HTTP Header明确禁止浏览器去推断响应类型。</p><h2 id="不安全的第三方依赖包"><a href="#不安全的第三方依赖包" class="headerlink" title="不安全的第三方依赖包"></a>不安全的第三方依赖包</h2><p>现如今进行应用开发，就好比站在巨人的肩膀上写代码。据统计，一个应用有将近80%的代码其实是来自于第三方组件、依赖的类库等，而应用自身的代码其实只占了20%左右。无论是后端服务器应用还是前端应用开发，绝大多数时候我们都是在借助开发框架和各种类库进行快速开发。</p><p>比如vue的生态包就出现过被黑的情况，安装包时 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。</p><p>而依赖使用这些流行框架影响会很大。</p><p>防御:<br>只能实时留意网上信息的动态，与使用安全工具对其进行扫描，以防万一，因为三方库都是很多人使用的，有问题会第一时间提出并修改。</p><h2 id="HTTPS被拦截降级为HTTP"><a href="#HTTPS被拦截降级为HTTP" class="headerlink" title="HTTPS被拦截降级为HTTP"></a>HTTPS被拦截降级为HTTP</h2><p>HTTPS是在HTTP上加TLS安全传输层，TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL，它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。<br>但有TLS还是可能被攻击的，黑客可以利用SSL Stripping这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。</p><p>问题的本质在于浏览器发出去第一次请求就被攻击者拦截了下来并做了修改，根本不给浏览器和服务器进行HTTPS通信的机会。大致过程如下，用户在浏览器里输入URL的时候往往不是从https:\//开始的，而是直接从域名开始输入，随后浏览器向服务器发起HTTP通信，然而由于攻击者的存在，它把服务器端返回的跳转到HTTPS页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。由于这一切都是暗中进行的，所以使用前端应用的用户对此毫无察觉。</p><p>防御:<br>使用HSTS,它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strict-Transport-Security: max-age=&lt;seconds&gt;; includeSubDomains; preload</span><br></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/999492eb5b1a" target="_blank" rel="noopener">Strict-Transport-Security</a></p><h2 id="敏感信息、错误信息暴露"><a href="#敏感信息、错误信息暴露" class="headerlink" title="敏感信息、错误信息暴露"></a>敏感信息、错误信息暴露</h2><ol><li><p>由于程序员疏忽直接在页面的js以及AJAX请求返回的内容中输出参与评论用户的敏感信息，导致攻击者可以轻松获取用户的手机号，真实姓名，注册邮箱，住址甚至有可能获取用户手机的IMEI，和抽奖和抽中的游戏礼包号。泄露内容千奇百怪，遇到此类问题时，看着泄露的内容时常会被雷到。<br>而这些敏感信息很容易就会获取到客户信息。</p></li><li><p>由于后台的疏忽，经常会出现堆栈信息被打印到页面，而这也是很容易很推断某些信息，而进行他想的攻击。</p></li></ol><p>防御:</p><ol><li>使用不对称密钥进行加密。</li><li>过滤堆栈信息，打印友好话术信息。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着前端的发展，现在应用越来越庞大，而大前端的时代，也让前端独立起来，复杂起来，重要起来，而前端信息被盗用，很容易就出现严重的情况，比如信息</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>defineProperty与Proxy</title>
    <link href="https://793338023.github.io/2019/04/30/defineProperty%E4%B8%8EProxy/"/>
    <id>https://793338023.github.io/2019/04/30/defineProperty%E4%B8%8EProxy/</id>
    <published>2019-04-30T14:32:47.000Z</published>
    <updated>2019-04-30T15:55:07.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从vue的出现，让很多前端开发对defineProperty这个方法进入了深入的了解，因为它涉及到vue核心实现，视图与数据的双向绑定，然而vue3后又盯上了Proxy，它比defineProperty完美，很适合做双向绑定。</p><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">defineProperty</a></h2><p>ECMAS-262第5版在定义只有内部采用的特性时，提供了描述了属性特征的几种属性。ECMAScript对象中目前存在的属性描述符主要有两种，数据描述符(数据属性)和存取描述符(访问器属性)，数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。</p><p>defineProperty提供了对数据描述属性进行修改的操作，而这也提供更加灵活操作，与在getter-setter 函数功能进行某些搜集和变化，所以这也让双向绑定变得更加简单可控。</p><p>以下为数据双向绑定例子，但没有对视图与数据进行绑定，只是提供了一个思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">// 校验是否是对象</span><br><span class="line">function isObject(obj)&#123;</span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Object]&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环递归给每个对象的值设置defineProperty</span><br><span class="line">function defineReactive(obj, key, val)&#123;</span><br><span class="line">  if(isObject(val))&#123;</span><br><span class="line">    observe(val);</span><br><span class="line">  &#125;else if(Array.isArray(val))&#123;</span><br><span class="line">    observeArray(val);</span><br><span class="line">    dealAugment(val);</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      // 处理获取数据</span><br><span class="line">      console.log(`获取值:$&#123;val&#125;`);</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      // 处理设置数据</span><br><span class="line">      console.log(`设置值:newVal-$&#123;newVal&#125;，oldVal-$&#123;val&#125;`);</span><br><span class="line">      val = newVal;</span><br><span class="line">      if(isObject(newVal))&#123;</span><br><span class="line">        observe(newVal);</span><br><span class="line">      &#125;else if(Array.isArray(val))&#123;</span><br><span class="line">        observeArray(val);</span><br><span class="line">        dealAugment(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组变异方式实现</span><br><span class="line">function dealAugment(arr)&#123;</span><br><span class="line">  // 把数组的所有原型方法赋值给arrysMethod</span><br><span class="line">  const arrysMethod = Object.create(Array.prototype);</span><br><span class="line">  // 重构push，就是变异psuh方法，这里可以实现其他的变异，如pop、shift、unshift</span><br><span class="line">  arrysMethod.push = function(...args)&#123;</span><br><span class="line">    // 处理push方法数据</span><br><span class="line">    console.log(&quot;push:&quot;,args);</span><br><span class="line">    [].push.apply(arr, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 重新把原型赋值到数组里</span><br><span class="line">  if(&quot;__proto__&quot; in Object)&#123;</span><br><span class="line">    arr.__proto__ = arrysMethod;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    // 不支持__proto__，变异当前方法</span><br><span class="line">    Object.defineProperty(arr, &quot;push&quot;, &#123;</span><br><span class="line">      value: arrysMethod.push,</span><br><span class="line">      enumerable: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组部分遍历递归检测对象与数组，实现defineProperty与数组变异</span><br><span class="line">function observeArray(arr)&#123;</span><br><span class="line">  arr.forEach((item)=&gt;&#123;</span><br><span class="line">    if(isObject(item))&#123;</span><br><span class="line">      observe(item);</span><br><span class="line">    &#125;else if(Array.isArray(item))&#123;</span><br><span class="line">      observeArray(item);</span><br><span class="line">      dealAugment(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历对象，对象值设置defineProperty</span><br><span class="line">function observe(obj)&#123;</span><br><span class="line">  Object.keys(obj).forEach((key)=&gt;&#123;</span><br><span class="line">    defineReactive(obj, key, obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试部分</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  let obj = &#123;</span><br><span class="line">    a: &quot;1&quot;,</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: &quot;xxx&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    c: [12,1],</span><br><span class="line">    d: [[1212],[&quot;ccc&quot;],&quot;vvv&quot;,&#123;e:&quot;222&quot;&#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">  window.obj = obj;</span><br><span class="line">  observe(obj);</span><br><span class="line">  console.log(obj.a);</span><br><span class="line">  obj.a = &#123;v:1&#125;;</span><br><span class="line">  obj.b.c = &quot;wqss&quot;;</span><br><span class="line">  obj.c.push(10); </span><br><span class="line">  obj.c.push([1000]); </span><br><span class="line">  obj.d[0].push(&quot;vvv&quot;);</span><br><span class="line">  obj.d[3].e = &quot;xcsss&quot;;</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure></p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><a href="https://www.baidu.com/link?url=Nh6XK8y88XQFJkNwfQxQGfOGsE2liUu9DS8bsADKJuVkkEUhRL7Nx9znY78mCclmiFEPG9Jo2zQCkb7SFsTq1l9eD5_AoDjwK9En5jfCYKLxFY-9gTOt8xRhOxGLWUHh&amp;wd=&amp;eqid=fb296093000cee35000000065cc86efb" target="_blank" rel="noopener">Proxy</a></h2><p>Proxy比defineProperty完善，因为Proxy相当于实现了一个代理，让数据都经过代理里的设置后再输出，所以我们可以再代理里的钩子里拦截下数据，进行操作后进行下一步的数据变化，而且也不需要数组方法变异之类的，因为只要代理的数据有变化，就需要经过代理里的钩子，从而不需要编写一些hack代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 还有比这更简洁的递归吗</span><br><span class="line">      return new Proxy(target[prop], handler);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      return target[prop]; // 或者是Reflect.get</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set(target, prop, newVal) &#123;</span><br><span class="line">    const oldVal = target[prop];</span><br><span class="line">    if (oldVal !== newVal) &#123;</span><br><span class="line">      console.warn(oldVal, newVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target[prop] = newVal;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  b: true,</span><br><span class="line">  o: &#123; name: &apos;obj&apos; &#125;,</span><br><span class="line">  a: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],</span><br><span class="line">  odeep: &#123;</span><br><span class="line">    path: &#123;</span><br><span class="line">      name: &apos;obj deep&apos;,</span><br><span class="line">      value: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = new Proxy(obj, handler);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  // 试试吧，太不可思议了!</span><br><span class="line">  obj.b = false;</span><br><span class="line">  obj.o.name = &apos;newObj&apos;;</span><br><span class="line">  obj.odeep.path.name = &apos;newObj deep&apos;;</span><br><span class="line"></span><br><span class="line">  obj.b = &#123; name: &apos;obj created&apos; &#125;;</span><br><span class="line">  obj.b.name = &apos;newObj created&apos;;</span><br><span class="line"></span><br><span class="line">  obj.a.push(&apos;d&apos;);</span><br><span class="line">  obj.odeep.path.value.push(1);</span><br><span class="line"></span><br><span class="line">  obj.b = [&apos;a&apos;];</span><br><span class="line">  obj.b.push(&apos;b&apos;);</span><br><span class="line">  obj.b[0] = &apos;new a&apos;;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自从vue的出现，让很多前端开发对defineProperty这个方法进入了深入的了解，因为它涉及到vue核心实现，视图与数据的双向绑定，然</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>chrome调试查找问题根源</title>
    <link href="https://793338023.github.io/2019/04/27/chrome%E8%B0%83%E8%AF%95%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90/"/>
    <id>https://793338023.github.io/2019/04/27/chrome%E8%B0%83%E8%AF%95%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90/</id>
    <published>2019-04-27T14:56:14.000Z</published>
    <updated>2020-09-19T07:57:51.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一个开发者来说，开发只是工作里的一个部分，然而修复功能的 bug 才是考验一个开发人员能力的时候，因为写出没有 BUG 的代码是一件很困难的事，不是谁都可以把所有的情况都考虑进去，代码复杂式总会出现一些 BUG 问题，所以才会出现各种各样的日志系统，因为他可以让开发人员从日志内容中找到代码的 BUG 根源，当然也不一定能查到，但这只是调试的一种，而在前端里，日志系统是比较少用的，都是靠浏览器的调试来完成 BUG 查找，而常用的有 console 方式，就是打印内容来定位问题，但这种方式只能应付一般简单的场景，如知道问题在哪，需要进一步核查一下是什么问题之类的，但如果出现 console 量特别大的时候就会出现难以排查。<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    conosole.log(&quot;1111&quot;)</span><br><span class="line">&#125;</span><br><span class="line">for(var j=0;j&lt;10;j++)&#123;</span><br><span class="line">    conosole.log(&quot;1111&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cconsole 的地方为循环调用的，而且是交替的，那么就会意义很难懂。</p><p>而最好的调式的方式应该是可以查看调用栈，那么就可以追踪问题的行为，而判断 BUG 怎么修复。</p><h2 id="调试方式-console"><a href="#调试方式-console" class="headerlink" title="调试方式-console"></a>调试方式-console</h2><p>在一般知道问题所在的情况下是 console 可以简单的快速定位问题原因，而且 console 量大是可以分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 分组方式</span><br><span class="line">console.group()</span><br><span class="line">console.log(&quot;问题打印&quot;);</span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure><h2 id="调试方式-Sources"><a href="#调试方式-Sources" class="headerlink" title="调试方式-Sources"></a>调试方式-Sources</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="s.png" alt="chrome调试查找问题根源" title="">                </div>                <div class="image-caption">chrome调试查找问题根源</div>            </figure><p>打开 Sources 可以用来查看页面的源文件，里面包含了 debugger 调式，这是重点。<br>ctrl+p 查找目标文件，当然也可以使用 console 打印后找到目标文件,点击红圈就可以跳转到目标文件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="console.PNG" alt="console" title="">                </div>                <div class="image-caption">console</div>            </figure></p><p>而 debugger 后可以使用-&gt;来一步一步走完所有的调用，这样可以更仔细的查找到问题，当不知道问题具体在哪时。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="call.PNG" alt="调用栈" title="">                </div>                <div class="image-caption">调用栈</div>            </figure><p>Call Stack 是当前 debugger 过程的调用栈，可以使用它查看到之前的调用过程，从而推断问题，而且点击对应的调用可以跳转到对应的调用方法上，这样就会可以查看当前调用的信息，但旧的浏览器还不可查看那些调用信息，还有 watch 是把某些变量放入，方面之后 debugger 执行查看到当前监控变量的值变化，Scope 当前调用方法的作用域的变量值，BreakPoints 为所拥有的 debugger 数和具体的 debugger，可以在这里删除 debugger，因为有时不知道 debugger 在哪里打，那么在这里移除是最好的，当前还有其他几个，但暂时没有使用到。</p><h2 id="调式方式-error"><a href="#调式方式-error" class="headerlink" title="调式方式-error"></a>调式方式-error</h2><p>当控制台报错时，会有报错信息与调用栈信息，而一般报错信息只能判断是什么原因，不能定位问题所在，而这时不用调用栈时很被动的，因为只有报错信息与简单的文件报错位置，在复杂的场景下是不够定位问题的，而这时调用栈的信息就可以让我们推断出问题所在，因为他与以上的 debugger 的调用栈是一样的，所以可以追踪的到的调用行为，以推断出问题，以想出对应的解决方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="e.PNG" alt="调用栈" title="">                </div>                <div class="image-caption">调用栈</div>            </figure><p>调式方式有很多种，如请求问题，可以查看 network 等等，优化可以 Memory 等，这些都很好，但我觉得调用栈才是定位问题的最佳方式，因为如果你知道问题的行为，那么你就相当如知道具体的问题在哪里出现，就可以直接针对修复，而现在的日志系统也是趋向用户行为分析来定位具体的问题，所以知道行为就是知道具体问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于一个开发者来说，开发只是工作里的一个部分，然而修复功能的 bug 才是考验一个开发人员能力的时候，因为写出没有 BUG 的代码是一件很困</summary>
      
    
    
    
    
    <category term="调试" scheme="https://793338023.github.io/tags/调试/"/>
    
  </entry>
  
  <entry>
    <title>旧博客地址</title>
    <link href="https://793338023.github.io/2019/04/25/%E6%97%A7%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/"/>
    <id>https://793338023.github.io/2019/04/25/%E6%97%A7%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/</id>
    <published>2019-04-25T15:50:14.000Z</published>
    <updated>2019-04-25T15:54:35.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>由于方便问题，以后的博文都在这里编写，而编写博文是为了记录自己的技术成长与以后忘记有个地方可以查找，好记性不如烂笔头。</p><p>以前的博文是在博客园编写的<br>地址为<a href="https://www.cnblogs.com/zhangzhicheng" target="_blank" rel="noopener">https://www.cnblogs.com/zhangzhicheng</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h2&gt;&lt;p&gt;由于方便问题，以后的博文都在这里编写，而编写博文是为了记录自己的技术成长与以后忘记有个地方可以查找，好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;以前的</summary>
      
    
    
    
    
    <category term="blog" scheme="https://793338023.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>react的hooks</title>
    <link href="https://793338023.github.io/2019/04/21/react%E7%9A%84hooks/"/>
    <id>https://793338023.github.io/2019/04/21/react%E7%9A%84hooks/</id>
    <published>2019-04-21T05:44:37.000Z</published>
    <updated>2019-04-21T06:25:59.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然react一般都是class类的方式编写，但有时为了简单，就使用函数编写，但在以前这是无副作用的函数,所以很多事都无法去做，比如后期为了维护而不得不在函数里使用state等时，这就不会符合无副作用的函数了，所以react会报错，而这是使用hooks就可以拯救啦，当然也有喜欢使用函数式编写的人来说也是福音，因为hooks基本上支持所有react生命周期，state,redux等等，与编写class方式差不多等效了。</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>引入react里的useState。<br>useState的参数就像state初始化值。<br>useState返回的值一个数组，数组中第一个参数是以前的state,第二个参数是setState，由于是参数，所以可以自己命名，不用想以前就state,setState这样。</p><p>例子如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;</span><br><span class="line"></span><br><span class="line">export const getText = function(props)&#123;</span><br><span class="line">    const [test, setTest] = useState(&apos;&apos;);</span><br><span class="line">    function onChange(val)&#123;</span><br><span class="line">        setTest(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;List&gt;</span><br><span class="line">               &lt;InputItem value=&#123;test&#125; onChange=&#123;onChange&#125;&gt;hooks测试&lt;/InputItem&gt; </span><br><span class="line">            &lt;/List&gt;</span><br><span class="line">            &lt;List&gt;</span><br><span class="line">               &lt;div&gt;&#123;test&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/List&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h2><p>引入react里的Effect。<br>useEffect增加了从功能组件执行副作用的功能，其实这个钩子就是让函数支持react生命周期。<br>它的目的是作为componentDidMount，componentDidUpdate以及componentWillUnmount，只是都在这个useEffect钩子实现。</p><ol><li><p>useEffect的第二参数为空数组[],效果如componentDidMount:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const getText = function(props)&#123;</span><br><span class="line">    </span><br><span class="line">    // 调用父级组件函数更新state</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        props.setVal(Math.floor(Math.random()*100));</span><br><span class="line">    &#125;,[]);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;List&gt;</span><br><span class="line">               &lt;div&gt;&#123;props.value&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/List&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>useEffect的第二参数不传，效果如componentDidUpdate,但初始加载也会触发:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const getText = function(props)&#123;</span><br><span class="line">    </span><br><span class="line">    // 调用父级组件函数更新state</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        props.setVal(Math.floor(Math.random()*100));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;List&gt;</span><br><span class="line">               &lt;div&gt;&#123;props.value&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/List&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>useEffect里函数的返回值，效果如componentWillUnmount,在组件卸载调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const getText = function(props)&#123;</span><br><span class="line">    const timer = setInterval(()=&gt;&#123;</span><br><span class="line">        console.log(+new Date());</span><br><span class="line">    &#125;);</span><br><span class="line">    // 调用父级组件函数更新state</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        props.setVal(Math.floor(Math.random()*100));</span><br><span class="line">        return ()=&gt;&#123;</span><br><span class="line">            clearInterVal(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;List&gt;</span><br><span class="line">               &lt;div&gt;&#123;props.value&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/List&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>useEffect的第二参数数组有对应的state或props值，只要当前值更新了才触发:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const getText = function(props)&#123;</span><br><span class="line">    </span><br><span class="line">    // 调用父级组件函数更新state</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        props.setVal(Math.floor(Math.random()*100));</span><br><span class="line">    &#125;,[props.value]);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;List&gt;</span><br><span class="line">               &lt;div&gt;&#123;props.value&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/List&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义钩子"><a href="#自定义钩子" class="headerlink" title="自定义钩子"></a>自定义钩子</h2><p>就是抽取相同逻辑的部分封装成一个新的钩子，而钩子使用hooks的钩子封装实现，然后返回一个目标内容，如值。</p><p>自定义钩子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">export const getHook = function(vId,props)&#123;</span><br><span class="line">    const [ssId, setSsId] = useState(&apos;&apos;);</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        props.setVal(Math.floor(Math.random()*100));</span><br><span class="line">        setSsId(vId);</span><br><span class="line">    &#125;,[props.value]);</span><br><span class="line"></span><br><span class="line">    return ssId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用自定义钩子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;</span><br><span class="line">improt &#123;getHook&#125; from &apos;./hooks&apos;;</span><br><span class="line"></span><br><span class="line">export const getText = function(props)&#123;</span><br><span class="line">    const nVal = getHook(&quot;xx&quot;,props);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;List&gt;</span><br><span class="line">               &lt;div&gt;&#123;props.value&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/List&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><ol><li>只能在顶层调用Hooks。不要在循环，条件或嵌套函数中调用Hook。</li><li>只能在functional component中使用，所以如果在class使用一定要是组件的形式，而不是函数调用的方式，不是会当成一个在class里使用hooks。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>react官网有很详细的资料,而且以上的只是当用的，Hooks还提供了别的钩子。<br><a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">react官方Hooks</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;虽然react一般都是class类的方式编写，但有时为了简单，就使用函数编写，但在以前这是无副作用的函数,所以很多事都无法去做，比如后期为了</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>javascript类型与语句</title>
    <link href="https://793338023.github.io/2019/04/13/javascript%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%AF%AD%E5%8F%A5/"/>
    <id>https://793338023.github.io/2019/04/13/javascript%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%AF%AD%E5%8F%A5/</id>
    <published>2019-04-13T15:00:32.000Z</published>
    <updated>2019-04-27T14:50:39.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 是一门简单易用的语言，应用广泛，同时它的语言机制又十分复杂和微妙，即使经验丰富的开发人员也需要用心学习才能真正掌握。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>一般描述某某类型，是对变量的值的类型描述，而不是变量，变量是没有类型的</p><p>javascript有七种内置类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">空值（null）</span><br><span class="line">未定义（undefined）</span><br><span class="line">布尔值（boolean）</span><br><span class="line">数字（number）</span><br><span class="line">字符串（string）</span><br><span class="line">对象（object）</span><br><span class="line">符号（symbol， ES6 中新增）</span><br></pre></td></tr></table></figure></p><p>使用typeof 就可以查看到，但有意思的null是object,无法一一对应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined === &apos;undefined&apos;</span><br><span class="line">typeof true === &apos;boolean&apos;</span><br><span class="line">typeof 1 === &apos;number&apos;</span><br><span class="line">typeof &quot;41&quot; === &apos;string&apos;</span><br><span class="line">typeof &#123;&#125; === &apos;object&apos;</span><br><span class="line">typeof Symbol() === &apos;symbol&apos;</span><br><span class="line">typeof null === &apos;object&apos;</span><br></pre></td></tr></table></figure></p><p>除了object，其他都是基础类型，而使用instanceof对基础类型校验类型，都是object，除非使用String等包装对象，就可以正确的校验出对应的类型，而对象类型都可以instanceof校验，因为它校验的是construct指向类型。</p><h3 id="typeof、instanceof、Object-prototype-toString"><a href="#typeof、instanceof、Object-prototype-toString" class="headerlink" title="typeof、instanceof、Object.prototype.toString"></a>typeof、instanceof、Object.prototype.toString</h3><ol><li>typeof<br>一般使用来检查基本类型，当然也有一些意外，如null为object，这是规范的bug，但牵连过多，所以无法修复，还有function，由于内部的[[call]]原因，当typeof检查时会认为它是可调用对象，所以会返回function字符串，其他的对象统一都返回object，而宿主对象也不一样，但这个很少用，不过有一个很特别就是document.all返回undefined。</li></ol><p>对基础类型进行手动的包装对象，typeof只能认为它是对象类型，而且js引擎对这部分优化了，会自动包装，所以最好不要手动包装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof document.all === &apos;undefined&apos;</span><br><span class="line">typeof 宿主对象（由JS环境提供） === Implementation-dependent</span><br><span class="line">typeof null === &apos;object&apos;</span><br><span class="line">typeof new String(&quot;xxx&quot;) === &apos;object&apos;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>instanceof<br>instanceof是检测对象的原型链上构造器constructor对象是否等于要检查对象。<br>而原型的constructor是很容易被修改的，比如prototype直接赋予对象，那么constructor就等于对象的constructor<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Car()&#123;&#125;</span><br><span class="line">Car.prototype = &#123;&#125;</span><br><span class="line">// Car的constructor被修改为Object</span><br></pre></td></tr></table></figure></li></ol><p>对象继承了父级对象，那么使用instanceof检查时要检查对象为父级constructor也是为true，因为它会查找原型链上的所有的constructor。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;&#125;</span><br><span class="line">Parent.prototype.get = function()&#123;</span><br><span class="line">    return &quot;父级&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function Car()&#123;&#125;</span><br><span class="line">Car.prototype = new Parent();</span><br><span class="line">Car.prototype.constructor = Car;</span><br><span class="line">let car = new Car();</span><br><span class="line">console.log(car instanceof Parent); // true</span><br></pre></td></tr></table></figure></p><ol start="3"><li>Object.prototype.toString<br>js的一句很吊的话，“一切皆为对象”，但有时从各种方面又可以体验出这句话的意思，如所有的类型都有一个顶级对象Object，而他们都继承了它的，这方面和java很像，因为java在强类型语言，所以一切变量都要定义好类型，但他们都可以向上转型为Object，他们的顶级类型也为Object。<br>而在一个对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用，就会自动调用toString方法，返回”[object type]”，type是对象的类型，所以可以利用这点对类型进行检查，但要使用到function的call重新定义上下文的this,那么就可以访问到对象里[[class]]属性，从而知道类型，而且这个检查类型的方式是比较全面的，但对自定义的实例化对象是无法检查到的，都统一返回[object Object],所以对这方面使用instanceof检查比较好。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = &quot;xx&quot;;</span><br><span class="line">Object.prototype.toString.call(a) // [object String]</span><br><span class="line">Object.prototype.toString.call(null) // [object Null]</span><br><span class="line">Object.prototype.toString.call(document.all) // [object HTMLAllCollection]</span><br></pre></td></tr></table></figure><p>所以综上所述，Object.prototype.toString对检查类型方面是比较完善正确的，缺点就是在自定义原型的实例化对象上的检查。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句相当于句子，表达式相当于短语，运算符相当于标点符号和连接符。<br>语句都是有结果返回的。<br>如在控制台输入一个语句，可以查看到一个返回结果。</p><p>赋值表达式的副作用，就是变量被赋予某个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var b;</span><br><span class="line">var a = 10;</span><br><span class="line">if(a &amp;&amp; (b = typeof a))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// b就被赋值，而且也进行了校验</span><br></pre></td></tr></table></figure></p><p>代码块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] + &#123;&#125;; // [object object]</span><br><span class="line">&#123;&#125; + []; // 0</span><br></pre></td></tr></table></figure></p><p>第一行[]强制转换为””, “”+{}，被认为{}空对象<br>第二行{}被当作空的代码块，而代码块不需要分号，+[]被强制转换为数字0，如+”” === 0</p><p>主要看运算符在谁前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = false,b = true, c = false, d = true, e = false, w = false, q = false, x = true, z = true;</span><br><span class="line">a || b &amp;&amp; c?d:e &amp;&amp; w? q: x||z</span><br></pre></td></tr></table></figure><p>&amp;&amp; 优先于 || 优先于 ?:</p><p>优先级,=优先于”,”,用()包着可以先优先执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var c = (++a,a)</span><br></pre></td></tr></table></figure></p><p>无论情况finally都会执行，除了finally报错，那么try的值就不会给返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    return 10;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    console.log(&quot;finally&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>switch case比较的是和===类似，所以计较严格，类型不一样也无法匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch(a)&#123;</span><br><span class="line">    case 10:....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(true)&#123;</span><br><span class="line">    case a == &apos;10&apos;:....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用&amp;&amp; || 要小心，因为它返回的是值，不是布尔值</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JavaScript 是一门简单易用的语言，应用广泛，同时它的语言机制又十分复杂和微妙，即使经验丰富的开发人员也需要用心学习才能真正掌握。&lt;</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>github博客域名绑定</title>
    <link href="https://793338023.github.io/2019/04/13/github%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
    <id>https://793338023.github.io/2019/04/13/github%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</id>
    <published>2019-04-13T07:58:59.000Z</published>
    <updated>2020-09-19T07:58:55.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阿里云的域名就挺不错的，还有免费的 SSL，就是不稳定，而好的年费上千，而区其他的地方购买域名有点坑，可能解析不成功或感觉卡 BUG。</p><p><a href="https://help.aliyun.com/document_detail/106669.html?spm=5176.100251.111252.22.5d774f15RAQ3dA" target="_blank" rel="noopener">阿里云解析教程</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>跟着阿里云的域名解析后，打开 DNS 解析设置，添加记录，记录类型为 CNAME，因为 github 不支持子域设置顶级域，所以只能重定向这样的，让 github 博客地址重定向到自定义域名上<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="DNS.PNG" alt="DNS" title="">                </div>                <div class="image-caption">DNS</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="tj.PNG" alt="添加" title="">                </div>                <div class="image-caption">添加</div>            </figure><br>打开 jithub 的博客仓库，然后再 setting 的域名地址。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="git.PNG" alt="git" title="">                </div>                <div class="image-caption">git</div>            </figure></p><p>这样就可以直接使用域名访问了，但访问地址是主机名+域名，不是 www+域名，如我的是 blog.gitzhangzhicheng.top</p><p>由于使用 hexo 博客，所以每次创建的 CNAME 都会被删除，那么就在 source 目录下创建 CNAME，那么每次提交到会把提交上，就不会出现覆盖不见的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;阿里云的域名就挺不错的，还有免费的 SSL，就是不稳定，而好的年费上千，而区其他的地方购买域名有点坑，可能解析不成功或感觉卡 BUG。&lt;/p</summary>
      
    
    
    
    
    <category term="github" scheme="https://793338023.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>我所知的linux操作</title>
    <link href="https://793338023.github.io/2019/04/05/%E6%88%91%E6%89%80%E7%9F%A5%E7%9A%84linux%E6%93%8D%E4%BD%9C/"/>
    <id>https://793338023.github.io/2019/04/05/%E6%88%91%E6%89%80%E7%9F%A5%E7%9A%84linux%E6%93%8D%E4%BD%9C/</id>
    <published>2019-04-05T13:27:59.000Z</published>
    <updated>2019-04-05T14:08:12.831Z</updated>
    
    <content type="html"><![CDATA[<p>##前言<br>作为一个开发者，有时工作久了，总要会一些不一样知识来填充自己，如我是一名前端开发，但前端的发展总要向后台靠拢，不是你无法知道怎么实现一个功能才能更符合逻辑，因为我们最后还是要和后台数据对接的或别的，而部署到服务器的项目，最后不会想windows那样使用，而是一种更加符合编码人员口味的linux，我们使用它打开文件，查看文件，安装等等，而对我们前端，最重要是查看，因为在一个BUG出现后终会看看是不是数据的问题，而这样就要查看日志了。</p><p>而我也只是使用过查看的功能，因为我没有权限。</p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><ol><li>进入要目录<br>cd 目录名或路径</li><li>进入”家”目录<br>cd ~</li><li>进入上一次工作路径<br>cd -</li><li>进入根目录<br>cd /</li><li>进入上层目录<br>cd ../</li></ol><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>查看当前工作目录路径</p><ol><li>查看当前路径<br>pwd</li><li>查看软链接的实际路径<br>pwd -P</li></ol><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等,是目前很常使用的命令，因为进入目录后不知道有什么文件，可以使用它查询</p><p>参数:</p><ol><li>-a 列出目录所有文件，包含以.开始的隐藏文件</li><li>-A 列出除.及..的其它文件</li><li>-r 反序排列</li><li>-t 以文件修改时间排序</li><li>-S 以文件大小排序</li><li>-h 以易读大小显示</li><li>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</li></ol><p>使用:</p><ol><li>按易读方式按时间反序排序，并显示文件详细信息<br>ls -lhrt</li><li>按大小反序显示文件详细信息<br>ls -lrS</li><li>列出当前目录中所有以“t”开头的目录的详细内容<br>ls -l t*</li><li>列出文件绝对路径（不包含隐藏文件）<br>ls | sed “s:^:<code>pwd</code>/:”</li><li>列出文件绝对路径（包含隐藏文件）<br>find $pwd -maxdepth 1 | xargs ls -ld</li></ol><p>而我比较常用的是<br>ls -lrt<br>反序列出所有修改时间的文件信息，可以看到最新的文件在顶部</p><h2 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h2><p>使用 less 可以随意浏览文件，之前使用view浏览文件的，但view查看会以乱码无法查看</p><p>常用命令参数：<br>-i  忽略搜索时的大小写<br>-N  显示每行的行号<br>-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来<br>-s  显示连续空行为一行<br>/字符串：向下搜索“字符串”的功能<br>?字符串：向上搜索“字符串”的功能<br>n：重复前一个搜索（与 / 或 ? 有关）<br>N：反向重复前一个搜索（与 / 或 ? 有关）<br>-x &lt;数字&gt; 将“tab”键显示为规定的数字空格<br>b  向后翻一页<br>d  向后翻半页<br>h  显示帮助界面<br>Q  退出less 命令<br>u  向前滚动半页<br>y  向前滚动一行<br>空格键 滚动一行<br>回车键 滚动一页<br>[pagedown]： 向下翻动一页<br>[pageup]：   向上翻动一页<br>实例：</p><ol><li>ps查看进程信息并通过less分页显示<br>ps -aux | less -N</li><li>查看多个文件<br>less 1.log 2.log<br>可以使用n查看下一个，使用p查看前一个</li></ol><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。而我是为了实时查看某个日志输出情况，而判断问题。</p><p> tail -f 查看日志文件</p><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索</p><p>grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>命令格式：<br>grep [option] pattern file|dir</p><p>grep参数实在太多了，<a href="https://www.cnblogs.com/wangcp-2014/p/5146335.html" target="_blank" rel="noopener">请看grep资料</a></p><p>实例：</p><ol><li>查找指定进程<br>ps -ef | grep svn</li><li>查找指定进程个数<br>ps -ef | grep svn -c</li><li>从文件中读取关键词<br>cat test1.txt | grep -f key.log</li><li>从文件夹中递归查找以grep开头的行，并只列出文件<br>grep -lR ‘^grep’ /tmp</li><li>查找非x开关的行内容<br>grep ‘^[^x]’ test.txt</li><li>显示包含ed或者at字符的内容行<br>grep -E ‘ed|at’ test.txt</li></ol><p>而4例子是最常使用的，因为有时不知道文件在哪里。只能根据大概的文件夹，递归的寻找到文件</p><p>以上都是一些查看操作权限</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##前言&lt;br&gt;作为一个开发者，有时工作久了，总要会一些不一样知识来填充自己，如我是一名前端开发，但前端的发展总要向后台靠拢，不是你无法知道怎么实现一个功能才能更符合逻辑，因为我们最后还是要和后台数据对接的或别的，而部署到服务器的项目，最后不会想windows那样使用，而是</summary>
      
    
    
    
    
    <category term="linux" scheme="https://793338023.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>react与antDesign</title>
    <link href="https://793338023.github.io/2019/04/02/react%E4%B8%8EantDesign/"/>
    <id>https://793338023.github.io/2019/04/02/react%E4%B8%8EantDesign/</id>
    <published>2019-04-02T14:37:05.000Z</published>
    <updated>2019-04-03T14:08:03.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>react的核心是数据与页面双向绑定，虚拟DOM，JSX，而react与vue差别在于react没有那么多的钩子函数，无指令，class方式编程，当然也可以函数式编程，如hooks，但主流还是class，在主观上react的操作需要构思一下数据结构与父子组件间的渲染优化，因为父组件渲染会触发子组件的钩子函数，并执行render，虽然虚拟DOM的diff算法，已经很大优化了渲染，但还是会出现父组件渲染导致子组件无必要渲染而导致页面卡顿现象，这就需要自己对不必要的数据控制不要渲染，如使用shouldComponentUpdate优化。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>脚手架的安装运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create-react-app my-app</span><br><span class="line">npm run eject  //弹出webpack</span><br></pre></td></tr></table></figure></p><p>一定要弹出webpack，不是没法进行一些配置，且安装babel-plugin-import那么就可以进行babel的配置，而且不需要建立babel配置文件，在package.json里就可以进行，否则会报错，plugins的import配置多个时需要在数组的第三个标明名称如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">      [&quot;import&quot;, &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;antd&quot;,</span><br><span class="line">        &quot;libraryDirectory&quot;: &quot;es&quot;,</span><br><span class="line">        &quot;style&quot;: &quot;css&quot; </span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;antd&quot;],</span><br><span class="line">      [&quot;import&quot;, </span><br><span class="line">      &#123; &quot;libraryName&quot;: &quot;antd-mobile&quot;, &quot;style&quot;: &quot;css&quot; &#125;,&quot;antd-mobile&quot;]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p><p>第三个参数没有会报错，如表明为antd或antd-mobile等。<br>而style设置为css，若设置true，那么加载的antd就要是less文件，否则无法正常加载css文件。</p><h2 id="react组件间使用的生命周期"><a href="#react组件间使用的生命周期" class="headerlink" title="react组件间使用的生命周期"></a>react组件间使用的生命周期</h2><p>在不使用路由router的情况下，组件在当前路由一开始就constructor-&gt;componentWillMount-&gt;render-&gt;componentDidMount,而当页面没有被卸载情况下componentWillReceiveProps-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate，当组件被卸载componentWillUnmount。</p><p>由于子组件没有卸载，所以constructor、componentWillMount、componentDidMount不会再触发，而是触发更新操作流程，而想每次更新都重新加载组件，那么就是卸载组件如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123;ChildCom&#125; from &apos;./ChildCom&apos;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">      const aaa = show?&lt;ChildCom /&gt;:null;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &#123;aaa&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 当shou为false时卸载组件，为true加载组件，这样就可以实现卸载与加载</span><br></pre></td></tr></table></figure><p>由于父组件的更新会触发子组件也触发更新操作，所以子组件的更新的钩子函数会去执行，而子组件自己的更新不会触发componentWillReceiveProps钩子函数。</p><h2 id="antd与antdDesign的表单校验"><a href="#antd与antdDesign的表单校验" class="headerlink" title="antd与antdDesign的表单校验"></a>antd与antdDesign的表单校验</h2><p>antd里有自己的一套完善的表单校验规则，根据API使用，而使用时需要Form与Form.Item包着，这样就可以使用getFieldDecorator函数给需要校验的组件进行双向绑定，然后进行表单的校验，而组件必须有value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性),而且传入的组件不需要声明value与onChange，它内部就实现好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; setItem, setItemContent &#125; from &apos;../../redux/itemReduce&apos;;</span><br><span class="line">import &#123; List, InputItem &#125; from &apos;antd-mobile&apos;;</span><br><span class="line">import &#123;Form&#125; from &apos;antd&apos;;</span><br><span class="line"></span><br><span class="line">class ItemTwo extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;name:&quot;zhang&quot;&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     componentDidMount() &#123;</span><br><span class="line">         // 全部进行校验，回调校验结果并触发页面的校验规则</span><br><span class="line">        this.props.form.validateFields((err, values) =&gt; &#123;</span><br><span class="line">            if (!err) &#123;</span><br><span class="line">              console.log(&apos;Received values of form: &apos;, values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      componentDidUpdate()&#123;</span><br><span class="line">        // isFieldTouched判断一个输入控件是否经历过 getFieldDecorator 的值收集时机 options.trigger</span><br><span class="line">        // getFieldError获取某个输入控件的 Error</span><br><span class="line">        const &#123; isFieldTouched,getFieldError,getFieldsValue, validateFields &#125; = this.props.form;</span><br><span class="line">        const childPhoneError = isFieldTouched(&apos;childPhone&apos;) &amp;&amp; getFieldError(&apos;childPhone&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; getFieldDecorator &#125; = this.props.form;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&apos;itemOne&apos;&gt;</span><br><span class="line">                &lt;Form&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                    &#123;getFieldDecorator(&apos;childPhone&apos;,&#123;</span><br><span class="line">                        rules: [&#123; required: true, message: &apos;手机号必填!&apos; &#125;]</span><br><span class="line">                    &#125;)(</span><br><span class="line">                        &lt;InputItem &gt;子手机号&lt;/InputItem&gt;</span><br><span class="line">                    )&#125;</span><br><span class="line">                &lt;/Form.Item&gt;    </span><br><span class="line">                &lt;/Form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state=&gt;&#123;</span><br><span class="line">    return state.itemRedux;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">const mapDispatchToProps = &#123;setItem, setItemContent&#125;;</span><br><span class="line">  </span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(Form.create(&#123;</span><br><span class="line">    name:&quot;itemTwo&quot;,</span><br><span class="line">    // 具体表单进行与父组件或redux，的props属性关联起来</span><br><span class="line">    mapPropsToFields(props)&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            childPhone:Form.createFormField(&#123;</span><br><span class="line">                    value: props.phone</span><br><span class="line">                    &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 当 Form.Item 子节点的值发生改变时触发，可以把对应的值转存到 Redux store</span><br><span class="line">    onFieldsChange(props, fields)&#123;</span><br><span class="line">        console.log(props);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 任一表单域的值发生改变时的回调</span><br><span class="line">    onValuesChange(props, changedValues, allValues)&#123;</span><br><span class="line">        console.log(props.form.getFieldError)</span><br><span class="line">        //console.log(changedValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(ItemTwo));</span><br></pre></td></tr></table></figure></p><p>这里只是一部分，还有很多校验方法，如自定义校验，自定义校验方法等等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;react的核心是数据与页面双向绑定，虚拟DOM，JSX，而react与vue差别在于react没有那么多的钩子函数，无指令，class方式</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>git的协同开发使用</title>
    <link href="https://793338023.github.io/2019/03/27/git%E7%9A%84%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8/"/>
    <id>https://793338023.github.io/2019/03/27/git%E7%9A%84%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8/</id>
    <published>2019-03-27T14:57:17.000Z</published>
    <updated>2019-04-22T14:24:51.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在团队开发中，难免要合并代码，代码冲突，检查代码之类的，而选择一个版本维护工具是首选项，这会影响以后在代码上的把控，而我使用过svn与git，然后在体验上发现git在这方面是做的最好的，它强大的分支功能和离线状态可使用，让后期工作效率更高，在代码上更方便，而svn在这方面就很吃力，代码的合并与检查都需要人为的操作，如需要代码清单，代码比对工具等人为的检查合并代码，真心浪费时间。</p><h2 id="协同流程"><a href="#协同流程" class="headerlink" title="协同流程"></a>协同流程</h2><p>不同公司，协同的方式有可能不一样。<br>而我们的流程是:</p><ol><li>首先fork远程源的仓库到自己的远程仓库</li><li><p>使用git clone 把项目克隆到自己的本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 远程仓库地址</span><br></pre></td></tr></table></figure></li><li><p>修改项目代码后检查状态，添加本地，提交本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 直接从主分支提交到远程的主分支上</span><br><span class="line"></span><br><span class="line">git status // 查状态</span><br><span class="line">git add . // 添加所以修改</span><br><span class="line">或</span><br><span class="line">git add 修改文件 // 可文件夹，多个文件用空格隔开</span><br><span class="line">git commit -m &quot;修改信息&quot; // 提交到本地仓库</span><br><span class="line">git remote -v // 检查关联的远程仓库，找到提交的远程仓库名称</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; // 提交到远程仓库</span><br><span class="line">如: 关联的远程仓库有: myDemo、gs</span><br><span class="line">git push myDemo master</span><br><span class="line">本地的主分支推送到myDemo远程仓库里</span><br><span class="line"></span><br><span class="line">// 从创建分支提交到远程的创建分支，然后请求合并，最后合并到主分支master上</span><br><span class="line"></span><br><span class="line">git checkout -b fz // fz为分支名，这是创建分支并切换到创建分支上</span><br><span class="line">git status // 查看状态</span><br><span class="line">git diff 文件 // 根据状态查看文件，然后比较是否为需要提交的代码</span><br><span class="line">git add 文件... // 根据状态查看文件，添加文件到暂缓区</span><br><span class="line">git commit -m &quot;描述&quot; // 提交暂缓区到当前分支的本地仓库上 </span><br><span class="line">git branch // 查看所有分支，并确认分支名</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; // 提交到远程仓库</span><br><span class="line">// 到远程仓库中提出合并请求</span><br><span class="line">git checkout master // 切换到主分支</span><br><span class="line">git merge fz // 合并分支到主分支</span><br><span class="line">git push &lt;远程主机名&gt; master // 把合并修改提交远程仓库的主分支上，为了同步，因为自己仓库需要自己维护，所以本地合并后提交到远程master</span><br></pre></td></tr></table></figure></li><li><p>推到自己的远程仓库后向fork源提出合并请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">点击</span><br><span class="line">pull request</span><br><span class="line">合并请求填写请求描述</span><br></pre></td></tr></table></figure></li><li><p>当项目已经存在，每次提交需要拉取一份远程源地址代码然后diff比较不同，查看是否冲突，然后合并到本地代码，再进行提交，推送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git remote add 代码源地址名称taregt 代码源地址 // 添加远程仓库关联</span><br><span class="line">git fetch git fetch taregt master:temp // 从远程的taregt仓库的master分支下载到本地并新建一个分支temp</span><br><span class="line">git diff temp // 比较本地的仓库和远程仓库的拉取到本地分支对比</span><br><span class="line">git merge temp // 合并temp分支到master分支</span><br><span class="line">git branch -d temp // 删除temp分支</span><br><span class="line"></span><br><span class="line">// 快速拉取，拉取是会自动合并，但有冲突就会提示，然后等冲突解决后合并，如使用git stash储藏可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用</span><br><span class="line">git pull &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line">// 回退版本，reset回退只是指针的回退到指定版本，然后重这个版本开始</span><br><span class="line">git reset --hard 目标版本号或HEAD^上一个版本</span><br><span class="line"></span><br><span class="line">// revert的作用通过反做创建一个新的版本,是把回退的版本做成一个新的版本，可以保留该目标版本后面的版本</span><br><span class="line">git revert -n 版本号</span><br><span class="line"></span><br><span class="line">// 都可以使用git log 查看版本信息</span><br><span class="line"></span><br><span class="line">// 重新操作、添加、提交、推送、pull request 进行代码贡献</span><br></pre></td></tr></table></figure></li><li><p>拉取团队代码操作流程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在项目拉取团队开发的代码时，一般有两种保存自己代码方式，为了的是不给拉取代码覆盖</span><br><span class="line"></span><br><span class="line">// 1. 创建分支，把代码从分支提交到本地分支里，等拉取完后，看情况merge合并分支代码到master里，这样就不会覆盖自己开发的代码，当然在merge时可以使用diff指令查看不同的地方，是否需要调整的</span><br><span class="line">git checkout -b 分支名</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;描述&quot;</span><br><span class="line">git checkout master</span><br><span class="line">git pull 远程主机 master</span><br><span class="line">git diff 分支名</span><br><span class="line">git merge 分支名</span><br><span class="line"></span><br><span class="line">// 2. stash到储存起来，把修改的代码存起来，然后拉取代码</span><br><span class="line">git stash</span><br><span class="line">git pull 远程主机 master</span><br><span class="line">git stash show -p // 查看拉取代码与存起来的代码的不同地方</span><br><span class="line">git stash apply // 应用储存的代码，这样就可以实现不被拉取代码覆盖</span><br></pre></td></tr></table></figure></li></ol><p>使用例子2觉得比较好，因为不会在log里存在提交日志，而且也不要创建分支合并分支删除分支等操作，就简单的存起来，然后释放就可以了，其实就就是把修改的代码保存起来，然后工作区的代码还原为当前版本的代码，拉取远程仓库代码带当前版本的代码里，最后应用存起来的代码就是覆盖到当前拉取的代码，就是一个这样的操作，所以有必要git stash show -p查看不同点，然后进行调整。</p><p><a href="https://www.cnblogs.com/tocy/p/git-stash-reference.html" target="_blank" rel="noopener">stash资料</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="noopener">更多git的学习</a></p><hr><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op1=&gt;operation: fork源项目</span><br><span class="line">op2=&gt;operation: add添加本地</span><br><span class="line">op3=&gt;operation: commit提交本地</span><br><span class="line">opt4=&gt;operation: 推送自己远程仓库</span><br><span class="line">opt5=&gt;operation: pull request</span><br><span class="line">opt6=&gt;operation: remote add 添加远程源仓库</span><br><span class="line">opt7=&gt;operation: clone克隆到本地</span><br><span class="line">opt8=&gt;operation: fetch拉取到本地仓库的新分支</span><br><span class="line">opt9=&gt;operation: diff比较主与支代码</span><br><span class="line">opt10=&gt;operation: 合并代码，删除分支</span><br><span class="line">cond=&gt;condition: 是否为初创项目?</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">st-&gt;cond</span><br><span class="line">cond(yes)-&gt;op1-&gt;opt7-&gt;opt6-&gt;op2-&gt;op3-&gt;opt4-&gt;opt5-&gt;e</span><br><span class="line">cond(no)-&gt;opt8-&gt;opt9-&gt;opt10-&gt;op2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在团队开发中，难免要合并代码，代码冲突，检查代码之类的，而选择一个版本维护工具是首选项，这会影响以后在代码上的把控，而我使用过svn与git</summary>
      
    
    
    
    
    <category term="git" scheme="https://793338023.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>react的setState</title>
    <link href="https://793338023.github.io/2019/03/25/react%E7%9A%84setState/"/>
    <id>https://793338023.github.io/2019/03/25/react%E7%9A%84setState/</id>
    <published>2019-03-25T15:12:10.000Z</published>
    <updated>2019-04-19T15:50:56.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React通过管理状态实现对组件的管理，通过this.setState()方法更新state，触发render()方法重新渲染页面，而在更新前有一个shouldComponentUpdate可以控制state更新是否触发render，方便不必要的渲染，而state里最好放入与渲染有关的属性，而渲染无关的使用class的属性对象保存使用即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Demo extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;name:<span class="string">"zhang"</span>&#125;;  // state</span><br><span class="line">        this.objState = &#123;currPage:0&#125;; // 不必要渲染的对象使用</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">changePage</span></span>()&#123;</span><br><span class="line">        this.objState.currPage++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="state注意事项"><a href="#state注意事项" class="headerlink" title="state注意事项"></a>state注意事项</h2><p>1、使用state是要遵循react的规则，state是不可变的，需要使用特定的函数更新state，如state在constructor定义后不能对它直接进行赋值操作，而是要使用setState，否则不会触发渲染render，而是直接修改了state，在下次使用setState后直接覆盖掉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Demo extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;name:<span class="string">"zhang"</span>&#125;;  // state</span><br><span class="line">        this.objState = &#123;currPage:0&#125;; // 不必要渲染的对象使用</span><br><span class="line">    &#125;</span><br><span class="line">    changePage=()=&gt;&#123;</span><br><span class="line">        // 这是错误的操作</span><br><span class="line">        this.state.name = <span class="string">"测试"</span>;</span><br><span class="line">        // 正确操作</span><br><span class="line">        this.setState(&#123;name: <span class="string">"ceshi"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div onClick=&#123;changePage&#125;&gt;&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、setState是异步的<br>由于react的setState的源码里，会先把state的更新推进队列里，等所有的state都进入后才会进行render的渲染操作，而所以在setState后不要直接获取state的数据，因为那些还是旧数据，而是要等调用栈结束后执行渲染操作再获取更新后state，但shouldComponentUpdate与componentWillUpdate接受的参数是更新后state，所以这些在渲染前的钩子函数可以在接收参数里获取更新的state与props,<strong>而setState的异步是代码执行顺序实现的，代码里都是同步的</strong>。</p><p>但由于setState在一般的调用时都会放到任务队列里，而把setState的使用放在setTimeout这些异步调用的回调函数里时不会放到任务队列里，而是直接调用，所以在setTimeout这些回调函数里可以直接获取到更新的state。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class ItemOne extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;name:<span class="string">"zhang"</span>&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     change=()=&gt;&#123;</span><br><span class="line">         this.setState(&#123;name:<span class="string">"vvv"</span>&#125;);</span><br><span class="line">         setTimeout(()=&gt;&#123;</span><br><span class="line">            this.setState(&#123;name:<span class="string">"xxx"</span>&#125;);</span><br><span class="line">            console.log(<span class="string">"time:"</span>+this.state.name); // xxx</span><br><span class="line">         &#125;,0)</span><br><span class="line">     &#125;</span><br><span class="line">    shouldComponentUpdate(props, state)&#123;</span><br><span class="line">        console.log(this.state.name)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUpdate(props, state)&#123;</span><br><span class="line">        console.log(state);</span><br><span class="line">        console.log(this.state.name);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span></span>()&#123;</span><br><span class="line">        console.log(this.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">'itemOne'</span>&gt;</span><br><span class="line">                &lt;div onClick=&#123;this.change&#125;&gt;&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印</span><br><span class="line">// zhang</span><br><span class="line">// &#123;name: <span class="string">"vvv"</span>&#125;</span><br><span class="line">// zhang</span><br><span class="line">// vvv</span><br></pre></td></tr></table></figure><p>3、不要在shouldComponentUpdate与componentWillUpdate使用<br>在shouldComponentUpdate与componentWillUpdate使用setState会造成死循环，所以浏览器都会在控制台报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错信息</span><br><span class="line">Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.</span><br></pre></td></tr></table></figure><p>4、不涉及渲染state<br>由于state的更新都会触发render渲染，而有些状态是不需要触发渲染的，那么可以使用一些普通对象保存，而不是使用state管理，因为state与普通对象的差别在于会触发页面的渲染。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Demo extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;name:<span class="string">"zhang"</span>&#125;;  // state</span><br><span class="line">        this.objState = &#123;currPage:0&#125;; // 不必要渲染的对象使用</span><br><span class="line">    &#125;</span><br><span class="line">    changePage=()=&gt;&#123;</span><br><span class="line">        this.objState.currPage++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div onClick=&#123;changePage&#125;&gt;&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、componentWillReceiveProps<br>当一个组件从父组件接受参数；只要父组件的render函数被重新执行了，子组件的这个生命周期就会被执行；<br>（如果这个组件第一次存在于父组件中，不会执行，如果这个组件之前存在于父组件中，才会执行）<br>所以无论props使用更新，只要父组件渲染了那么就会触发这个函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;React通过管理状态实现对组件的管理，通过this.setState()方法更新state，触发render()方法重新渲染页面，而在更新</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react与后端通讯和react高阶组件</title>
    <link href="https://793338023.github.io/2019/03/19/react%E4%B8%8E%E5%90%8E%E7%AB%AF%E9%80%9A%E8%AE%AF%E5%92%8Creact%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <id>https://793338023.github.io/2019/03/19/react%E4%B8%8E%E5%90%8E%E7%AB%AF%E9%80%9A%E8%AE%AF%E5%92%8Creact%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</id>
    <published>2019-03-19T13:27:40.000Z</published>
    <updated>2019-04-25T15:49:52.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react与后端通讯"><a href="#react与后端通讯" class="headerlink" title="react与后端通讯"></a>react与后端通讯</h2><h3 id="react组件"><a href="#react组件" class="headerlink" title="react组件"></a>react组件</h3><p>当只考虑使用react组件与后端进行通讯时，一般在componentDidMount钩子函数里实现请求即可，componentDidMount是render渲染后触发，在这里可以进行DOM之类的操作。而react不带请求方法，需要引入插件，而使用JQ这类的有点冗余，而axios插件流行，且灵活度高，而且返回的结果为Promise，便于操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm isntall axios --save</span><br></pre></td></tr></table></figure><p>请求例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">    axios.get(<span class="string">'请求URL'</span>)</span><br><span class="line">    .<span class="keyword">then</span>(<span class="keyword">function</span> (response) &#123;</span><br><span class="line">     // response.data返回数据</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="keyword">function</span> (error) &#123;</span><br><span class="line">      // 捕获异常，如reject之类的</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/7a9fbcbb1114" target="_blank" rel="noopener">axios</a>的拦截器可以对请求装饰，如添加token，添加遮罩或处理一些公共的信息，如错误码跳转等，这些可以让项目更容易维护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加请求拦截器</span><br><span class="line">axios.interceptors.request.use（<span class="keyword">function</span>（config）&#123;</span><br><span class="line">     //在发送请求之前做某事</span><br><span class="line">     <span class="built_in">return</span> config;</span><br><span class="line">   &#125;，<span class="keyword">function</span>（error）&#123;</span><br><span class="line">     //请求错误时做些事</span><br><span class="line">     <span class="built_in">return</span> Promise.reject（error）;</span><br><span class="line">   &#125;）;</span><br><span class="line"> </span><br><span class="line">//添加响应拦截器</span><br><span class="line">axios.interceptors.response.use（<span class="keyword">function</span>（response）&#123;</span><br><span class="line">     //对响应数据做些事</span><br><span class="line">     <span class="built_in">return</span> response;</span><br><span class="line">   &#125;，<span class="keyword">function</span>（error）&#123;</span><br><span class="line">     //请求错误时做些事</span><br><span class="line">     <span class="built_in">return</span> Promise.reject（error）;</span><br><span class="line">   &#125;）;</span><br></pre></td></tr></table></figure><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>当项目很复杂时需要使用redux进行数据的集中分发时那么数据的来源都是从redux里来，而这样前端与后端的通讯就要在redux里进行。<br>但redux的数据进行传送过程时同步的，那么就需要中间件转为异步操作，而redux的强大又体出来了，redux适配性很高，只要给它加个合适的中间件，即可方便使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux-thunk</span><br></pre></td></tr></table></figure><p>redux-thunk在Redux的action对象被reducer函数处理之前，插入异步功能。<br>redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123;createStore, applyMiddleware&#125; from <span class="string">'redux'</span>;</span><br><span class="line">import thunk from <span class="string">'redux-thunk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> count(state = 0, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="built_in">return</span> state + 1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'REDUCER'</span>:</span><br><span class="line">            <span class="built_in">return</span> state - 1;</span><br><span class="line">        default:</span><br><span class="line">            <span class="built_in">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const store = createStore(count,applyMiddleware(thunk));</span><br><span class="line"></span><br><span class="line">//action创建函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">addIfOdd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (dispatch, getState) =&gt; &#123;</span><br><span class="line">        const currentValue = getState();</span><br><span class="line">        <span class="keyword">if</span> (currentValue % 2 == 0) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            <span class="built_in">type</span>: <span class="string">'ADD'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件用于增强现有组件组件，好比装饰器模式一样。<br>简单来说，一个高阶组件就是一个函数，这个函数接受一个组件作为输入，然后返回一个新的组件作为结果，而且，返回的新组件拥有了输入组件所不具有的功能。</p><p>而高阶组件的实现有两种方式，代理方式与继承方式。</p><h3 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a>代理方式</h3><p>代理方式就是以组件为参数传入返回一个新的组件。<br>代理方式的高阶组件，可以应用在下列场景中：<br>1、操纵 prop;<br>2、访问 ref;<br>3、抽取状态；<br>4、包装组件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const newComponent = (Component, newProps)=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> calss Wrapper extends React.Component&#123;</span><br><span class="line">        constructor(props)&#123;</span><br><span class="line">            super(props);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">            <span class="built_in">return</span> (</span><br><span class="line">                &lt;Component &#123;...this.props&#125; &#123;...newProps&#125; /&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式的高阶组件采用继承关系关联作为参数的组件和返回的组件，假如传入的组件参数是 WrappedComponent，那么返回的组件就直接继承自 WrappedComponent。</p><p>继承方式的高阶组件可以应用于下列场景：<br>1、操纵 prop;<br>2、操纵生命周期函数。</p><p>而继承方式改变prop是很麻烦的，需要使用React.cloneElement复制一份组件并修改prop值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const modyComponent = (WrappedComponent)=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> class NewComponent extends WrappedComponent&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">            const elem = super.render();</span><br><span class="line">            const newProps = &#123;...this.props, style: &#123;color: <span class="string">'red'</span>&#125;&#125;;</span><br><span class="line">            <span class="built_in">return</span> React.cloneElement(elem, newProps, elem.props.children);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面例子的比较可以看出来，各方面看来代理方式都要优于继承方式。</p><h2 id="以函数为子组件"><a href="#以函数为子组件" class="headerlink" title="以函数为子组件"></a>以函数为子组件</h2><p>由于以上的高阶组件都有一个问题就是嵌套加深，都要在组件外包囊一层，而且固化prop，无法达到预期的灵活要求，而以函数为子组件就可以解决这个问题。<br>以函数为子组件其实就是在使用this.props.children获取嵌套在组件内的函数，然后传参调用返回组件。</p><p>弊端就是每次使用都要创建一个函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">calss Wrapper extend Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">            super(props);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        childFn = this.props.children(this.props);</span><br><span class="line">        <span class="built_in">return</span> childFn;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一定要是函数</span><br><span class="line">Wrapper.propTypes = &#123;</span><br><span class="line">    children: React.PropTypes.func.isRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">&lt;Wrapper&gt;</span><br><span class="line">&#123;(aa)=&gt;&lt;div&gt;&#123;aa&#125;&lt;/div&gt;&#125;</span><br><span class="line">&lt;/Wrapper&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react与后端通讯&quot;&gt;&lt;a href=&quot;#react与后端通讯&quot; class=&quot;headerlink&quot; title=&quot;react与后端通讯&quot;&gt;&lt;/a&gt;react与后端通讯&lt;/h2&gt;&lt;h3 id=&quot;react组件&quot;&gt;&lt;a href=&quot;#react组件&quot; class</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>redux运用</title>
    <link href="https://793338023.github.io/2019/03/16/redux%E8%BF%90%E7%94%A8/"/>
    <id>https://793338023.github.io/2019/03/16/redux%E8%BF%90%E7%94%A8/</id>
    <published>2019-03-16T04:06:31.000Z</published>
    <updated>2020-01-04T04:00:31.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redux-的概念"><a href="#redux-的概念" class="headerlink" title="redux 的概念"></a>redux 的概念</h2><p>Redux 是 Flux 的另一种实现，也可以说进步，在以前基本都是使用 MVC 开发模式，然而这个模式没有限制住广大开发者们，因为他只是一个开发模式，没有边界限制，只能自己按照 MVC 的开发模式规范去做，至于是否真的按照规范做，这就不能约束了，所以会出现 M 与 V 直接对话，而没有让 C 起到作用，或者一些别的，使得 MVC 模式下开发混乱，还有就是 Model 和 View 之间缠绕着蜘蛛网一样复杂的依赖关系，让人难以维护。<br>而 Redux 出现可以说把这个模式加上了约束条件，不让开发者为了方便跳过 C 等操作，一定遵循 Action-&gt;Dispatcher-&gt;Store-&gt;view-&gt;Action，这个流程循环执行。</p><p>Dispatcher:处理动作分发，维持 Store 之间的依赖关系；<br>Store:负责存储数据和处理数据相关逻辑；<br>Action:驱动 Dispatcher 的 JavaScript 对象；<br>View:视图部分，负责显示用户界面。</p><p>如果把 redux 和 MVC 做一个结构对比，那么，redux 的 Dispatcher 相当于 MVC 的 Controller,redux 的 Store 相当于 MVC 的 Model,redux 的 View 是 react 组件 对应 MVC 的 View 了，至于多出来的这个 Action，可以理解为对应给 MVC 框架的用户请求。</p><h3 id="Redux-的基本原则"><a href="#Redux-的基本原则" class="headerlink" title="Redux 的基本原则"></a>Redux 的基本原则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、唯一数据源</span><br><span class="line">2、保持状态只读</span><br><span class="line">3、数据改变只能通过纯函数完成</span><br></pre></td></tr></table></figure><h4 id="唯一数据源"><a href="#唯一数据源" class="headerlink" title="唯一数据源"></a>唯一数据源</h4><p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个 Store 上。<br>虽然我们经常会按功能把 store 分成多个文件进行管理，但最后我们还是会把 store 合并成一个 Store。</p><h4 id="保持状态只读"><a href="#保持状态只读" class="headerlink" title="保持状态只读"></a>保持状态只读</h4><p>保持状态只读，就是说不能去直接修改状态，要修改 Store 的状态，必须要通过派发一个 action 对象完成。</p><h4 id="数据改变只能通过纯函数完成"><a href="#数据改变只能通过纯函数完成" class="headerlink" title="数据改变只能通过纯函数完成"></a>数据改变只能通过纯函数完成</h4><p>这里所说的纯函数就是 Reducer，reducer(state , action)<br>第一个参数 state 是当前的状态，第二个参数 action 是接收到的 action 对象，而 reducer 函数要做的事情，就是根据 state 和 action 的值产生一个新的对象返回，注意 reducer 必须是纯函数，也就是说函数的返回结果必须完全由参数 state 和 action 决定，而且不产生任何副作用，也不能修改参数 state 和 action 对象。</p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>由于 redux 可以通用其他的地方，所以它的灵活性高，使用中间件连接 react 与 redux,免除一些配置，如 react-redux 最主要的两个功能是 connect 与 Provider。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>connect 有两个参数 mapStateToProps、mapDispatchToProps，就是把 redux 的 Store 变成组件的 props 与把 action 方法变成组件的 props，方便组件内部调用。<br>connect 的实现就是给组件嵌套一层容器组件，然后让容器组件向内部的组件传递 props，既容器组件与傻瓜组件的概念。</p><p>mapStateToProps、mapDispatchToProps 函数都接受两个参数，第二参数都是为自身拥有的 props，mapStateToProps 第一个参数为 Store，返回的对象为转化为 props 的值，mapDispatchToProps 第一参数为 dispatch 派发器，既 action 怎么触发派发函数，而 mapDispatchToProps 可以直接为一个字面量对象，那么就可以把 action 包装为一个派发函数，只要触发它即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from <span class="string">'react'</span>;</span><br><span class="line">import &#123; Link &#125; from <span class="string">'react-router-dom'</span>;</span><br><span class="line">import &#123;connect&#125; from <span class="string">'react-redux'</span>;</span><br><span class="line">import &#123;setItem, setItemContent&#125; from <span class="string">'../../redux/itemReduce'</span>;</span><br><span class="line"></span><br><span class="line">import ItemOne from <span class="string">'../ItemOne/'</span>;</span><br><span class="line"></span><br><span class="line">class Item extends Component &#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;&#125;;</span><br><span class="line">    this.setName = this.setName.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">    console.log(this.props);</span><br><span class="line">  &#125;</span><br><span class="line">  setName(ev)&#123;</span><br><span class="line">    <span class="built_in">let</span> val = ev.target.value;</span><br><span class="line">    // 触发action</span><br><span class="line">    this.props.setItem(&#123;itemName: val&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'item'</span>&gt;</span><br><span class="line">        &lt;p&gt;item 欢迎光临&lt;/p&gt;</span><br><span class="line">        &lt;Link to=<span class="string">'/'</span>&gt;跳转home&lt;/Link&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">'text'</span> onInput=&#123;this.setName&#125;/&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ItemOne /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state=&gt;&#123;</span><br><span class="line">  <span class="built_in">return</span> state.itemRedux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// setItem,setItemContent是action方法</span><br><span class="line">const mapDispatchToProps = &#123;setItem, setItemContent&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default connect(mapStateToProps, mapDispatchToProps)(Item);</span><br></pre></td></tr></table></figure><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider 组件，可以让容器组件拿到 state。<br>Provider 在根组件一般在根组件的上一层包着，App 的所有子组件就默认都可以拿到 state 了。<br>而它的原理就是使用 context，store 放在了上下文对象 context 上面,然后，子组件就可以从 context 拿到 store。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// react-redux、redux-thunk、redux配合使用的写法基本是固定的，除非有特殊要求</span><br><span class="line"></span><br><span class="line">import React from <span class="string">'react'</span>;</span><br><span class="line">import ReactDOM from <span class="string">'react-dom'</span>;</span><br><span class="line">import <span class="string">'./index.css'</span>;</span><br><span class="line">import * as serviceWorker from <span class="string">'./serviceWorker'</span>;</span><br><span class="line"></span><br><span class="line">import router from <span class="string">'./router.js'</span>;</span><br><span class="line"></span><br><span class="line">import &#123;createStore, applyMiddleware, compose&#125; from <span class="string">'redux'</span></span><br><span class="line">import thunk from <span class="string">'redux-thunk'</span></span><br><span class="line">import &#123; Provider &#125; from <span class="string">'react-redux'</span></span><br><span class="line">import reducers from <span class="string">'./reduces'</span></span><br><span class="line"></span><br><span class="line">// compose是增强store的，如浏览器插件redux监听store数据，添加中间件，如redux-thunk解决异步问题</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers, compose(applyMiddleware(thunk),</span><br><span class="line">window.devToolsExtension?window.devToolsExtension():f=&gt;f))</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &#123;router()&#125;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">, document.getElementById(<span class="string">'root'</span>));</span><br><span class="line"></span><br><span class="line">serviceWorker.unregister();</span><br></pre></td></tr></table></figure><p>由于 Store 只有一个，如果数据冗余，那么会很占内存且结构复杂，而宁愿牺牲一些性能，进行一些运算达到获取目标结果，也比存储起来好。<br>还有数据的扁平化，由于使用 Store 把数据嵌套过深，会让数据的修改与获取加大难度，这样最好是数据的扁平化，那么就可以减少没有必要的非空判断，默认赋值之类的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 若嵌套深时获取数据</span><br><span class="line">const d = state.A &amp;&amp; state.A.B &amp;&amp; state.A.B.C &amp;&amp; state.A.B.C.D ;</span><br><span class="line"></span><br><span class="line">//而扁平化</span><br><span class="line">const d = state.A;</span><br></pre></td></tr></table></figure><p>而 redux 的 Store 只有一个，但我们需要模块化的开发，那么就是需要把多个 Store 合并成一个，就要使用 combineReducers。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;combineReducers&#125; from <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line">import &#123;home&#125; from <span class="string">'./redux/homeReduce'</span>;</span><br><span class="line">import &#123;item&#125; from <span class="string">'./redux/itemReduce'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> comReduces = &#123;</span><br><span class="line">    homeRedux: home,</span><br><span class="line">    itemRedux: item</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default combineReducers(comReduces);</span><br></pre></td></tr></table></figure><p>而合并后 Store 的对应模块的键值为对象的键值，如 homeRedux 下 Store，为 homeRedux。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redux-的概念&quot;&gt;&lt;a href=&quot;#redux-的概念&quot; class=&quot;headerlink&quot; title=&quot;redux 的概念&quot;&gt;&lt;/a&gt;redux 的概念&lt;/h2&gt;&lt;p&gt;Redux 是 Flux 的另一种实现，也可以说进步，在以前基本都是使用 MVC 开</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react运用</title>
    <link href="https://793338023.github.io/2019/03/15/react%E8%BF%90%E7%94%A8/"/>
    <id>https://793338023.github.io/2019/03/15/react%E8%BF%90%E7%94%A8/</id>
    <published>2019-03-15T14:57:28.000Z</published>
    <updated>2020-01-04T02:44:20.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-的安装"><a href="#react-的安装" class="headerlink" title="react 的安装"></a>react 的安装</h2><p>由于 react 的需要依赖一些的技术栈才能方便进行正常的开发，但这对学习它的成本会提高很多，如要需要会 webpack、gulp、Babel 等模块与构建工具，这样在没有开始就倒在了入门路上，而这些配置一般都可以是固定的，而使用脚手架，一行代码即可。</p><p>但 react 脚手架过于复杂，对初学者来说，没有特殊要求可以不修改配置之类，不过一旦涉及这方面需求就懵逼了，因为 react 脚手架是 node 写的，webpack 只是它的一部分，也是核心部分，所以有 webpack 初步经验，为了更好的了解可以选择自己搭建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 安装全局的create-react-app</span><br><span class="line">npm install --g create-react-app</span><br><span class="line"></span><br><span class="line">// 在指定目录创建react项目</span><br><span class="line">create-react-app 项目名</span><br><span class="line"></span><br><span class="line">// 进入项目</span><br><span class="line"><span class="built_in">cd</span> 项目名</span><br><span class="line"></span><br><span class="line">// 启动项目</span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line">// 对webpack进行操作，执行就无法逆转，如果有必要备份一份</span><br><span class="line">npm run eject</span><br></pre></td></tr></table></figure><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX 是 JavaScript 的扩展语言，让 HTML 可以在 js 里编写，但使用模块一定要引入 react,而一般自定义的组件元素首字母都是大写，而这样区别 html 与 react 组件，而在 HTML 中大量的绑定事件是不规范的。<br>原因有以下:<br>2、如 onclick 添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意料不到的后果；<br>3、给很多 DOM 元素添加 onclick 事件，可能会影响网页的性能，毕竟，网页需要的事件处理函数越多，性能就会越低；<br>4、对于使用 onclick 的 DOM 元素，如果要动态地从 DOM 树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的 bug 很难被发现。</p><p>而以上的原因都是针对复杂的项目或单页面项目。</p><p>但 JSX 没有这方面的缺点，首先，如 onClick 挂载的每个函数，都可以控制在组件范围内，不会污染全局空间。我们在 JSX 中看到一个组件使用了 onClick，但并没有产生直接使用 onclick 的 HTML，而是使用了事件委托的方式处理点击事件，无论有多少个 onClick 出现，其实最后都只在 DOM 树上添加了一个事件处理函数，挂在最顶层的 DOM 节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定函数，使用事件委托的性能要比为每个 onClick 都挂载一个事件处理函数要高。</p><p>React 控制了组件的生命周期，在 unmount 的时候自然能够清除相关的所有事件处理函数，内存泄露也不再是一个问题。</p><p>在使用 jsx 时，添加类名要使用 className,因为 class 是保留关键字，使用 js 的保留关键字一般使用报错的，但如果习惯使用 class 可以添加相对的兼容包。</p><h2 id="React-与-JQuery-区别"><a href="#React-与-JQuery-区别" class="headerlink" title="React 与 JQuery 区别"></a>React 与 JQuery 区别</h2><p>JQuery 操作是选中一些 DOM 元素，然后对这些元素做一些操作，而在大项目中频繁的选择各种各样的元素，而一种元素有不同选择方式，使得项目很复杂，难以维护。<br>React 操作就只注重数据怎么操作，而界面对数据进行渲染，而无需关心怎么选择元素操作。既重要的是区分开哪些属于 data，哪些属于 render，想要更新用户界面，要做的就是更新 data，用户界面自然会做出响应。</p><p>而 React 渲染都不是整体渲染的，React 利用 Virtual DOM，让每次渲染都只重新渲染最少的 DOM 元素。<br>Web 前端开发关于性能优化有一个原则尽量减少 DOM 操作。虽然 DOM 操作也只是一些简单的 JavaScript 语句，但是 DOM 操作会引起浏览器对网页进行重新布局，重新绘制，这就是一个比 JavaScript 语句执行慢很多的过程。<br>Virutal DOM 不会触及浏览器的部分，只是存在于内存空间的树形结构，每次自上而下渲染 React 组件时，会对比这一次产生的 Virtual DOM 和上一次渲染的 Virtual DOM ，对比就会发现差别，然后修改真正的 DOM 树时就只需要触及差别中的部分就行。<br>所以 react 的渲染基本是达到最优渲染，比人为的操作 DOM 省心多了。</p><h2 id="React-组件的数据"><a href="#React-组件的数据" class="headerlink" title="React 组件的数据"></a>React 组件的数据</h2><p>React 组件的数据分为两种，props 和 state，无论 props 或者 state 的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用 prop?什么时候选择用 state 呢?其实原则很简单，props 是组件的对外接口，state 是组件的内部状态，对外用 props，内部用 state。</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>在 React 中，props 是从外部传递给组件的数据，一个 React 组件通过定义自己能够接受的 props 就定义了自己的对外公共接口。<br>每个 React 组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过 props 来和组件对话的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 给prop赋值</span><br><span class="line">&lt;Demo <span class="built_in">test</span>=&#123;100&#125; /&gt;</span><br><span class="line"></span><br><span class="line">// 读取props</span><br><span class="line">class Demo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.props;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于是对外公布的接口，那么传入时应该有自己的一套规则，如前端与后端人员对接时后端人员都会对自己的接口，公布一份接口文档，方便人员的对接，而不是让对接人员自己猜想传什么字段，才能正常使用接口，而 props 就需要这样做，使用<a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">propTypes</a>规范接口，让使用组件的人员一目了然，知道组件需要什么字段。</p><p>而 propTypes 是一种限制，会在运行时与静态代码时检查代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Demo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.props;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="built_in">test</span>字符串并必须传入</span><br><span class="line">Demo.propTypes = &#123;</span><br><span class="line">    <span class="built_in">test</span>: PropTypes.string.isRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何没有传入，浏览器的控制台会报错，但不影响运行</span><br></pre></td></tr></table></figure><p>但由于 props 不一定都要传入，这样可以使用 defaultProps 设置默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Demo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.props;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Demo.defaultProps = &#123;</span><br><span class="line">    <span class="built_in">test</span>: <span class="string">'测试'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">class Demo extends Component &#123;</span><br><span class="line">    static defaultProps&#123;</span><br><span class="line">        <span class="built_in">test</span>: <span class="string">'测试'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.props;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果你是使用typescript编写的项目，那么就可以不使用propTypes，typescript特性就是静态类型检查。</span><br></pre></td></tr></table></figure><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>由于 React 组件不能修改传入的 props，所以需要记录自身数据变化，就要使用 state。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Demo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            <span class="built_in">test</span>: props.test</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.state;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 state 的修改需要使用特定函数，this.setState()进行修改，才能触发 view 与 data 的同步更新，若直接对 this.state 对象进行赋值操作，是不会触发的，但对象里的值是发生了改变，只是没有更新视图，当触发 this.setState()会把变化更新，所以修改一定要使用 this.setState。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Demo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            <span class="built_in">test</span>: props.test</span><br><span class="line">        &#125;</span><br><span class="line">        this.changeFn = this.changeFn.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    changeFn(event)&#123;</span><br><span class="line"></span><br><span class="line">        this.setState(&#123;<span class="built_in">test</span>: event.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.state;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">            &lt;input value=&#123;<span class="built_in">test</span>&#125; onChange=&#123;changeFn&#125; <span class="built_in">type</span>=<span class="string">'text'</span> /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：<br>装载过程，也就是把组件第一次在 DOM 树中渲染的过程；<br>更新过程，当组件被重新渲染的过程；<br>卸载过程，组件从 DOM 中删除的过程。<br>三种不同的过程，React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。</p><p>装载过程中会触发:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor</span><br><span class="line">getlnitialState</span><br><span class="line">getDefaultProps</span><br><span class="line">static getDerivedStateFromProps</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><p>getlnitialState 与 getDefaultProps 在 React.createClass 中有效，在 ES6 中不能使用这个，所以一般都不使用。<br>constructor，初始化的操作都会在这里进行，如 this.state，事件处理函数的 this 绑定等。<br>render 函数无疑是 React 组件中最重要的函数，一个 React 组件可以忽略其他所有函数都不实现，但是一定要实现 render 函数，因为所有 React 组件的父类 React.Component 类对除 render 之外的生命周期函数都有默认实现。<br>componentDidMount 是 render 函数执行后 DOM 加载出来才触发的，所以对操作 DOM 或数据请求都可以在这里进行。</p><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容,但此方法无法访问组件实例，因为它是一个静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; email: props.email &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    if (props.email !== state.email) &#123;</span><br><span class="line">      return &#123; email: props.email &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        Email: &lt;input value=&#123;this.state.email&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新过程会触发:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 依次触发</span><br><span class="line">static getDerivedStateFromProps</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">render</span><br><span class="line">getSnapshotBeforeUpdate</span><br><span class="line">componentDidUpdate</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            <span class="built_in">test</span>: <span class="string">"aaa"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.state;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;Child <span class="built_in">test</span>=&#123;<span class="built_in">test</span>&#125;/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.props;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shouldComponentUpdate 是对数据的改变是否触发 render 来更新视图的，对性能优化很重要，它决定了一个组件什么时候不需要渲染。<br>当它返回 false 时不渲染，为 true 渲染，默认时都为 true 的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            <span class="built_in">test</span>: <span class="string">"aaa"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.state;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;Child <span class="built_in">test</span>=&#123;<span class="built_in">test</span>&#125;/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">        &#123;<span class="built_in">test</span>&#125; = nextProps;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">test</span> === this.props.test)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        <span class="built_in">let</span> &#123;<span class="built_in">test</span>&#125; = this.props;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="built_in">test</span>&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    // 我们是否在 list 中添加新的 items ?</span><br><span class="line">    // 捕获滚动​​位置以便我们稍后调整滚动位置。</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      return list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span><br><span class="line">    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span><br><span class="line">    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span><br><span class="line">    if (snapshot !== null) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>componentDidUpdate 既渲染后的钩子函数。</p><p>卸载过程只涉及一个函数 componentWillUnmount，为了在组件被卸载进行一些操作，避免造成污染之类的，如内存溢出。</p><h3 id="即将废弃的钩子"><a href="#即将废弃的钩子" class="headerlink" title="即将废弃的钩子"></a>即将废弃的钩子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount</span><br><span class="line">componentWillUpdate</span><br><span class="line">componentWillReceiveProps</span><br></pre></td></tr></table></figure><p>componentWillMount 组件初始化时会出现在 constructor 后 render 前。</p><p>componentWillUpdate 组件状态更新时会触发，在 render 之前。</p><p>componentWillReceiveProps 组件初始化不会触发，但父组件的状态更新就会触发。</p><p>由于 react 团队启用异步渲染方式，把一些长期被使用者不正当使用的生命周期钩子都准备弃用，以达到未来更新的版本更完善做准备。</p><p><a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">资料</a></p><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops" target="_blank" rel="noopener">资料 2</a></p><p><a href="https://github.com/793338023/react-antd-typescript" target="_blank" rel="noopener">例子项目</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-的安装&quot;&gt;&lt;a href=&quot;#react-的安装&quot; class=&quot;headerlink&quot; title=&quot;react 的安装&quot;&gt;&lt;/a&gt;react 的安装&lt;/h2&gt;&lt;p&gt;由于 react 的需要依赖一些的技术栈才能方便进行正常的开发，但这对学习它的成本会</summary>
      
    
    
    
    
    <category term="react" scheme="https://793338023.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>javascript事件循环</title>
    <link href="https://793338023.github.io/2019/02/19/javascript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1/"/>
    <id>https://793338023.github.io/2019/02/19/javascript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1/</id>
    <published>2019-02-19T08:06:39.000Z</published>
    <updated>2020-09-19T07:59:07.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-的事件循环"><a href="#JavaScript-的事件循环" class="headerlink" title="JavaScript 的事件循环"></a>JavaScript 的事件循环</h2><p>简单了解一下浏览器的 js 事件循环，由于涉及到浏览器版本不一样结果不一样，既参考。</p><p>首先要理解一下:</p><ol><li>js 的执行分同步与异步</li><li>在执行 js 时首先执行整体代码的同步代码，然后异步代码处理完后会把回调函数放置到任务队列里等待执行栈执行完后，将任务队列的任务添加到执行栈里执行</li><li>事件循环是通过任务队列的机制进行协调的，一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；<strong>每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。</strong> setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。</li><li>任务队列的执行顺序又分为宏任务队列和微任务任务，微任务队列都在当前宏任务执行完毕之后立刻执行，然后才会执行浏览器的渲染。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="eventLoop.png" alt="js事件循环" title="">                </div>                <div class="image-caption">js事件循环</div>            </figure><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。<br>宏任务主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>微任务可以理解是在当前宏任务执行结束后立即执行的任务。也就是说，在当前宏任务任务后，下一个宏任务之前，在渲染之前。</p><p>所以它的响应速度相比 setTimeout（setTimeout 是宏任务）会更快，因为无需等渲染。也就是说，在某一个宏任务执行完后，就会将在它执行期间产生的所有微任务都执行完毕（在渲染前）。</p><p>微任务主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</p><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ol><li>执行当前宏任务(当前宏任务从任务队列里获取)</li><li>在执行栈中遇到微任务，把它放置到微任务队列里，遇到宏任务把它放置宏任务队列</li><li>当前执行的宏任务结束，检查微任务队列，如果有任务，则有序的执行微任务，否则执行下一步</li><li>浏览器开始检查渲染，然后 GUI 线程接管渲染</li><li>渲染完毕后，js 线程接管，继续重第一步执行代码</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript事件循环-1\pp.jpg" alt="运行机制" title="">                </div>                <div class="image-caption">运行机制</div>            </figure><p>以下为测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async1</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async2</span></span>() &#123;</span><br><span class="line">    //async2做出如下更改：</span><br><span class="line">    new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, 0)</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'promise3'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise4'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">promise4</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaScript-的事件循环&quot;&gt;&lt;a href=&quot;#JavaScript-的事件循环&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 的事件循环&quot;&gt;&lt;/a&gt;JavaScript 的事件循环&lt;/h2&gt;&lt;p&gt;简单了解一下浏览器的 js </summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>复杂vue路由</title>
    <link href="https://793338023.github.io/2019/02/10/%E5%A4%8D%E6%9D%82vue%E8%B7%AF%E7%94%B1/"/>
    <id>https://793338023.github.io/2019/02/10/%E5%A4%8D%E6%9D%82vue%E8%B7%AF%E7%94%B1/</id>
    <published>2019-02-10T14:36:38.000Z</published>
    <updated>2019-02-10T15:25:54.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步状态"><a href="#异步状态" class="headerlink" title="异步状态"></a>异步状态</h2><p>问题:<br>异步状态会引入不确定性，代码执行结果的正确与否完全靠运气或者靠网速。而无法确定异步代码的执行阶段，在多个组件或代码块之间耦合情况下会出现代码执行错误情况，怎么办？</p><p>为了应对各种各样的需求，我们在写任何存在异步任务的代码时，都要提前做好流程设计，要确保代码的运行是严格符合期望的。<br>而大部分的需求都可以使用vue-router的这种方案解决掉，而这个方案无法解决的时候，那么就要清楚js的执行机制，那么就可以比较准确的知道什么时候执行那一块代码，具体如下:<br>1、首先要列出所有需要异步操作的代码<br>2、分析他们之间的依赖关系，以此决定请求的顺序<br>3、根据这个顺序，并结合Vue组件的父子关系，决定这些异步代码的存放位置<br>4、不断在脑海里过Vue的执行流程，不断完善代码，弥补纰漏<br>5、最后要确保，在nextTick、setTimeout、ajax、Promise等交织在一起的代码里，自己能预测出任意位置代码的执行时机</p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a><a href="https://router.vuejs.org/zh/guide/advanced/data-fetching.html" target="_blank" rel="noopener">vue-router</a></h2><p>在使用vue-router实现获取数据时有两种获取数据的方式。<br>1、导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子(created\mounted)中获取数据。在数据获取期间显示“加载中”之类的指示。<br>2、导航完成之前获取：导航完成前，在路由进入的路由钩子(<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">beforeRouteEnter\beforeRouteUpdate\beforeRouteLeave</a>)中获取数据，在数据获取成功后执行导航。</p><p>beforeRouteEnter\beforeRouteUpdate\beforeRouteLeave钩子都是即将进入的路由组件里的编写，如从A页面进入B页面，那么钩子就在B页面的编写钩子，由于执行beforeRouteEnter时组件还有初始化，所以无法使用this，beforeRouteUpdate时组件被复用时调用的，如路由的方式为\B\:id，这种路由的组件是会被复用的，所以只会触发beforeRouteUpdate，而beforeRouteLeave是当前页面在离开是调用的，如何使用它制作是否确认离开的，而他们都是要调用next()，否则都无法进入路由。</p><p>beforeRouteEnter的next方法的回调可以获取到当前组件的this，可以使用它设置data。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url: <span class="string">"/api/v2/movie/subject/"</span> + to.params.id,</span><br><span class="line">    method: <span class="string">"get"</span></span><br><span class="line">  &#125;).<span class="keyword">then</span>(rps =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> data = rps.data;</span><br><span class="line">    next(vm =&gt; &#123;</span><br><span class="line">      vm.item = data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate(to, from, next) &#123;</span><br><span class="line">  console.log(<span class="string">"beforeRouteUpdate"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">  console.log(<span class="string">"beforeRouteLeave"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由缓存与scrollBehavior"><a href="#路由缓存与scrollBehavior" class="headerlink" title="路由缓存与scrollBehavior"></a>路由缓存与scrollBehavior</h2><p>由于确保前进后退时回看自己之前的内容，而不是重新刷新，实现缓存功能。<br>有时浏览一个内容后点击了页面的内容进入了下一个页面查看，但想回到之前的页面继续看，而不是后退后等待刷新后重新查看之前浏览的内容，但这个的实现就要keep-alive与scrollBehavior结合使用，但这个方案需要了解scrollBehavior的执行阶段，而scrollBehavior函数在组件的生命周期mounted后beforeUpdate前执行，所以要在route组件参数meta里先设置是否缓存的参数，然后v-if在router-view里显示是否缓存的组件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=<span class="string">"<span class="variable">$route</span>.meta.isKeepAlive"</span>/&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">  &lt;router-view v-if=<span class="string">"!<span class="variable">$route</span>.meta.isKeepAlive"</span>/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>isKeepAlive是否缓存，先设置下一次路由到该页面后是否缓存。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Router from <span class="string">'vue-router'</span></span><br><span class="line">import hotShow from <span class="string">'@/views/hotShow'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'hotShow'</span>,</span><br><span class="line">      component: hotShow,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        isKeepAlive: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/product/:id'</span>,</span><br><span class="line">      name: <span class="string">'product'</span>,</span><br><span class="line">      component: () =&gt; import(<span class="string">'@/views/detail'</span>),</span><br><span class="line">      meta: &#123;</span><br><span class="line">        isKeepAlive: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  // 设置只缓存后退，当前进或进入后不缓存</span><br><span class="line">  scrollBehavior(to, from, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (savedPosition || typeof savedPosition === <span class="string">'undefined'</span>) &#123;      // 只处理设置了路由元信息的组件</span><br><span class="line">      from.meta.isKeepAlive = typeof from.meta.isKeepAlive === <span class="string">'undefined'</span> ? undefined : <span class="literal">false</span></span><br><span class="line">      to.meta.isKeepAlive = typeof to.meta.isKeepAlive === <span class="string">'undefined'</span> ? undefined : <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">        <span class="built_in">return</span> savedPosition;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      from.meta.isKeepAlive = typeof from.meta.isKeepAlive === <span class="string">'undefined'</span> ? undefined : <span class="literal">true</span></span><br><span class="line">      to.meta.isKeepAlive = typeof to.meta.isKeepAlive === <span class="string">'undefined'</span> ? undefined : <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="测试过程问题"><a href="#测试过程问题" class="headerlink" title="测试过程问题"></a>测试过程问题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">报错:</span><br><span class="line">Cannot convert undefined or null to object</span><br><span class="line"></span><br><span class="line">Object.keys()中传错了参数</span><br><span class="line">由于undefined和null无法转成对象，所以如果它们做为Object.assign()的参数（只有一个参数），也会报错</span><br></pre></td></tr></table></figure><p><a href="https://github.com/793338023/vue-routerTest" target="_blank" rel="noopener">完整代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异步状态&quot;&gt;&lt;a href=&quot;#异步状态&quot; class=&quot;headerlink&quot; title=&quot;异步状态&quot;&gt;&lt;/a&gt;异步状态&lt;/h2&gt;&lt;p&gt;问题:&lt;br&gt;异步状态会引入不确定性，代码执行结果的正确与否完全靠运气或者靠网速。而无法确定异步代码的执行阶段，在多个组件或</summary>
      
    
    
    
    
    <category term="vue" scheme="https://793338023.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>transform与matrix</title>
    <link href="https://793338023.github.io/2019/02/06/transform%E4%B8%8Ematrix/"/>
    <id>https://793338023.github.io/2019/02/06/transform%E4%B8%8Ematrix/</id>
    <published>2019-02-06T04:57:54.000Z</published>
    <updated>2019-02-06T06:40:30.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transform的值大类"><a href="#Transform的值大类" class="headerlink" title="Transform的值大类"></a>Transform的值大类</h2><p>transform 本质上来说是一系列的变形函数，主要有以下值：<br>none -  不进行转换，常用作覆盖别的值使用<br>translate(x,y) - 2d位移；translate3d(x,y,z) - 3d位移； transformX/Y/Z(n) - 单向位移<br>scale(x,y) - 2d缩放； scale3d(x,y,z) - 3d缩放； scaleX/Y(n) - 单向缩放<br>rotate(angle) - 2d旋转； rotate3d(x,y,z,angle) - 3d旋转；rotateX/Y/Z(angle) - 单向旋转<br>skew(x-angle,y-angle) - 倾斜变换； skewX/Y(angle) - 单向倾斜变换<br>matrix[3d] - 矩阵<br>perspective(n) - 视距（值）</p><h2 id="Transform的前置属性"><a href="#Transform的前置属性" class="headerlink" title="Transform的前置属性"></a>Transform的前置属性</h2><p>transform-origin - 变换原点<br>transform-style - 变换类型<br>perspective - 3d透视视图的视距（属性）<br>perspective-origin - 视距的基点<br>backface-visibility - 是否可以看见背面</p><h2 id="Transform特性"><a href="#Transform特性" class="headerlink" title="Transform特性"></a>Transform特性</h2><p>1、如果是动画效果，translate能达到比1px更小的过渡效果，而position却不行，这就影响了用户体验。<br>2、translate的动画效果能启用电脑GPU加速，分离图层，大大减少页面重绘模块，节省资源。<br>3、position 的可拓展性不如 translate等。<br>4、transform百分比的基准是被设置值的本身容器，而不是像margin等以父级为基准。<br>5、3d效果需要使用在父级使用perspective，否则设置的值无效。</p><h2 id="矩阵-matrix"><a href="#矩阵-matrix" class="headerlink" title="矩阵 - matrix"></a>矩阵 - matrix</h2><p>线性代数里矩阵<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|1 0 0|</span><br><span class="line">|1 0 0|</span><br><span class="line">|2 0 0|</span><br><span class="line"></span><br><span class="line">transform: matrix(a,b,c,d,e,f);</span><br><span class="line"></span><br><span class="line">|a b c|</span><br><span class="line">|d e f|</span><br><span class="line">|0 0 1|</span><br></pre></td></tr></table></figure></p><p>当我们要做变换时，实质上就是对初始值添加一些系数，也就是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|a c e|   |x|    |ax cy e|</span><br><span class="line">|b d f| * |y| =  |bx dy f|</span><br><span class="line">|0 0 1|   |1|    |0  0  1|</span><br></pre></td></tr></table></figure></p><p>而变化后的x与y坐标<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x<span class="string">' = ax + cy +  e   // 即：x坐标</span></span><br><span class="line"><span class="string">y'</span> = bx + dy + f    // 即：y坐标</span><br></pre></td></tr></table></figure></p><p>默认值:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix(1, 0, 0, 1, 0, 0)</span><br><span class="line">// 在默认基础上继续变化</span><br></pre></td></tr></table></figure></p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">matrix(a,b,c,d,e,f);</span><br><span class="line">// 只需要变换e,f即可，e为x，f为y</span><br><span class="line">// 如</span><br><span class="line">transform: matrix(1, 0, 0, 1, 10, 20);</span><br><span class="line">// x为10px,y为20px</span><br></pre></td></tr></table></figure><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">matrix(a,b,c,d,e,f);</span><br><span class="line">// 只需要变换a,d即可，a为x，d为y，既放大缩小多少倍，如果在是正常倍数，设置为1即可,否则图形会消失，如设置为0了</span><br><span class="line">// 如</span><br><span class="line">transform: matrix(2, 0, 0, 2, 0, 0);</span><br><span class="line">// x为2倍,y为2倍</span><br></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>由于旋转需要使用到三角函数，cos与sin，而且matrix(a,b,c,d,e,f)中要使用都abcd。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'matrix('</span>+Math.cos(x)+<span class="string">', '</span>+Math.sin(x)+<span class="string">', -'</span>+Math.sin(x)+<span class="string">', '</span>+Math.cos(x)+<span class="string">', 0, 0)'</span></span><br><span class="line"></span><br><span class="line">// 三角函数的转换</span><br><span class="line"><span class="built_in">let</span> x = 2 * Math.PI / 360 * angle;</span><br></pre></td></tr></table></figure><p>例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;button @click=<span class="string">'btnFn'</span>&gt;开始&lt;/button&gt;</span><br><span class="line">    &lt;div class=<span class="string">"wrapper"</span>&gt;</span><br><span class="line">      &lt;div ref=<span class="string">"item"</span> class=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      timer: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    transFn(angle = 0)&#123;</span><br><span class="line">      <span class="built_in">let</span> item = this.<span class="variable">$refs</span>.item;</span><br><span class="line">      <span class="built_in">let</span> x = 2 * Math.PI / 360 * angle;</span><br><span class="line">      item.style.transform = <span class="string">'matrix('</span>+Math.cos(x)+<span class="string">', '</span>+Math.sin(x)+<span class="string">', -'</span>+Math.sin(x)+<span class="string">', '</span>+Math.cos(x)+<span class="string">', 0, 0)'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    move(start, end)&#123;</span><br><span class="line">      clearInterval(this.timer);</span><br><span class="line">      this.timer = setInterval(()=&gt;&#123;</span><br><span class="line">        this.transFn(start);</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">          clearInterval(this.timer);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          start+= 2;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 100);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">btnFn</span></span>()&#123;</span><br><span class="line">      this.move(0, 360);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.wrapper &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 500px;</span><br><span class="line">  perspective: 100px; </span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">  background-color: <span class="comment">#42b983;</span></span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  transform: matrix(2, 0, 0, 2, 0, 0);</span><br><span class="line">  transform-origin: 0 0 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h3 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h3><p>由于旋转需要使用到三角函数，tan，而且matrix(a,b,c,d,e,f)中要使用都bc。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix(1,tan(θy),tan(θx),1,0,0)</span><br><span class="line">// 三角函数的转换</span><br><span class="line"><span class="built_in">let</span> x = 2 * Math.PI / 360 * angle;</span><br><span class="line"><span class="built_in">let</span> θ = Math.tan(x);</span><br><span class="line">// 30度</span><br><span class="line">transform: matrix(1, 0.5, 0.5, 1, 0, 0);</span><br></pre></td></tr></table></figure><p>以上是对单种变换的matrix使用，若要多个一起使用就要按顺序使用上述的方法累加起来，所以在使用transform是变换使用都会根据使用的变换顺序不同而达到的结果不一样，因为它会根据前一个变换后的结果进行下一次的变换，如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(30deg) translate(10px, 20px);</span><br><span class="line"></span><br><span class="line">transform: translate(10px, 20px) rotate(30deg);</span><br></pre></td></tr></table></figure></p><p>以上的数值都一致，但结果是不一样的。<br>第一个为旋转后根据旋转的方向进行移动<br>第二个为移动后再进行旋转</p><p><a href="https://www.html.cn/tool/css3Preview/Transform-Matrix.html" target="_blank" rel="noopener">matrix 工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Transform的值大类&quot;&gt;&lt;a href=&quot;#Transform的值大类&quot; class=&quot;headerlink&quot; title=&quot;Transform的值大类&quot;&gt;&lt;/a&gt;Transform的值大类&lt;/h2&gt;&lt;p&gt;transform 本质上来说是一系列的变形函数，主</summary>
      
    
    
    
    
    <category term="css3" scheme="https://793338023.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>__proto__与prototype</title>
    <link href="https://793338023.github.io/2019/02/01/proto-%E4%B8%8Eprototype/"/>
    <id>https://793338023.github.io/2019/02/01/proto-%E4%B8%8Eprototype/</id>
    <published>2019-02-01T07:36:01.000Z</published>
    <updated>2019-02-01T08:16:39.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener"><strong>proto</strong></a></h2><p>在JavaScript里面，一切皆为对象，而对象(除了null)都有<strong>proto</strong>，这个属性会指向该对象的原型，即作为实例对象和实例原型的之间的链接桥梁。<br><strong>proto</strong>属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[[Prototype]]。<br>所以直接使用它进行原型对象的操作是很不友好的，它的目的只是为了访问到原型对象里的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123;a:<span class="string">'1'</span>&#125;;</span><br><span class="line">console.log(obj.__proto__);</span><br></pre></td></tr></table></figure></p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>prototype是函数特有属性，因为实现面向对象的编程方式，需要有类似继承等属性，而原型对象即可解决此类问题，且保存javascript的灵活多变的方式。<br>函数上使用prototype，可<strong>proto</strong>变成合法的操作，而不单单只是一个访问器，可对其添加修改删除等，而在函数上<strong>proto</strong>与prototype是相等的，因为它们都指向同一个内存地址，但在实际上他们是不一样的，因为除了函数，其他对象都没有prototype属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); //<span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>##构造函数、实例对象、原型对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'proto'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> per = new Person();</span><br></pre></td></tr></table></figure></p><p>Person这个函数的prototype属性指向了一个对象,即:Person.prototype也是一个对象。这个对象正是调用该构造函数而创建的实例的原型。</p><p>既构造函数与原型对象、实例对象都是需要new一个实例对象时才能正确使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.调用的构造函数：  Person</span><br><span class="line">2.使用什么调用：    new关键字</span><br><span class="line">3.得到了什么：     实例化对象per</span><br><span class="line">4.实例化对象和原型是什么关系: per的原型就是 Person.prototype</span><br></pre></td></tr></table></figure><p>而原型就是实例对象都共享原型上的属性，而原型对象包含<strong>proto</strong>对象，指向上层原型对象，当实例对象访问某个属性时，先查询对象本身所函数的属性是否存在该属性，否则访问原型对象上的属性，而当当前原型对象不含有，则通过<strong>proto</strong>对象访问上层原型对象属性，直到访问到该属性或<strong>proto</strong>指向的顶层对象Object后停止访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;proto&quot;&gt;&lt;a href=&quot;#proto&quot; class=&quot;headerlink&quot; title=&quot;proto&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Refere</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>node-爬虫体验</title>
    <link href="https://793338023.github.io/2019/01/30/node-%E7%88%AC%E8%99%AB%E4%BD%93%E9%AA%8C/"/>
    <id>https://793338023.github.io/2019/01/30/node-%E7%88%AC%E8%99%AB%E4%BD%93%E9%AA%8C/</id>
    <published>2019-01-30T13:41:56.000Z</published>
    <updated>2019-01-30T14:16:04.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-爬虫"><a href="#node-爬虫" class="headerlink" title="node-爬虫"></a>node-爬虫</h2><p>使用技术:<br>express + crawler + request<br>而crawler是集成了request+cheerio，由于某些方面crawler没有使用request那么方便，只是在爬虫上可以比request简单的实现爬虫，所以比较强大简单，而在node里比较流行，而node实现爬虫有些不够好，所以在这方面框架没有几个，不像python那么强大而且这方面的库很多，很专业，而node的使用后发现有些不太好，而且这方面都比较简单而粗略。</p><p>爬去电影天堂的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> express = require(<span class="string">'express'</span>);</span><br><span class="line"><span class="built_in">let</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> Crawler = require(<span class="string">'crawler'</span>);</span><br><span class="line"><span class="built_in">let</span> fs = require(<span class="string">'fs'</span>);</span><br><span class="line"><span class="built_in">let</span> path = require(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">let</span> request = require(<span class="string">'request'</span>);</span><br><span class="line"><span class="built_in">let</span> mkdirs = require(<span class="string">'../util/mkdirs'</span>);</span><br><span class="line"><span class="built_in">let</span> dataUrl = path.resolve(__dirname, <span class="string">'../../data'</span>);</span><br><span class="line"><span class="built_in">let</span> root = <span class="string">'https://www.dytt8.net'</span>;</span><br><span class="line"></span><br><span class="line">/* GET home page. */</span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res, next) &#123;</span><br><span class="line">  <span class="built_in">let</span> c = new Crawler(&#123;</span><br><span class="line">        // 在每个请求处理完毕后将调用此回调函数</span><br><span class="line">        callback : <span class="keyword">function</span> (error, resData, <span class="keyword">done</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                console.log(error);</span><br><span class="line">                res.render(<span class="string">'index'</span>, &#123; title: <span class="string">'电影天堂'</span>, content: error &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                var $ = resData.$;</span><br><span class="line">                <span class="built_in">let</span> <span class="variable">$dataList</span> = $(<span class="string">".bd3r .co_content8 ul table"</span>);</span><br><span class="line">                <span class="built_in">let</span> paging = $(<span class="string">".bd3r .co_content8 .x"</span>);</span><br><span class="line">                <span class="built_in">let</span> listData = []; </span><br><span class="line"></span><br><span class="line">                // 分页处理</span><br><span class="line">                <span class="built_in">let</span> sel = paging.find(<span class="string">'select'</span>);</span><br><span class="line">                <span class="built_in">let</span> maxLen = sel.children().length;</span><br><span class="line">                <span class="built_in">let</span> currPage = sel.find(<span class="string">'[selected]'</span>).text();</span><br><span class="line"></span><br><span class="line">                <span class="variable">$dataList</span>.each((key, item)=&gt;&#123;</span><br><span class="line">                  <span class="built_in">let</span> <span class="variable">$a</span> = $(item).find(<span class="string">'a'</span>);</span><br><span class="line">                  <span class="built_in">let</span> dac = $(item).find(<span class="string">'font'</span>).text();</span><br><span class="line">                  <span class="built_in">let</span> content = $(<span class="string">":last-child"</span>,item).find(<span class="string">'td'</span>).text();</span><br><span class="line">                  </span><br><span class="line">                  dac.match(/(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; [\d:]+)\D*(\d+)/);</span><br><span class="line">                  listData.push(&#123;<span class="string">"name"</span>: <span class="variable">$a</span>.text(),</span><br><span class="line">                                  <span class="string">"href"</span>: root+<span class="variable">$a</span>.attr(<span class="string">'href'</span>),</span><br><span class="line">                                  <span class="string">"date"</span>: RegExp.<span class="variable">$1</span>,</span><br><span class="line">                                  <span class="string">"clickNum"</span>: RegExp.<span class="variable">$2</span>,</span><br><span class="line">                                  <span class="string">"content"</span>: content</span><br><span class="line">                                &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                createFs(currPage, listData);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">let</span> listUrl = [];</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">let</span> i=2;i&lt;=maxLen;i++)&#123;</span><br><span class="line">                  listUrl.push(root+<span class="string">'/html/gndy/dyzz/list_23_'</span>+i+<span class="string">'.html'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                getPageNum(listUrl);</span><br><span class="line">                res.render(<span class="string">'index'</span>, &#123; title: <span class="string">'电影天堂'</span>, content: listData &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">done</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  // 将一个URL加入请求队列，并使用默认回调函数</span><br><span class="line">  c.queue(root+<span class="string">'/html/gndy/dyzz/list_23_1.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 获取当前页的数据</span><br><span class="line"><span class="keyword">function</span> getPageNum(listUrl)&#123;</span><br><span class="line">  <span class="built_in">let</span> c = new Crawler(&#123;</span><br><span class="line">    // 在每个请求处理完毕后将调用此回调函数</span><br><span class="line">    callback : <span class="keyword">function</span> (error, resData, <span class="keyword">done</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(error)&#123;</span><br><span class="line">            console.log(error);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            var $ = resData.$;</span><br><span class="line">            <span class="built_in">let</span> <span class="variable">$dataList</span> = $(<span class="string">".bd3r .co_content8 ul table"</span>);</span><br><span class="line">            <span class="built_in">let</span> paging = $(<span class="string">".bd3r .co_content8 .x"</span>);</span><br><span class="line">            <span class="built_in">let</span> listData = []; </span><br><span class="line"></span><br><span class="line">            // 分页处理</span><br><span class="line">            <span class="built_in">let</span> sel = paging.find(<span class="string">'select'</span>);</span><br><span class="line">            <span class="built_in">let</span> maxLen = sel.children().length;</span><br><span class="line">            <span class="built_in">let</span> currPage = sel.find(<span class="string">'[selected]'</span>).text();</span><br><span class="line"></span><br><span class="line">            <span class="variable">$dataList</span>.each((key, item)=&gt;&#123;</span><br><span class="line">              <span class="built_in">let</span> <span class="variable">$a</span> = $(item).find(<span class="string">'a'</span>);</span><br><span class="line">              <span class="built_in">let</span> dac = $(item).find(<span class="string">'font'</span>).text();</span><br><span class="line">              <span class="built_in">let</span> content = $(<span class="string">":last-child"</span>,item).find(<span class="string">'td'</span>).text();</span><br><span class="line">              </span><br><span class="line">              dac.match(/(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; [\d:]+)\D*(\d+)/);</span><br><span class="line">              listData.push(&#123;<span class="string">"name"</span>: <span class="variable">$a</span>.text(),</span><br><span class="line">                              <span class="string">"href"</span>: root+<span class="variable">$a</span>.attr(<span class="string">'href'</span>),</span><br><span class="line">                              <span class="string">"date"</span>: RegExp.<span class="variable">$1</span>,</span><br><span class="line">                              <span class="string">"clickNum"</span>: RegExp.<span class="variable">$2</span>,</span><br><span class="line">                              <span class="string">"content"</span>: content</span><br><span class="line">                            &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            createFs(currPage, listData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 将一个URL加入请求队列，并使用默认回调函数</span><br><span class="line">c.queue(listUrl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历当前页的条数</span><br><span class="line">async <span class="keyword">function</span> createFs(page, content)&#123;</span><br><span class="line">  <span class="built_in">let</span> url =  path.join(dataUrl,<span class="string">'./'</span>+page);</span><br><span class="line">  <span class="built_in">let</span> file = path.join(url, <span class="string">'./mkdir.json'</span>); </span><br><span class="line">  // 如果不存在创建目录，支持多层创建，异步</span><br><span class="line">  await mkdirs(url);</span><br><span class="line">  await (()=&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      fs.writeFile(file, JSON.stringify(content), (err)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          resolve(<span class="literal">false</span>);</span><br><span class="line">          console.log(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          resolve(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> p;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> item of content)&#123;</span><br><span class="line">    detailContent(item, url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取具体信息</span><br><span class="line">async <span class="keyword">function</span> detailContent(item, rootUrl)&#123;</span><br><span class="line">  <span class="built_in">let</span> dirUrl = path.join(rootUrl,<span class="string">'./'</span>+item.name.replace(/[\\\/:*?<span class="string">"&lt;&gt;|]/g,"</span>-<span class="string">"));</span></span><br><span class="line"><span class="string">  let file = path.join(dirUrl,'./detail.json');</span></span><br><span class="line"><span class="string">  await mkdirs(dirUrl);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  let c = new Crawler(&#123;</span></span><br><span class="line"><span class="string">    callback(error, resData, done)&#123;</span></span><br><span class="line"><span class="string">      if(error)&#123;</span></span><br><span class="line"><span class="string">        console.log(error);</span></span><br><span class="line"><span class="string">      &#125;else&#123;</span></span><br><span class="line"><span class="string">        let data = &#123;&#125;;</span></span><br><span class="line"><span class="string">        let $ = resData.$;</span></span><br><span class="line"><span class="string">        let <span class="variable">$content</span> = <span class="variable">$('.bd3r .co_area2')</span>;</span></span><br><span class="line"><span class="string">        let contentStr = <span class="variable">$content</span>.find('#Zoom p').eq(0).text();</span></span><br><span class="line"><span class="string">        let imgList = [];</span></span><br><span class="line"><span class="string">        data.title = <span class="variable">$content</span>.find('.title_all font').text();</span></span><br><span class="line"><span class="string">        data.content = contentStr.substr(0,contentStr.indexOf('【下载地址】'));</span></span><br><span class="line"><span class="string">        <span class="variable">$content</span>.find('#Zoom img').each(function(key, it)&#123;</span></span><br><span class="line"><span class="string">          imgList.push(<span class="variable">$(it)</span>.attr('src'));</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        data.img = imgList;</span></span><br><span class="line"><span class="string">        data.magnet = <span class="variable">$content</span>.find('[href^="</span>magnet<span class="string">"]').attr('href');</span></span><br><span class="line"><span class="string">        data.thunder = <span class="variable">$content</span>.find('[vkorgxpv]').attr('vkorgxpv');</span></span><br><span class="line"><span class="string">        fs.writeFile(file, JSON.stringify(data), err=&gt;&#123;</span></span><br><span class="line"><span class="string">          if(err)&#123;</span></span><br><span class="line"><span class="string">            console.log(err);</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        // getImg(JSON.stringify(imgList), dirUrl);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      done();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">  c.queue(item.href);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 图片下载处理</span></span><br><span class="line"><span class="string">// 由于某些问题无法正确获取到图片,并且会报错而无法爬取下去</span></span><br><span class="line"><span class="string">function getImg(imgList, dirUrl)&#123;</span></span><br><span class="line"><span class="string">  // var c = new Crawler(&#123;</span></span><br><span class="line"><span class="string">  //     encoding:null,</span></span><br><span class="line"><span class="string">  //     jQuery:false,// set false to suppress warning message.</span></span><br><span class="line"><span class="string">  //     callback:function(err, res, done)&#123;</span></span><br><span class="line"><span class="string">  //         if(err)&#123;</span></span><br><span class="line"><span class="string">  //             console.error(err.stack);</span></span><br><span class="line"><span class="string">  //         &#125;else&#123;</span></span><br><span class="line"><span class="string">  //           console.log(res.options.filename);</span></span><br><span class="line"><span class="string">  //           console.log(res.body);</span></span><br><span class="line"><span class="string">  //             fs.createWriteStream(res.options.filename).write(res.body);</span></span><br><span class="line"><span class="string">  //         &#125;</span></span><br><span class="line"><span class="string">  //         done();</span></span><br><span class="line"><span class="string">  //     &#125;</span></span><br><span class="line"><span class="string">  // &#125;);</span></span><br><span class="line"><span class="string">  imgList = JSON.parse(imgList);</span></span><br><span class="line"><span class="string">  imgList = imgList.map((item, key)=&gt;&#123;</span></span><br><span class="line"><span class="string">    return &#123;uri: item, filename: path.join(dirUrl,"</span>./<span class="string">"+key+"</span>.jpg<span class="string">")&#125;;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">  // c.queue(imgList);</span></span><br><span class="line"><span class="string">  for(let ii = 0; ii&lt;imgList.length; ii++)&#123;</span></span><br><span class="line"><span class="string">    if(!fs.existsSync(imgList[ii].filename))&#123;</span></span><br><span class="line"><span class="string">      setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="string">        let options = &#123;</span></span><br><span class="line"><span class="string">          url: imgList[ii].uri,</span></span><br><span class="line"><span class="string">          headers: &#123;</span></span><br><span class="line"><span class="string">            'content-length': 1001976</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        request(options).pipe(fs.createWriteStream(imgList[ii].filename)).on('close',function()&#123;</span></span><br><span class="line"><span class="string">          console.log("</span>关闭...<span class="string">"+imgList[ii].filename);</span></span><br><span class="line"><span class="string">          &#125;);</span></span><br><span class="line"><span class="string">      &#125;,1000);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = router;</span></span><br></pre></td></tr></table></figure></p><p>在文字爬去方面一点问题都没有，但在图片方面都各种问题出现，而图片量大时不要使用pipe，会出现0k的图片，既空图片，而且要使用异步的形式下载图片，如使用<a href="https://blog.csdn.net/davidsu33/article/details/52711892" target="_blank" rel="noopener">bagpipe或async</a>方法下载图片。</p><p>// 图片下载方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">    url: imgUrl,// 请求链接</span><br><span class="line">    encoding:null</span><br><span class="line">&#125;, (err, response, body) =&gt; &#123;</span><br><span class="line">    fs.writeFileSync(</span><br><span class="line">        imgPath, // 保存本地地址</span><br><span class="line">        body, // 保存内容</span><br><span class="line">        &#123;</span><br><span class="line">            encoding:<span class="string">'binary'</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/793338023/node-paChong" target="_blank" rel="noopener">github代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;node-爬虫&quot;&gt;&lt;a href=&quot;#node-爬虫&quot; class=&quot;headerlink&quot; title=&quot;node-爬虫&quot;&gt;&lt;/a&gt;node-爬虫&lt;/h2&gt;&lt;p&gt;使用技术:&lt;br&gt;express + crawler + request&lt;br&gt;而crawler是集</summary>
      
    
    
    
    
    <category term="node" scheme="https://793338023.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>webpack4-踩坑体验</title>
    <link href="https://793338023.github.io/2019/01/25/webpack4-%E8%B8%A9%E5%9D%91%E4%BD%93%E9%AA%8C/"/>
    <id>https://793338023.github.io/2019/01/25/webpack4-%E8%B8%A9%E5%9D%91%E4%BD%93%E9%AA%8C/</id>
    <published>2019-01-25T03:40:08.000Z</published>
    <updated>2019-01-25T15:13:18.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack4"><a href="#webpack4" class="headerlink" title="webpack4"></a><a href="http://webpack.html.cn/" target="_blank" rel="noopener">webpack4</a></h2><p>webpack4与之前的版本差别很大，当webpack每个大版本的更新，都需要重新学习一下webpack的打包功能，因为每次的大版本更新带来的一连串的别的模块的跟随更新，而上下版本之前是不兼容的。</p><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>先安装node与npm。<br>建议局部方式安装，因为webpack的版本更新很快，使用全局可能会出现不兼容的报错问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建项目文件夹</span><br><span class="line">npm init</span><br><span class="line">// 安装webpack与webpack-cli</span><br><span class="line">cnpm webpack webpack-cli --save-dev</span><br><span class="line">// 创建webpack.config.js文件，使用webpack指令时会访问到这个webpack配置文件</span><br><span class="line">// 在package.json的scripts里添加webpack指令。如</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">// 在终端执行指令npm start 就会执行局部安装的webpack指令，实现简单的打包功能</span><br></pre></td></tr></table></figure></p><h3 id="2、babel安装"><a href="#2、babel安装" class="headerlink" title="2、babel安装"></a>2、<a href="https://webpack.docschina.org/loaders/babel-loader/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">babel</a>安装</h3><p>而babel的更新也是很快的，所以之前安装babel的方式已经不符合了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cnpm install babel-cli babel-loader @babel/preset-env @babel/core --save-dev</span><br><span class="line"></span><br><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>, &#123;</span><br><span class="line">          <span class="string">"modules"</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="string">"targets"</span>: &#123;</span><br><span class="line">            <span class="string">"browsers"</span>: [<span class="string">"&gt; 1%"</span>, <span class="string">"last 2 versions"</span>, <span class="string">"not ie &lt;= 8"</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;],</span><br><span class="line">    ],   </span><br><span class="line">    <span class="string">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jb51.net/article/135225.htm" target="_blank" rel="noopener">在.babelrc配置文件中，主要是对预设（presets）和插件（plugins）进行配置</a>。<br><a href="https://babeljs.io/docs/en/babel-preset-env/" target="_blank" rel="noopener">presets</a> 预设<br>targets可以制定兼容浏览器版本，如果设置了browsers，那么就会覆盖targets原本对浏览器的限制配置。<br>targets.node正对node版本进行编译<br>modules通常都会设置为false，因为默认都是支持CommonJS规范，同时还有其他配置参数：”amd” | “umd” | “systemjs” | “commonjs”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"targets"</span>: &#123;</span><br><span class="line">    <span class="string">"chrome"</span>: 52,</span><br><span class="line">    <span class="string">"browsers"</span>: [<span class="string">"last 2 versions"</span>, <span class="string">"safari 7"</span>],</span><br><span class="line">    <span class="string">"node"</span>:<span class="string">"6.10"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"modules"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、webpack-dev-server热替换"><a href="#3、webpack-dev-server热替换" class="headerlink" title="3、webpack-dev-server热替换"></a>3、<a href="https://webpack.docschina.org/configuration/dev-server/#devserver-contentbase" target="_blank" rel="noopener">webpack-dev-server</a>热替换</h3><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack-dev-server --save-dev</span><br><span class="line">// 配置启动</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>由于热替换的直接配置webpack.config.js里的devServer下，而不是通过CLI配置，所以如hot的配置需要在配置文件添加webpack.HotModuleReplacementPlugin插件，而CLI的配置会自动添加webpack.HotModuleReplacementPlugin。<br>由于启动了热替换，为了在终端上更好的观察变化情况，需要添加<a href="https://www.jianshu.com/p/8499842defbe" target="_blank" rel="noopener">webpack.HotModuleReplacementPlugin()</a>插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        compress: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">---------------------------</span><br><span class="line">plugins: [</span><br><span class="line">    new webpack.NamedModulesPlugin(),</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="4、html-webpack-plugin自动注入"><a href="#4、html-webpack-plugin自动注入" class="headerlink" title="4、html-webpack-plugin自动注入"></a>4、html-webpack-plugin自动注入</h3><p>使用过vue的一定都对它的开发环境下自动注入很好奇，为什么热替换下没有打包浏览器观察到的文件，而浏览器的开发者模式下观察到的文件与项目下文件不一样，而且项目下没有文件打包，这就是因为html-webpack-plugin与热替换的原因。</p><p><a href="https://www.cnblogs.com/wonyun/p/6030090.html" target="_blank" rel="noopener">资料一</a><br><a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="noopener">资料二</a></p><p>以上资料已经把html-webpack-plugin的使用很详细的介绍了。</p><p>而自动注入而不生成文件的，是因为使用热替换的情况下，会把变化的文件放到热替换的开启的服务器容器里，既内存里，只会在浏览器体验到它的打包变化，实际文件是没有变化的，而html-webpack-plugin会把js文件插入html里面，那么实现以上的效果。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>package.json<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"w4"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"webpack4"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"@babel/core"</span>: <span class="string">"^7.0.0"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>: <span class="string">"^7.3.1"</span>,</span><br><span class="line">    <span class="string">"babel-cli"</span>: <span class="string">"^6.26.0"</span>,</span><br><span class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^8.0.5"</span>,</span><br><span class="line">    <span class="string">"html-webpack-plugin"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"^0.12.7"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.29.0"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.2.1"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.1.14"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>webpack.config.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(<span class="string">'webpack'</span>);</span><br><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line">const HtmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        compress: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">test</span>: /\.js$/,</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                exclude: /(node_modules|bower_components)/</span><br><span class="line">              &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.NamedModulesPlugin(),</span><br><span class="line">        new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            template: <span class="string">'index.html'</span>,</span><br><span class="line">            inject: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/793338023/webpack4Test" target="_blank" rel="noopener">github代码</a></p><p><a href="https://webpack.js.org/concepts/mode/" target="_blank" rel="noopener">webpack4</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 使用babel报错</span><br><span class="line">Cannot <span class="built_in">read</span> property <span class="string">'bindings'</span> of null</span><br><span class="line">是因为没有正常安装与配置</span><br><span class="line">解决:</span><br><span class="line">cnpm install babel-cli babel-loader @babel/preset-env @babel/core --save-dev</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line"><span class="string">"plugins"</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有由于使用babel转换要忽略这些文件</span><br><span class="line">exclude: /(node_modules|bower_components)/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;webpack4&quot;&gt;&lt;a href=&quot;#webpack4&quot; class=&quot;headerlink&quot; title=&quot;webpack4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://webpack.html.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopene</summary>
      
    
    
    
    
    <category term="webpack" scheme="https://793338023.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>css3的pointer-events</title>
    <link href="https://793338023.github.io/2019/01/21/css3%E7%9A%84pointer-events/"/>
    <id>https://793338023.github.io/2019/01/21/css3%E7%9A%84pointer-events/</id>
    <published>2019-01-21T11:19:33.000Z</published>
    <updated>2019-01-22T14:28:26.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a><a href="https://www.css88.com/book/css/properties/user-interface/pointer-events.htm" target="_blank" rel="noopener">pointer-events</a></h2><p>CSS属性 pointer-events 允许用户控制特定的图形元素在何时成为鼠标事件的 target。当未指定该属性时，SVG 内容表现如同 visiblePainted。<br>除了指定元素不成为鼠标事件的目标，none 值还指示鼠标事件穿过该元素，并指向位于元素下面的元素。</p><p>而目前pointer-events 主要的用途还是穿透元素。<br>如需要一个上层背景覆盖内容而增加页面的丰富性，但由于上层容器的层级比较高，导致无法触发下层的内容的事件，只是一件很不友好的行为，而使用了这个属性pointer-events:none，就可以达成穿透的效果。<br>如使用canvas制作下雪的效果覆盖整个屏幕当成背景效果，或操作迭代的容器，当选中下层元素，可使用这个属性，当选回后设置为pointer-events:auto即可。</p><p>兼容性:<br>IE 　11+<br>Firefox 　3.6＋<br>Chrome　4.0+<br>Safari　　6.0<br>Opera　 15.0<br>iOS Safari 6.0<br>Android Browser　2.1+<br>Android Chrome　18.0+</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">'bg'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">'content'</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">'wwww.baidu.com'</span>&gt;百度&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.<span class="built_in">bg</span>&#123;</span><br><span class="line">    position:fixed;</span><br><span class="line">    top:0;</span><br><span class="line">    bottom:0;</span><br><span class="line">    left:0;</span><br><span class="line">    right:0;</span><br><span class="line">    background:rgba(0,0,0,.2);</span><br><span class="line">    z-index:10000;</span><br><span class="line">    pointer-events:none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pointer-events&quot;&gt;&lt;a href=&quot;#pointer-events&quot; class=&quot;headerlink&quot; title=&quot;pointer-events&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.css88.com/book/css/prop</summary>
      
    
    
    
    
    <category term="css3" scheme="https://793338023.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>vue骨架屏</title>
    <link href="https://793338023.github.io/2019/01/17/vue%E9%AA%A8%E6%9E%B6%E5%B1%8F/"/>
    <id>https://793338023.github.io/2019/01/17/vue%E9%AA%A8%E6%9E%B6%E5%B1%8F/</id>
    <published>2019-01-17T11:00:14.000Z</published>
    <updated>2019-01-17T15:43:58.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack-target"><a href="#webpack-target" class="headerlink" title="webpack-target"></a><a href="https://www.css88.com/doc/webpack2/concepts/targets/" target="_blank" rel="noopener">webpack-target</a></h2><p>webpack可以为js的各种不同的宿主环境提供编译功能，为了能正确的进行编译，就需要开发人员在配置里面正确的进行配置。<br>默认情况下，target的值是web，也就是为类浏览器的环境提供编译。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  target: <span class="string">'node'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="webpack-vue-ssr-webpack-plugin"><a href="#webpack-vue-ssr-webpack-plugin" class="headerlink" title="webpack-vue-ssr-webpack-plugin"></a><a href="https://www.npmjs.com/package/vue-ssr-webpack-plugin" target="_blank" rel="noopener">webpack-vue-ssr-webpack-plugin</a></h2><p>当您使用Webpack的按需代码分割功能（通过require.ensure或动态import）时，生成的服务器端捆绑包将包含多个单独的文件。此插件通过自动将这些文件打包到可传递到的单个JSON文件中来简化工作流程bundleRenderer。</p><h2 id="node-writeFileSync"><a href="#node-writeFileSync" class="headerlink" title="node-writeFileSync"></a><a href="https://www.jb51.net/article/58474.htm" target="_blank" rel="noopener">node-writeFileSync</a></h2><p>同步，既当写入完成后才进行下一步，而且会把文件里的内容覆盖为新内容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(<span class="string">'fs'</span>);</span><br><span class="line">fs.writeFileSync(filename, data, [options])</span><br></pre></td></tr></table></figure></p><h2 id="html-minifier"><a href="#html-minifier" class="headerlink" title="html-minifier"></a><a href="https://github.com/kangax/html-minifier" target="_blank" rel="noopener">html-minifier</a></h2><p>作用:压缩的文件<br>第一个参数<br>String类型， 一段html代码<br>第二个参数 options<br>这里只列了几个常用的</p><p>removeComments 默认值false；是否去掉注释<br>collapseWhitespace 默认值false；是否去掉空格<br>minifyJS 默认值false；是否压缩html里的js（使用uglify-js进行的压缩）<br>minifyCSS 默认值false；是否压缩html里的css（使用clean-css进行的压缩）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html = htmlMinifier.minify(html, &#123;</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    minifyCSS: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="vue-server-renderer"><a href="#vue-server-renderer" class="headerlink" title="vue-server-renderer"></a><a href="https://www.baidu.com/link?url=b3VnGNcxUaQbcbd1cN4TqwNnrmCCvOjQmVFZ_d97pPydHD_n3mc6ZMrCkhchC5fgPbfD8DX7g9KBzTL5MTgK4K&amp;wd=&amp;eqid=c86a6f430002b879000000065c407448" target="_blank" rel="noopener">vue-server-renderer</a></h2><p>用于 Vue2.0 的服务端渲染,既可以在node环境下把所需的内容写入html等目标文件里，实现服务器渲染功能。</p><p><a href="https://ssr.vuejs.org/api/#webpack-plugins" target="_blank" rel="noopener">插件方式</a><br>会打包成json文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const VueSSRServerPlugin = require(<span class="string">'vue-server-renderer/server-plugin'</span>)</span><br><span class="line">或</span><br><span class="line">const VueSSRClientPlugin = require(<span class="string">'vue-server-renderer/client-plugin'</span>)</span><br><span class="line"></span><br><span class="line">const plugin = new VueSSRServerPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'my-server-bundle.json'</span> // 自定义名称</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/8e7099aed792" target="_blank" rel="noopener">createBundleRenderer</a><br>使用预编译的应用程序包创建bundleRenderer。bundle参数可以是以下之一：<br>生成的bundle文件（.js或.json）的绝对路径。文件路径必须以/开头<br>由vue-ssr-webpack-plugin生成的束对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; createBundleRenderer &#125; = require(<span class="string">'vue-server-renderer'</span>)</span><br><span class="line">const bundleRenderer = createBundleRenderer(serverBundle, &#123; /* options */ &#125;)</span><br></pre></td></tr></table></figure></p><p><a href="https://ssr.vuejs.org/api/#renderer-rendertostring" target="_blank" rel="noopener">renderToString</a><br>将捆绑的应用程序复制到字符串。与renderer.renderToString相同的回调。可选的上下文对象将被传递到bundle的导出函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bundleRenderer.renderToString(&#123; url: <span class="string">'/'</span> &#125;, (err, html) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>注意:该HTML必须包含<!--vue-ssr-outlet-->, 这个createBundleRenderer函数把这行代码替换成HTML.</strong></p><p>由于webpack3与webpack4的vue-loader的差别，webpack4可以使用vue-loader15以上，所以要安装插件<a href="https://github.com/vuejs/vue-loader/issues/1238" target="_blank" rel="noopener">VueLoaderPlugin</a>，而vue-loader14既以下都不需要这个。</p><p><strong>问题</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue packages version mismatch:</span><br><span class="line">- vue@2.4.4</span><br><span class="line">- vue-template-compiler@2.5.13</span><br><span class="line">This may cause things to work incorrectly. Make sure to use the same version <span class="keyword">for</span></span><br><span class="line"> both.</span><br><span class="line">If you are using vue-loader@&gt;=10.0, simply update vue-template-compiler.</span><br><span class="line">If you are using vue-loader@&lt;10.0 or vueify, re-installing vue-loader/vueify sho</span><br><span class="line">uld bump vue-template-compiler to the latest.</span><br></pre></td></tr></table></figure></p><p>解决:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">出现这种错误之后可以使用命令，将vue的版本改成和vue-template-compiler的版本一致，使用命令</span><br><span class="line">npm install vue@2.5.13 --save，然后直接运行就可以了！</span><br></pre></td></tr></table></figure></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>config目录下建webpack.skeleton.conf.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line">const webpack = require(<span class="string">'webpack'</span>);</span><br><span class="line">const nodeExternals = require(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line">const VueSSRServerPlugin = require(<span class="string">'vue-server-renderer/server-plugin'</span>);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    target: <span class="string">'node'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        skeleton: <span class="string">'./src/skeleton/skeleton.entry.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">        publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">        libraryTarget: <span class="string">'commonjs2'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">test</span>: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'vue-style-loader'</span>,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">test</span>: /\.vue$/,</span><br><span class="line">                loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    externals: nodeExternals(&#123;</span><br><span class="line">        whitelist: /\.css$/,</span><br><span class="line">    &#125;),</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        <span class="built_in">alias</span>: &#123;</span><br><span class="line">            <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        extensions: [<span class="string">'*'</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new VueSSRServerPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'skeleton.json'</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>config目录下建skeleton.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(<span class="string">'fs'</span>);</span><br><span class="line">const &#123; resolve &#125; = require(<span class="string">'path'</span>);</span><br><span class="line">const htmlMinifier = require(<span class="string">'html-minifier'</span>);</span><br><span class="line">const createBundleRenderer = require(<span class="string">'vue-server-renderer'</span>).createBundleRenderer;</span><br><span class="line"></span><br><span class="line">// 先把vue的模板文件index.html置换成标准的模板，防止骨架屏污染</span><br><span class="line"><span class="built_in">let</span> tempData = fs.readFileSync(resolve(__dirname, <span class="string">'../temp.html'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line">fs.writeFileSync(resolve(__dirname, <span class="string">'../index.html'</span>), tempData, <span class="string">'utf-8'</span>);</span><br><span class="line">console.log(<span class="string">'模板注入完成'</span>);</span><br><span class="line">// 读取`skeleton.json`，以`index.html`为模板写入内容</span><br><span class="line">const renderer = createBundleRenderer(resolve(__dirname, <span class="string">'../dist/skeleton.json'</span>), &#123;</span><br><span class="line">    template: fs.readFileSync(resolve(__dirname, <span class="string">'../index.html'</span>), <span class="string">'utf-8'</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 把上一步模板完成的内容写入（替换）`index.html`</span><br><span class="line">renderer.renderToString(&#123;&#125;, (err, html) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 压缩文件</span><br><span class="line">    // html = htmlMinifier.minify(html, &#123;</span><br><span class="line">    //     collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    //     minifyCSS: <span class="literal">true</span>,</span><br><span class="line">    // &#125;);</span><br><span class="line">    fs.writeFileSync(resolve(__dirname, <span class="string">'../index.html'</span>), html, <span class="string">'utf-8'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(<span class="string">'骨架屏注入完成'</span>);</span><br></pre></td></tr></table></figure></p><p>根目录(既index.html的目录)下建temp.index,而且从index.html复制到temp.index里，添加注释<!--vue-ssr-outlet--><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;my-demo&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">      &lt;!--vue-ssr-outlet--&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>src目录下建seleton文件夹，里面添加seleton.vue与seleton.entry.js文件<br>seleton.vue<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"skeleton page"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"skeleton-nav"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"skeleton-swiper"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"skeleton-swiper-item item-one"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"skeleton-swiper-item item-two"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">html,body,div&#123;</span><br><span class="line">    margin:0;</span><br><span class="line">    padding:0;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  background: <span class="comment">#fff;</span></span><br><span class="line">&#125;</span><br><span class="line">.skeleton-nav &#123;</span><br><span class="line">  height: 54px;</span><br><span class="line">  background: <span class="comment">#eee;</span></span><br><span class="line">  margin-bottom: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton-swiper &#123;</span><br><span class="line">    min-height:600px;</span><br><span class="line">    max-width:1280px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton-swiper-item&#123;</span><br><span class="line">    min-height: 600px;</span><br><span class="line">    height:100%;</span><br><span class="line">    background:<span class="comment">#eee;</span></span><br><span class="line">    border-radius:5px;</span><br><span class="line">&#125;</span><br><span class="line">.item-one&#123;</span><br><span class="line">    width:20%;</span><br><span class="line">    <span class="built_in">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line">.item-two&#123;</span><br><span class="line">    width:78%;</span><br><span class="line">    <span class="built_in">float</span>:right;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>seleton.entry.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span>;</span><br><span class="line">import Skeleton from <span class="string">'./Skeleton.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default new Vue(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        Skeleton,</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">'&lt;skeleton /&gt;'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/793338023/vue-Skeleton" target="_blank" rel="noopener">github代码地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;webpack-target&quot;&gt;&lt;a href=&quot;#webpack-target&quot; class=&quot;headerlink&quot; title=&quot;webpack-target&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.css88.com/doc/webpack2/</summary>
      
    
    
    
    
    <category term="vue" scheme="https://793338023.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>es6语法使用之大全</title>
    <link href="https://793338023.github.io/2019/01/07/es6%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%A4%A7%E5%85%A8/"/>
    <id>https://793338023.github.io/2019/01/07/es6%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%A4%A7%E5%85%A8/</id>
    <published>2019-01-07T13:25:07.000Z</published>
    <updated>2019-02-01T07:44:03.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h2><p>声明let与const都是块级作用域，所以不能想var声明一样，没有变量声明提升。<br>let是声明变量，const是常量声明，不能修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 5;</span><br><span class="line">const b = 10;</span><br></pre></td></tr></table></figure></p><h2 id="块级作用域代替函数作用域"><a href="#块级作用域代替函数作用域" class="headerlink" title="块级作用域代替函数作用域"></a>块级作用域代替函数作用域</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">// 函数作用域</span><br><span class="line">var a = <span class="string">"ccc"</span>;</span><br><span class="line">&#125;)()</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">// 块级作用域</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">let</span> b = 1000;</span><br><span class="line">&#125;</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure><p>使用块级作用域就可以避免如循环后只能获取到最后一个值的情况。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3];</span><br><span class="line">arr.map((item, index)=&gt;&#123;</span><br><span class="line"><span class="built_in">return</span> item+index;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用箭头函数可以简化代码，而且this的指向问题也出现了变化，箭头函数的this上下文环境为定义函数的环境，而普通函数的this上下文环境为调用对象决定的环境。<br>如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">a</span></span>()&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a();</span><br><span class="line">// obj对象</span><br><span class="line">------------</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">a</span></span>()&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a();</span><br><span class="line">// window对象</span><br></pre></td></tr></table></figure></p><p>所以需要注意像事件调用的函数与一些对调用环境决定this指向时不要使用箭头函数，不是会出现this指向错误，<br>如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc.addEventListener((e)=&gt;&#123;console.log(this)&#125;);</span><br></pre></td></tr></table></figure></p><p>这是错误的。</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>模板字符串使用反引号 (<code></code>) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aa = <span class="string">"abc cc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> str =`</span><br><span class="line">哈哈 <span class="variable">$&#123;aa&#125;</span> 一起走</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure><h3 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h3><p>就是使用反引号 (<code></code>) 调用函数，然后传入多个参数，而第一个参数为把含有表达式的部分为分割点切割成多个值存放到数组里，后续的参数为表达式的第一个值、第二个值。。。依次传入，<br>如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> p = <span class="string">'mike'</span>,</span><br><span class="line">    age = 25;</span><br><span class="line"><span class="keyword">function</span> temp(str, ...key)&#123;</span><br><span class="line">  console.log(str);</span><br><span class="line">  console.log(key);</span><br><span class="line">  <span class="built_in">return</span> str + key;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="built_in">let</span> op = temp`that is <span class="variable">$&#123;p&#125;</span> is a <span class="variable">$&#123;age&#125;</span>`;</span><br><span class="line"></span><br><span class="line">// [<span class="string">"that is "</span>, <span class="string">" is a "</span>, <span class="string">""</span>]</span><br><span class="line">// [<span class="string">'mike'</span>, 25]</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>结构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。</p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [a,b,c,d] = [1,2,3,4]</span><br><span class="line"><span class="built_in">let</span> [v, ...k] = [0,1,2,3,4,<span class="string">'b'</span>]</span><br><span class="line">// 不完全解构</span><br><span class="line"><span class="built_in">let</span> [a,b] = [7,8,9,1]</span><br><span class="line">// 深度解构</span><br><span class="line"><span class="built_in">let</span> [[[a=<span class="string">',b='</span><span class="string">']='</span><span class="string">']='</span><span class="string">']=[[['</span>g<span class="string">','</span>v<span class="string">']],['</span>c<span class="string">']]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 数组合并</span></span><br><span class="line"><span class="string">let arr1 = ['</span>ss<span class="string">','</span>rr<span class="string">','</span>vvv<span class="string">'];</span></span><br><span class="line"><span class="string">let arr2 = ['</span>ccc<span class="string">','</span>kkk<span class="string">','</span>hhh<span class="string">'];</span></span><br><span class="line"><span class="string">let cArr = [...arr1, ...arr2];</span></span><br></pre></td></tr></table></figure><h3 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;a&#125; = &#123;a:1,b:2&#125;</span><br><span class="line"><span class="built_in">let</span> &#123;a:&#123;b:&#123;c=<span class="string">''</span>&#125;=<span class="string">''</span>&#125;=<span class="string">''</span>,a&#125; = &#123;a:&#123;b:&#123;c:10&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">// 对象合并</span><br><span class="line"><span class="built_in">let</span> obj1 = &#123;p:<span class="string">"vvv"</span>,cc:<span class="string">"ccc"</span>&#125;</span><br><span class="line"><span class="built_in">let</span> obj2 = &#123;o:<span class="string">"dddd"</span>&#125;</span><br><span class="line"><span class="built_in">let</span> obj = &#123; ...obj1, ...obj2 &#125;</span><br><span class="line">// 变量重命名</span><br><span class="line"><span class="built_in">let</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;</span><br></pre></td></tr></table></figure><p>对象解构，左边的变量名对应右边的键值名</p><h2 id="增强的对象字面量"><a href="#增强的对象字面量" class="headerlink" title="增强的对象字面量"></a>增强的对象字面量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aa = <span class="string">'ooo'</span>;</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">aa</span><br><span class="line">&#125;;</span><br><span class="line">// 动态</span><br><span class="line"><span class="built_in">let</span> tt = <span class="string">'cc'</span>;</span><br><span class="line"><span class="built_in">let</span> ff = <span class="string">'rr'</span>;</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">[tt+<span class="string">"#"</span>+ff]: <span class="string">'ccc'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的拓展方法"><a href="#数组的拓展方法" class="headerlink" title="数组的拓展方法"></a>数组的拓展方法</h2><p>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener">keys</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">"a"</span>, , <span class="string">"c"</span>];</span><br><span class="line">console.log([...arr.keys()]);</span><br><span class="line">console.log(Object.keys(arr));</span><br></pre></td></tr></table></figure></p><p>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener">entries</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">'r'</span>,<span class="string">'p'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">let</span> itr = arr.entries();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> a of itr)&#123;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* [0, <span class="string">"r"</span>]</span><br><span class="line">* [1, <span class="string">"p"</span>]</span><br><span class="line">* [2, <span class="string">"c"</span>]</span><br><span class="line">**/</span><br></pre></td></tr></table></figure></p><p>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="noopener">values</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">"a"</span>, , <span class="string">"c"</span>];</span><br><span class="line">console.log([...arr.values()]);</span><br><span class="line">console.log(Object.values(arr));</span><br></pre></td></tr></table></figure></p><p>4、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener">includes</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(array1.includes(2));</span><br><span class="line">// expected output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var pets = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>];</span><br><span class="line"></span><br><span class="line">console.log(pets.includes(<span class="string">'cat'</span>));</span><br><span class="line">// expected output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">console.log(pets.includes(<span class="string">'at'</span>));</span><br><span class="line">// expected output: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>5、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">find</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line">var found = array1.find(<span class="keyword">function</span>(element) &#123;</span><br><span class="line">  <span class="built_in">return</span> element &gt; 10;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(found);</span><br><span class="line">// expected output: 12</span><br></pre></td></tr></table></figure></p><p>6、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" target="_blank" rel="noopener">findIndex</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> findFirstLargeNumber(element) &#123;</span><br><span class="line">  <span class="built_in">return</span> element &gt; 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(array1.findIndex(findFirstLargeNumber));</span><br><span class="line">// expected output: 3</span><br></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的默认值"><a href="#函数的默认值" class="headerlink" title="函数的默认值"></a>函数的默认值</h3><p>给函数参数设置默认值的意思是：当没有传参的时候 ，参数取设定的默认值，即传入值为undefined<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">log</span>(x, y = <span class="string">'World'</span>)&#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'Hello'</span>); // Hello World</span><br><span class="line">console.log(<span class="string">'Hello'</span>, <span class="string">'China'</span>); // Hello China</span><br><span class="line">console.log(<span class="string">'Hello'</span>, null); // Hello null</span><br></pre></td></tr></table></figure></p><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a, ...arr, b) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;  // 报错</span><br><span class="line"><span class="keyword">function</span> f(a, b, ...arr) &#123;</span><br><span class="line">    console.log(arr);</span><br><span class="line">&#125;  </span><br><span class="line">f(<span class="string">"c"</span>,<span class="string">"b"</span>,<span class="string">"d"</span>,<span class="string">"x"</span>,<span class="string">"c"</span>);// [<span class="string">"d"</span>,<span class="string">"x"</span>,<span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">// ES5</span><br><span class="line">f.name // <span class="string">""</span></span><br><span class="line">// ES6</span><br><span class="line">f.name // <span class="string">"f"</span></span><br></pre></td></tr></table></figure><h3 id="对象函数简易写法"><a href="#对象函数简易写法" class="headerlink" title="对象函数简易写法"></a>对象函数简易写法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">'xxxx'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">等同于</span><br><span class="line">var obj = &#123;</span><br><span class="line">func: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> cs = <span class="string">'xx'</span>;</span><br><span class="line"><span class="built_in">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h3><p>双冒号运算符用来取代 call, apply, bind 调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj::fun;</span><br><span class="line">// 等同于</span><br><span class="line">obj.bind(fun);</span><br><span class="line"></span><br><span class="line">obj::fun(...arguments);</span><br><span class="line">// 等同于</span><br><span class="line">obj.apply(fun, arguments);</span><br></pre></td></tr></table></figure></p><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var method = obj::obj.foo;</span><br><span class="line">// 等同于</span><br><span class="line">var method = ::obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="built_in">log</span> = ::console.log;</span><br><span class="line">// 等同于</span><br><span class="line">var <span class="built_in">log</span> = console.log.bind(console);</span><br></pre></td></tr></table></figure></p><h2 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">Set</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">Map</a></h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set 本身是一个构造函数，用来生成 Set 数据结构。<br>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"><span class="built_in">let</span> arr = [...<span class="built_in">set</span>];</span><br><span class="line">// [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> a = new Set([1, 2, 3]);</span><br><span class="line"><span class="built_in">let</span> b = new Set([4, 3, 2]);</span><br><span class="line">// 并集</span><br><span class="line"><span class="built_in">let</span> union = new Set([...a, ...b]);</span><br><span class="line">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">// 交集</span><br><span class="line"><span class="built_in">let</span> intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">// <span class="built_in">set</span> &#123;2, 3&#125;</span><br><span class="line">// 差集</span><br><span class="line"><span class="built_in">let</span> difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></p><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。<br>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map0 = new Map()</span><br><span class="line">  .<span class="built_in">set</span>(1, <span class="string">'a'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(2, <span class="string">'b'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(3, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> map1 = new Map(</span><br><span class="line">  [...map0].filter(([k, v]) =&gt; k &lt; 3)</span><br><span class="line">);</span><br><span class="line">// 产生Map结构 &#123;1 =&gt; <span class="string">'a'</span>, 2 =&gt; <span class="string">'b'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> map2 = new Map(</span><br><span class="line">  [...map0].map(([k, v]) =&gt; [k * 2, <span class="string">'_'</span> + v])</span><br><span class="line">    );</span><br><span class="line">// 产生Map结构 &#123;2 =&gt; <span class="string">'_a'</span>, 4 =&gt; <span class="string">'_b'</span>, 6 =&gt; <span class="string">'_c'</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h2><p>Iterator遍历器，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br>而Iterator为for..of提高消费，既可带有遍历器的对象都可被for…of遍历。</p><p>for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、Generator对象，以及字符串。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map();</span><br><span class="line">map.set(<span class="string">'a1'</span>,<span class="string">'b'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(<span class="string">'v2'</span>,<span class="string">'cr'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(<span class="string">'a3'</span>,<span class="string">'br'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(<span class="string">'v4'</span>,<span class="string">'cr'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> [key, value] of map)&#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">import</a>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener">export</a><br>import语句用于导入由另一个模块导出的绑定。无论是否声明了 strict mode ，导入的模块都运行在严格模式下。在浏览器中， import语句只能在声明了type=”module”的script的标签中使用。<br>此外还有一个类似函数的动态import()，它不需要依赖type=”module”的script标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 默认导入与命名导入一起导入</span><br><span class="line">// 第一个参数为默认导入，第二个命名导入</span><br><span class="line">import _,&#123;* as names&#125; from <span class="string">'a.js'</span>;</span><br><span class="line"></span><br><span class="line">// 动态导入</span><br><span class="line">import(<span class="string">'a.js'</span>).<span class="keyword">then</span>((module)=&#123;</span><br><span class="line">  // 对导入模块操作</span><br><span class="line">&#125;);</span><br><span class="line">或</span><br><span class="line">aynsc <span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">  <span class="built_in">let</span> module = await import(<span class="string">'a.js'</span>);</span><br><span class="line">  <span class="built_in">return</span> module;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span>语句用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。</span><br><span class="line">``` bash</span><br><span class="line">// 不能使用var，<span class="built_in">let</span>或const用于导出默认值<span class="built_in">export</span> default。</span><br><span class="line">// 只能有一个默认的导出</span><br><span class="line">// 命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> a = &#123;<span class="string">"a"</span>:10&#125;;</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> b = &#123;<span class="string">"b"</span>:10&#125;;</span><br><span class="line"><span class="built_in">let</span> bb = 20;</span><br><span class="line"><span class="built_in">export</span> default bb;</span><br></pre></td></tr></table></figure><h2 id="Generators-生成器"><a href="#Generators-生成器" class="headerlink" title="Generators 生成器"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener">Generators 生成器</a></h2><p>generator也是为了解决地狱回调问题的，本质还是各种回调。<br>在某些时候也可以认为generator为es6中新定义的数据类型，这种数据类型和函数很像，每个函数只能返回一个结果，即只能return一次，如果在某些函数中没有看到return，其实质在函数结尾是存在一个隐藏的return undefined 的，而generator不同，可以返回多次</p><p>Generators生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen(a)&#123;</span><br><span class="line">  <span class="built_in">let</span> b = 9 * (yield(10 + a));</span><br><span class="line">  <span class="built_in">let</span> c = 100 - (yield(b / 2));</span><br><span class="line">  <span class="built_in">let</span> d = c / 8;</span><br><span class="line">  <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> func = gen(20);</span><br><span class="line">console.log(func); // Generator &#123;_invoke: ƒ&#125;</span><br><span class="line"><span class="built_in">let</span> ii = func.next(9); </span><br><span class="line">console.log(ii); // &#123;value: 30, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">let</span> ii2 = func.next(40); </span><br><span class="line">console.log(ii2); // &#123;value: 180, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">let</span> ii3 = func.next(5);</span><br><span class="line">console.log(ii3); // &#123;value: 11.875, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></p><p>当done不为false时可以继续调用next方法，而返回值为yield的结果值，而传入值会替换yield的部分继续走下去。<br>如第一个next传入的值为9，而变量b = 9 * 9。</p><p>generator function 返回的,并且它符合可迭代协议和迭代器协议,所以可以被for…of遍历，而当遇到return后不会继续遍历，return值不会被返回出来。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  yield 10;</span><br><span class="line">  yield 20;</span><br><span class="line">  yield 30;</span><br><span class="line">  yield 40;</span><br><span class="line">  <span class="built_in">return</span> 50;</span><br><span class="line">  yield 100;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of gen())&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// 10 20 30 40</span><br></pre></td></tr></table></figure></p><p>return和throw在生成器中起到了终止的作用,迭代器it可以直接调用throw方法，传入的参数就是catch中的err，然后在调用it的next方法时，done已经被设置成true了，就是说生成器终止了。这个异常其实是在生成器内部产生的，只是我们没有捕获，所以继续往外抛了出来，如果在内部try-catch这个异常也是可以的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        yield;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    i.throw(<span class="string">'a'</span>);</span><br><span class="line">    i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a></h2><p>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。<br>Promise 优缺点<br>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p><p>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 使用</span><br><span class="line"><span class="built_in">let</span> p = new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>);</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(d=&gt;&#123;</span><br><span class="line">  console.log(d);</span><br><span class="line">&#125;,d=&gt;&#123;</span><br><span class="line">  console.log(d);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 链式使用</span><br><span class="line">p.then(d=&gt;&#123;</span><br><span class="line">  console.log(d);</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    resolve(100);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,d=&gt;&#123;</span><br><span class="line">  console.log(d);</span><br><span class="line">&#125;).<span class="keyword">then</span>(d=&gt;&#123;</span><br><span class="line">  console.log(d);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/sweeeper/p/8442613.html" target="_blank" rel="noopener">资料</a></p><p>Promise 的api　<br>1、Promise.resolve()<br>2、Promise.reject()<br>3、Promise.prototype.then()<br>4、Promise.prototype.catch()<br>5、Promise.all() // 所有的都有完成，相当于 且<br>6、Promise.race() // 完成一个即可，相当于 或<br>7、Promise.resolve()的作用将现有对象转为Promise对象resolvedl;Promise.resolve(‘test’)==new Promise(resolve=&gt;resolve(‘test’))<br>8、Promise.reject()也是返回一个Promise对象,状态为rejected；<br>9、then方法上边已经做介绍，这里就不再介绍。<br>10、catch():发生错误的回调函数。</p><h2 id="ayncs与await"><a href="#ayncs与await" class="headerlink" title="ayncs与await"></a>ayncs与await</h2><p>async await可以用更少的处理实现 Promise 和 Generators 所实现的异步处理,避免多层嵌套，是一种多个Promise同步的优雅的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = <span class="keyword">function</span> ii(x)&#123;</span><br><span class="line">  <span class="built_in">let</span> p = new Promise((res, rej)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      res(<span class="string">'success '</span>+x);</span><br><span class="line">    &#125;,1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">ayn</span></span>()&#123;</span><br><span class="line">  <span class="built_in">let</span> x = await a(<span class="string">"zzc"</span>);</span><br><span class="line">  console.log(x);</span><br><span class="line">  <span class="built_in">let</span> b = await a(x+<span class="string">"zhi"</span>);</span><br><span class="line">  console.log(b);</span><br><span class="line">  <span class="built_in">let</span> c = await a(b+<span class="string">"sss"</span>);</span><br><span class="line">  console.log(c);</span><br><span class="line">  <span class="built_in">let</span> d = await a(c+<span class="string">"xx"</span>);</span><br><span class="line">  <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ayn().<span class="keyword">then</span>(d=&gt;&#123;</span><br><span class="line">  console.log(d);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="class"><a href="#class" class="headerlink" title="class"></a><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001458267339633fd3a83c597d04b5fb59f7d1f6792efb3000" target="_blank" rel="noopener">class</a></h2><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 使用</span><br><span class="line">class Abc&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    this.a = <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getA</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.a;</span><br><span class="line">  &#125;</span><br><span class="line">  setA(a)&#123;</span><br><span class="line">    this.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> abcx = new Abc();</span><br><span class="line">console.log(abcx.getA()); // abc</span><br><span class="line"></span><br><span class="line">// 继承</span><br><span class="line">class Ext extends Abc&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    super();</span><br><span class="line">    super.getA();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSA</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> abcx = new Ext();</span><br><span class="line">console.log(abcx.getA()); // abc</span><br></pre></td></tr></table></figure></p><p>继承时一定要调用super(),因为需要初始化父类，把父类的this指向子类的this，若不调用会报错。而父类的方法的使用可以使用super。</p><p>后续会持续更新…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;let与const&quot;&gt;&lt;a href=&quot;#let与const&quot; class=&quot;headerlink&quot; title=&quot;let与const&quot;&gt;&lt;/a&gt;let与const&lt;/h2&gt;&lt;p&gt;声明let与const都是块级作用域，所以不能想var声明一样，没有变量声明提升。&lt;</summary>
      
    
    
    
    
    <category term="js" scheme="https://793338023.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>github博客网站构建</title>
    <link href="https://793338023.github.io/2018/12/27/github%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9E%84%E5%BB%BA/"/>
    <id>https://793338023.github.io/2018/12/27/github%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9E%84%E5%BB%BA/</id>
    <published>2018-12-27T13:17:49.000Z</published>
    <updated>2019-01-07T13:19:02.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直打算使用github搭建自己的博客地址，而且看起来还不错的，但ssh的问题一直都提交不成功，一度不放弃了很多次，但在最后还是成功了。<br><a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">前面的构建可以参考</a></p><h2 id="ssh问题解决"><a href="#ssh问题解决" class="headerlink" title="ssh问题解决"></a>ssh问题解决</h2><p>1、首先我得重新在git设置一下身份的名字和邮箱（因为当初都忘了设置啥了，因为遇到坑了）进入到需要提交的文件夹底下（因为直接打开git Bash，在没有路径的情况下，根本没！法！改！刚使用git时遇到的坑。。。）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span>·</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email“your@email.com<span class="string">"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：yourname是你要设置的名字，your@email是你要设置的邮箱。</span><br></pre></td></tr></table></figure><p>2、删除.ssh文件夹（直接搜索该文件夹）下的known_hosts(手动删除即可，不需要git）<br>3、git输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your@email.com"</span>（请填你设置的邮箱地址）</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接着出现：</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/your_user_directory/.ssh/id_rsa):</span><br><span class="line">请直接按下回车</span><br><span class="line">然后系统会自动在.ssh文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub</span><br><span class="line">将全部的内容复制</span><br></pre></td></tr></table></figure><p>注意输入完ssh-keygen这个后出现的都回车，不要输入东西。<br>那么就可以出现在git中输入命令：<br>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>然后会跳出一堆话。。<br>输入命令：yes<br>不是没有yes这个命令输入，并且也无法提交。</p><p><a href="https://blog.csdn.net/jingtingfengguo/article/details/51892864" target="_blank" rel="noopener">资料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前一直打算使用github搭建自己的博客地址，而且看起来还不错的，但ssh的问题一直都提交不成功，一度不放弃了很多次，但在最后还是成功了。</summary>
      
    
    
    
    
    <category term="github" scheme="https://793338023.github.io/tags/github/"/>
    
  </entry>
  
</feed>
