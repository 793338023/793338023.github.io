[{"title":"http第三篇","date":"2020-09-14T15:50:36.000Z","path":"2020/09/14/http第三篇/","text":"HTTPMIME type数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type； Accept 字段标记的是客户端可理解的 MIME type 相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型 有了 MIME type 和 Encoding type，无论是浏览器还是服务器就都可以轻松识别出 body 的类型，也就能够正确处理数据了。 以为为常见的MIME type: text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。 image：即图像文件，有 image/gif、image/jpeg、image/png 等。 audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。 application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，需要客户端猜的，就会是 application/octet-stream，即不透明的二进制数据。 Encoding type数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding； 常用的只有下面三种： gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式； deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip； br：一种专门为 HTTP 优化的新压缩算法（Brotli）。 分块传输当传输大内容时使用只使用一次的请求应答模式会导致响应时间过长，这是很影响性能的，那么如何处理这样的问题呢？ 那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。 这种“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块逐个发送。 “Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。 范围请求如果使用范围请求，需要服务器在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。 如果已经确定双端都支持范围请求，我们就可以在请求资源的时候使用它。 HTTP/1.1 中定义了一个 Ranges 的请求头，来指定请求实体的范围。它的范围取值是在 0 - Content-Length 之间，使用 - 分割。。 服务器收到 Range 字段后，需要做以下操作： 它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。 如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。 服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。 CookieCookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”，每次的传输内容都会带上 cookie 信息，所以尽量不要让自己服务器以外的人看到。 为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 、SameSite 等。 Cookie 最基本的一个用途就是身份识别，保存用户的登录信息，实现会话事务。 比如，你用账号和密码登录某电商，登录成功后网站服务器就会发给浏览器一个 Cookie，内容大概是“name=yourid”，这样就成功地把身份标签贴在了你身上，实现了“状态保持”。 Cookie 的另一个常见用途是广告跟踪。 你上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站（例如 Google），它会“偷偷地”给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。 这种 Cookie 不是由访问的主站存储的，所以又叫“第三方 Cookie”。如果广告商势力很大，广告到处都是，那么就比较“恐怖”了，无论你走到哪里它都会通过 Cookie 认出你来，实现广告“精准打击”，但也是最容易泄露隐私。 HTTPS因为 http 的不安全性，才有 https 的出现。 通信安全必须同时具备机密性、完整性、身份认证和不可否认这四个特性，而 https 为 HTTP 增加了这四大安全特性。 HTTPS 默认端口号是 443，除了协议名“http”和端口号 80 这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。 HTTPS 与 HTTP 最大的区别，它能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、篡改或者“钓鱼”、伪造。 而 HTTPS 把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，让 HTTP 运行在了安全的 SSL/TLS 协议上，其实就是在 TCP/IP 与 HTTP 之间添加一层 SSL/TLS。 HTTP2/3阐述当 HTTP 到 HTTPS 后，在安全上已经有保障了，但本来性能一般般的 HTTP 又加上一层处理，变得更加重，在性能上有所损耗，那么成熟后的 HTTPS 已经在性能暴露了问题，那么只能对其性能方面下手，所以就出现后续的 HTTP2/3。 而为什么 HTTP 在后续的版本再也没有出现过小版本？ 以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号，只使用大版本号，从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”。 这样就可以明确无误地辨别出协议版本的“跃进程度”，让协议在一段较长的时期内保持稳定，每当发布新版本的 HTTP 协议都会有本质的不同，绝不会有“零敲碎打”的小改良。 HTTP/2保持功能上的兼容，完全兼容 HTTP1，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。 特别要说的是，与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。 可以让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。 但 HTTP/2 的内容对于 HTTP/1 有着“天翻地覆”的改造 头部压缩由于 HTTP1 没有针对头部的优化手段，头部还有优化的空间，不过 HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。 二进制格式相对于 HTTP/1 里纯文本形式的报文，HTTP/2 采用二进制格式 二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。 虚拟的“流”HTTP/2 为此定义了一个“流”的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。 因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”——多个往返通信都复用一个连接来处理。 在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。 多路复用多路复用多个请求没有顺序，而长连接多个请求必须排队，就会队头阻塞。 http 协议要求请求-响应必须一来一回，上一个请求没有处理完，下一个请求是不能发出去的。一个 tcp 连接上的 http 请求必然是串行。 管道模式可以顺序发出多个请求，但响应也必须顺序响应。这些都是 http/1.1 里规定的。 再对比 http/2，一个 tcp 连接里有多个流，每个流就是一个请求，所以多个请求可以并发，“复用”在了一个连接里。 http/3HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。 由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。 Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。 QUIC 选择使用 UDP 为基础，因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。 QUIC 在 UDP 上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。 QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。 webSocket其实 WebSocket 与 HTTP/2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的。HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。 “请求 - 应答”是一种“半双工”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。 “请求 - 应答”模式，导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域。 为了克服 HTTP“请求 - 应答”模式的缺点，WebSocket 就“应运而生”了。 WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，而不用像 HTTP“你拍一，我拍一”那么“客套”。于是，服务器就可以变得更加“主动”了。一旦后台有新的数据，就可以立即“推送”给客户端，不需要客户端轮询，“实时通信”的效率也就提高了。 WebSocket 使用兼容 HTTP 的 URI 来发现服务，但定义了新的协议名“ws”和“wss”，端口号也沿用了 80 和 443； 总结http/1 请求-应答都是有序并且每次都需要建立连接，而后 http/1.1 出现长连接与管道模式可以让连接维持不断并且多个请求有序的同时发送等待响应，但响应部分还是需要排队等待一个一个返回，而 HTTP/2 出现就是主要是压缩头部信息与数据格式从文本改为二进制，让数据的体积变小，而且让应用层上连接的有序变为无序，解决了连接层上队头阻塞，而 HTTP/3 的出现主要解决了 TCP 的传输层上队头阻塞问题，把 TCP 换为 UDP 无序的、包之间没有依赖更快传输协议，并改造为可靠的传输协议。 而使用 HTTP2/3 就没有必要使用精灵图、多个请求合并的操作，因为这些技术出现都是为了解决对头阻塞导致的请求响应慢的问题，而且还不能很好的使用 HTTP 的缓存机制，在 HTTP2/3 中这些技术反而会拖慢请求响应的速度。","tags":[{"name":"http","slug":"http","permalink":"https://793338023.github.io/tags/http/"}]},{"title":"http第二篇","date":"2020-09-10T14:59:52.000Z","path":"2020/09/10/http第二篇/","text":"报文结构HTTP 是基于 TCP/IP 的，那么传输的事情应该是 TCP/IP 完成的，那么 HTTP 称为超文本传输协议是不是有点不妥了，因为它不负责传输，那这个传输又是怎么回事，答案就在它的传输的报文内容，HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略。 HTTP 协议是一个“纯文本”的协议，而 HTTP2/3 后就是二进制协议，http/1 纯文本的好处是方便易读，对人类友好，而 http/2 正相反，易于机器解析。 HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成： 起始行（start line）：描述请求或响应的基本信息； 头部字段集合（header）：使用 key-value 形式更详细地说明报文； 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。 通俗的理解就是“header+body”。 HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。 这个使用 fiddler 抓取 HTTP 包就能看得出来，如: 请求报文: 123456789POST https://array701.prod.do.dsp.mp.microsoft.com/join/ HTTP/1.1Connection: Keep-AliveAccept: */*User-Agent: Microsoft-Delivery-Optimization/10.0MS-CV: edXwuc8Ok0mKLY9H.1.2.3.1.7.2.6.1.10Content-Length: 682Host: array701.prod.do.dsp.mp.microsoft.com&#123;&quot;ContentId&quot;:&quot;d91f96082d4a8db9f1bdccaeb06a29cb6c1341b7&quot;,&quot;AltCatalogId&quot;:&quot;http://11.au.download.windowsupdate.com/d/msdownload/update/software/secu/2020/08/windows10.0-kb4576484-x64-ndp48_d91f96082d4a8db9f1bdccaeb06a29cb6c1341b7.cab&quot;,&quot;PeerId&quot;:&quot;2614138130a28042b021b5b0c0add9c400000000&quot;,&quot;ReportedIp&quot;:&quot;192.168.1.54&quot;,&quot;SubnetMask&quot;:&quot;255.255.255.0&quot;,&quot;Ipv6&quot;:&quot;&quot;,&quot;IsBackground&quot;:&quot;1&quot;,&quot;ClientCompactVersion&quot;:&quot;10.0.18362.959&quot;,&quot;Uploaded&quot;:&quot;0&quot;,&quot;Downloaded&quot;:&quot;8388608&quot;,&quot;DownloadedCdn&quot;:&quot;8388608&quot;,&quot;DownloadedDoinc&quot;:&quot;0&quot;,&quot;Left&quot;:&quot;0&quot;,&quot;JoinRequestEvent&quot;:&quot;3&quot;,&quot;RestrictedUpload&quot;:&quot;0&quot;,&quot;PeersWanted&quot;:&quot;50&quot;,&quot;GroupId&quot;:&quot;&quot;,&quot;Scope&quot;:&quot;2&quot;,&quot;UploadedBPS&quot;:&quot;0&quot;,&quot;DownloadedBPS&quot;:&quot;0&quot;,&quot;Profile&quot;:&quot;0&quot;,&quot;ConnAttempts&quot;:&quot;1:96;&quot;,&quot;Seq&quot;:&quot;9&quot;&#125; 响应报文: 1234567891011HTTP/1.1 200 OKCache-Control: privateContent-Type: text/htmlServer: Microsoft-IIS/10.0x-content-type-options: nosniffX-AspNet-Version: 4.0.30319X-Powered-By: ASP.NETDate: Thu, 10 Sep 2020 16:04:09 GMTContent-Length: 287&#123;&quot;FailureReason&quot;:null,&quot;NextJoinTimeIntervalInMs&quot;:231680,&quot;Complete&quot;:0,&quot;Incomplete&quot;:0,&quot;Rediscover&quot;:false,&quot;KVVersion&quot;:&quot;1E81C22A406C2F10A31B4149E8C96946EB35AD4CA26974B2145E165F2762B22B&quot;,&quot;GeoVersion&quot;:&quot;E6B6DF02CFC90F2720E5594DF177BA33ABDAE4CCBA432D08DDEAD11123552399&quot;,&quot;Peers&quot;:[],&quot;Leave&quot;:false&#125; 报文头与报文体之间有一行空行 请求行请求行就是起始行 它简要地描述了客户端想要如何操作服务器端的资源。 三部分构成： 请求方法：是一个动词，如 GET/POST，表示对资源的操作； 请求目标：通常是一个 URI，标记了请求方法要操作的资源； 版本号：表示报文使用的 HTTP 协议版本。 这三个部分通常使用空格来分隔，最后要用 CRLF 换行表示结束。 如: 1POST https://array701.prod.do.dsp.mp.microsoft.com/join/ HTTP/1.1 请求方法为POST，请求目标为https://array701.prod.do.dsp.mp.microsoft.com/join/，版本号为HTTP/1.1 而响应的起始行就是状态行 也是由三部分构成: 版本号：表示报文使用的 HTTP 协议版本； 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误； 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。 如: 1HTTP/1.1 200 OK 版本号为HTTP/1.1,状态码200,原因OK 头部字段请求头和响应头的结构是基本一样的，唯一的区别是起始行 头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束 HTTP 头字段非常灵活可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能 不过使用头字段需要注意下面几点： 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好； 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名； 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格； 字段的顺序是没有意义的，可以任意排列不影响语义； 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。 HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。 标准请求方法目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式 GET：获取资源，可以理解为读取或者下载数据； HEAD：获取资源的元信息； POST：向资源提交数据，相当于写入或上传数据； PUT：类似 POST； DELETE：删除资源； CONNECT：建立特殊的连接隧道； OPTIONS：列出可对资源实行的方法； TRACE：追踪请求 - 响应的传输路径。 请求方法是客户端发出的、要求服务器执行的、对资源的一种操作;请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据； 响应状态码1××1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。 2××2×× 类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。 “200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果 3××3×× 类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。 301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。 “304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件” 301、302 和 304 分别涉及了 HTTP 协议里重要的“重定向跳转”和“缓存控制” 4××4×× 类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。 “400 Bad Request”是一个通用的错误码，表示请求报文有错误 “403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。 “404 Not Found”、资源在本服务器上未找到，所以无法提供给客户端。 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET； 5××5×× 类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。 HTTP 特性HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。 简单HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。 灵活可扩展HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。 同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。 应用广泛和跨平台互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。 无状态“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。 而无状态这个特性在不同的场景，体现出现的价值不一样，是一把双刃剑。 好处:如在不需要客户端或者服务器里保存的一些数据或者标志来记录通信过程中的一些变化信息时，可以减轻服务器的负担，提高性能。 坏处:如果需要知道每次操作的请求是不是同一个人时需要记录一些数据，那么要完成这个关联性的操作时会非常麻烦，因为每个请求都是独立的。 例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。 解决方法对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。 Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了， 明文明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。 但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。 不安全HTTP 比较严重的缺点就是不安全： 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。 HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。 性能HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。 长连接早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。 为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 管道网络传输HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。 但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。 队头阻塞「请求 - 应答」的模式加剧了 HTTP 的性能问题。 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班坐公交车和别的公交车并行行驶，但驶入公交站时大家串行排队等待前面的车辆的人下完后驶出才到你坐的公交车驶入站下车。 总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。","tags":[{"name":"http","slug":"http","permalink":"https://793338023.github.io/tags/http/"}]},{"title":"http第一篇","date":"2020-09-06T11:18:47.000Z","path":"2020/09/06/http第一篇/","text":"http 简史 HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文； HTTP/0.9 是个简单的文本协议，只能获取文本资源； HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准； HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善； HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及； HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。 http 是什么HTTP 是超文本传输协议 HTTP 的名字「超文本协议传输」，它可以拆成三个部分： 超文本 传输 协议 HTTP三部分 协议是什么协议是指两个或两个以上实体为了开展某项活动，经过协商后双方达成的一致意见。协议在法律上是合同的同义词。合同是当事人或当事双方之间设立、变更、终止民事关系的协议。 而协议必须要有两个或多个参与者，为了保证最基本的顺畅交流与对参与者的一种行为约定和规范。 例如，为了保证你顺利就业，“三方协议”里的参与者有三个：你、公司和学校；为了保证你顺利入住，“租房协议”里的参与者有两个：你和房东。 而有多个参与者并能正常交流还是不够的，还需要达成某个共同的目的而站在了一起，那么必须明确地规定各方的“责、权、利”，约定该做什么不该做什么，先做什么后做什么，做错了怎么办，有没有补救措施等等。例如，“租房协议”里就约定了，租期多少个月，每月租金多少，押金是多少，水电费谁来付，违约应如何处理等等。 而 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 传输HTTP 是一个传输协议，就是传输的过程中都需要遵循这个协议，而传输就是字面上的意思，把一堆东西从 A 点传到 B 点，或者 B 点传到 A 点，但 A、B 两点之间是否还有其他的点进行传输那它就没有限制,允许有中转或接力，就像运动会上接力棒比赛一样，起点、终点规定有多少人是不限的，但要遵循比赛规则，而且还可以 A 到 B，然后 B 到 A，可以知道它是一个双向的协议。 而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。 HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 注意是两点之间，是不限制你在服务器还是客户端 超文本我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。 再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。 HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。 超文本传输协议使用一句话表达超文本传输协议 HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范 HTTP 的概念在互联网世界里 HTTP 是最常见的也是最普遍的，当然还有其实的各自的专有协议，如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等 不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。 综合起来看，现在的互联网 90% 以上的部分都被 HTTP 所覆盖，所以把互联网约等于 HTTP 应该也不算大错。 浏览器浏览器的正式名字叫“Web Browser”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。 万维网，它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。 浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。 在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求，通常称之为“客户端”。 Web 服务器Web 服务器是协议另一端的应答方（响应方） 而 Web 服务器一般都是 Apache、Nginx、IIS、Jetty/Tomcat 等 Nginx 使用的最普遍，特点是高性能、高稳定，且易于扩展。 爬虫它也是一种用户代理，代替我们访问互联网 而无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML。 HTTP 相关的协议TCP/IPTCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。 IPIP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。可以对比一下现实中的电话系统，你拿着的手机相当于互联网上的计算机，而要打电话就必须接入电话网，由通信公司给你分配一个号码，这个号码就相当于 IP 地址。 现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但已经被分配完了。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，但 v6 没有考虑向下兼容的问题，所以完全代替 v4 版本是不可能的，而且 NAT 的出现也在一定程度上解决 v4 版本不足的问题。 TCPTCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。 可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。 而互联网上的 HTTP 协议就运行在了 TCP/IP 上 DNSIP 地址来标识计算机，对于人类来说难以记住，于是就有了“域名系统”，用有意义的名字来代替 IP 地址。 但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。 但能域名解析的服务器很多，而且会出现层级关系，逐层递归地实现域名查询，因此域名解析也会很耗时，所以出现 DNS 缓存。 而我们的本地就有一个特殊的“主机映射”文件，C:\\WINDOWS\\system32\\drivers\\etc\\hosts,在缓存里找不到 DNS 记录，就会找这个文件。 使用域名，我们可以很简单的实现 IP 地址任意变动，可以基于域名实现的负载均衡，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡，域名解析也可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡 但不怀好意的人可以在域名这方面“做手脚“ “域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站； “域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。 HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。 代理代理是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。 代理有很多的种类，常见的有： 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 反向代理：靠近服务器端，代表服务器响应客户端的请求； 由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如： 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化； 内容缓存：暂存上下行的数据，减轻后端的压力； 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器； 数据处理：提供压缩、加密等额外的功能。","tags":[{"name":"http","slug":"http","permalink":"https://793338023.github.io/tags/http/"}]},{"title":"探讨react的核心原理","date":"2020-07-19T15:46:40.000Z","path":"2020/07/19/探讨react的核心原理/","text":"React 核心而前三个就可以实现一个简单版 React，最后一个 Fiber 为 React 核心数据结构 React.createElement：创建虚拟 DOM React.Component：实现⾃定义组件 ReactDOM.render：渲染真实 DOM Fiber 核心数据结构 createElementReact 会把 jsx 语法经过 babel 转译成 React.createElement，所以当使用 jsx 时识别到的标签都会转译。如: jsx 1const App = &lt;div&gt;123&lt;/div&gt;; 转译后 1234567891011121314const App = React.createElement( \"div\", &#123; __self: undefined, __source: &#123; fileName: _jsxFileName, lineNumber: 7, columnNumber: 13, &#125;, &#125;, \"123\");// __source,__self 属性是开发环境时调式使用的，在生成环境时不会存在。 createElement 参数 第一参数为标签名，如果是自定标签，那么就是组件的变量如 1const Test = React.createElement(App, &#123;&#125;, \"xxx\"); 第二参数为标签上的属性，如 123const Test = &lt;App name=\"10\"&gt;xxx&lt;/App&gt;;//转换后const Test = React.createElement(App, &#123; name: \"10\" &#125;, \"xxx\"); 第三个之后包括第三个，都是 chlidren 12345678910111213const Test = ( &lt;div&gt; &lt;div&gt;123&lt;/div&gt; &lt;App name=\"10\" /&gt; &lt;/div&gt;);//转换后const Test = React.createElement( \"div\", &#123;&#125;, React.createElement(\"div\", &#123;&#125;, \"123\"), React.createElement(App, &#123; name: \"10\" &#125;)); render 会根据 createElement 返回的数据结构(虚拟 DOM)遍历生成真实 DOM 节点，而自定义标签组件会根据是否为 class 组件或函数组件获取 createElement 返回的数据结构，而函数组件的当前函数就是 jsx 数据，而 class 组件是从 render 方法上获取 jsx 数据。 Component我们写 class 组件，都需要继承 React.Component，而 Component 主要是包含了一个 class 需要属性与方法 方法有: setState forceUpdate 而这两个方法的目的都是更新 state 的，只是一个正常的更新 state 数据，setState 会被 shouldComponentUpdate 优化更新拦截更新视图，而 forceUpdate 则不会，因为它是直接跳过更新视图的，所以当我们的数据没有走 setState 更新 state 时，而是直接更新 state 或自己定义的状态对象那么可以使用 forceUpdate 直接渲染视图达到更新视图的效果，如 antd 的 form 就是使用 forceUpdate 更新数据的，由于无法使用 shouldComponentUpdate 优化，表单过大的渲染量大导致操作一项更新所有表单项很消耗性能，会出现卡顿的现象。 属性有: props context refs updater props 与 context 略过，就是状态 refs 是 class 组件上的让我们存储组件上 ref 值的 updater 才是重点，因为状态的更新就在这里实现，每个组件都有一个更新对象，而里面只实现了更新需要的方法，真正需要更新的数据都存储在 fiber 里面 那么我们在写组件时就会带上默认的属性与方法 renderrender 用于将 React 渲染的虚拟 DOM 渲染到浏览器 DOM，一般在顶层组件使用。该方法把元素挂载到 container 中，并且返回 element 的实例（即 refs 引用），如果是函数组件，render 会返回 null。当组件装载完毕时，callback 就会被调用。其语法为： 1ReactDOM.render(ReactElement element,DOMElement container,[function callback]) React diff 三大策略 策略一（tree diff）：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。（DOM 结构发生改变—–直接卸载并重新加载组件） 策略二（component diff）：DOM 结构一样—–不会卸载,但是会 update 策略三（key diff）：比较节点的 key 值，通过 key 来区分重载与更新—–同时遵循 1.2 两点 Fiberfiber 其实可以理解为虚拟 DOM，因为 createElement 创建的虚拟 DOM 会对应到 fiber 上，而 DOM 上更新是根据 fiber 的信息，比如 diff 比较。 进行 render 后会把 createElement 的数据转换成 Fiber 数据结构 fiber 最大的好处是可暂定可恢复，让 React 实现让出机制，时间分片，使用的 API requestIdleCallback: React 已经内部实现了 requestIdleCallback，不使用 requestIdleCallback API React16/fiber js 事件循环机制我理解的同步异步，是进入主线程的为同步，进行事件队列的为异步，简单的说就是任务在没有进入主线程即为异步 而会进入事件队列里的大概有如下: 浏览器事件：window.load、document.DomContentLoaded 等 网络请求事件:ajax、websocket 用户事件:单双击、鼠标滚动、调整页面大小等 计时器事件：setTimeout,setInterval 等 延迟对象或在某个阶段才触发的浏览器 API，Promise、requestIdleCallback、requestAnimationFrame 等 事件队列分为宏任务的事件队列与微任务的事件队列 宏任务：setTimeout，setInterval，setImmediate，requestAnimationFrame，I / O，UI 呈现，js 初始执行代码等微任务：Promise，Object.observe，MutationObserver js 引擎的执行机制是执行把一个宏任务放入主线程上执行，当这个宏任务结束后执行当前的整个微任务队列，然后交出线程让 GUI 渲染线程接管，执行界面上渲染，如解析 DOM 树、css 树之类的，就是做视觉上的工作 而首次执行的代码也是属于宏任务的，所以整个 js 执行机制，可以理解为事件循环机制，但我们不使用会进入事件队列的 API，那么整个代码执行的过程都是在主线程上，因为整个代码都是一个宏任务 而 js 引擎线程与 GUI 渲染线程是互斥的 为什么 React 15 会出现卡顿在 React 没有使用 Fiber 进行重构之前，React 实现的代码是没有使用能进入事件队列的 API 的，所以我们使用 React 实现的功能就是一个宏任务，当这个宏任务代码量与计算量庞大时，就会让 GUI 渲染无法执行，导致到了该渲染时无法渲染。 而 React 重构后加入了时间分片的原理，实现方式是使用了 requestIdleCallback 的原理，React 没有直接使用 requestIdleCallback，因为它有兼容性问题 而我们常说 React 的 setState 使用异步更新，这是因为在代码执行上的效果如异步操作，不会立即更新状态的值，而它的事件原理是进行 setState 时不会立即赋值到 state 上而会进行一轮的状态收集,即进入更新队列里,并且更新队列里的状态改为等待中,当收集完毕后改变状态为完成,并进行 state 更新与 render 渲染内容,但进入事件队列里的方法内的 setState 的状态就无法收集,因为更新流程是在主线程执行的，而事件队列是要等主线程执行完毕后才进行执行的，那么当前的更新队列里的状态已经为完成了,所以异步内的 setState 为同步更新,因为 setState 后获取 state 就是当前的 setState 后的状态,如 12345678910111213141516171819202122232425state = &#123; a: 0 &#125;;this.setState(&#123; a: 1 &#125;);this.setState(&#123; a: 2 &#125;);class App extends React.Component &#123; state = &#123; a: 0, &#125;; click = () =&gt; &#123; this.setState(&#123; a: 1 &#125;); this.setState(&#123; a: 2 &#125;); console.log(this.state.a); // 0 setTimeout(() =&gt; &#123; this.setState(&#123; a: 3 &#125;); console.log(this.state.a); // 3 this.setState(&#123; a: 4 &#125;); console.log(this.state.a); // 4 &#125;, 0); &#125;; render() &#123; return &lt;div onClick=&#123;this.click&#125;&gt;&#123;this.state.a&#125;&lt;/div&gt;; &#125;&#125; React 的事件是合成事件，不是原生的事件，内部已经实现了状态更新过程的状态收集 github 项目","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"redux中间件原理","date":"2020-06-01T15:17:20.000Z","path":"2020/06/01/redux中间件原理/","text":"前言redux 中间件设计的代码，简洁到极致，它的代码量很少，但却满足 redux 设计中间件的要求，柯里化的特性也在这里完美的体现。 涉及的代码createStore.ts、compose.ts、applyMiddleware.ts createStore 所有 store 集中所在，这里包括了监听变化，数据存储、替换 reducer、中间件等处理逻辑。 compose 使用数组 reduce 的特性，让数组内的函数从左到右层层向内嵌套，并使用柯里化，把真实的 args 实参传递给最里面的函数。 applyMiddleware 给每一层的中间件函数传递 getState 与改造的 dispatch，而真实的 dispatch 使用 compose 传递给最里面一层的中间件，其他层的 dispatch 都是使用 compose 的第二调用的函数，因此中间件的要使用多层函数而最里层的函数接受 compose 的第三调用的函数的入参，既 action 数据。 compose 实现在 redux 中 compose 的实现很简洁，但又比较难吃透，因为对数组的 reduce 与闭包结合的理解不够 以下为它的源码: 1234567891011function compose(...funcs: Function[]) &#123; if (funcs.length === 0) &#123; return &lt;T&gt;(arg: T) =&gt; arg; &#125; if (funcs.length === 1) &#123; return funcs[0]; &#125; return funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)));&#125; 当一次调用 compose 时，compose 接受多个函数形参，使用扩展扩展运算符获取把所有函数入参以数组的形式获取到，然后当函数个数为 0 时返回一个空数组，当函数个数为 1 时直接返回当前函数，而大于 1 时，使用 reduce 累计函数，让函数之间形成嵌套关系，如 123compose(fn1, fn2, fn3);// === 等价于fn1(fn2(fn3(...args))); 由于 funcs.reduce 里面使用了箭头函数，理解起来会有点困难，所以转化为以下的: 12345funcs.reduce(function (a, b) &#123; return function (...args: any) &#123; return a(b(...args)); &#125;;&#125;); 而当使用 reduce 累计函数时,如累计 fn1、fn2、fn3，由于 reduce 没有使用默认值，所以第一次遍历的 a、b 分别为 fn1、fn2,而第二次遍历为 reduce 返回的函数与 fn3，累计结束。 1234567891011121314151617181920// 第一次遍历a = fn1;b = fn2;function (...args: any) &#123; return fn1(fn2(...args)); &#125;;// 第二次遍历a = function (...args: any) &#123; return fn1(fn2(...args)); &#125;;b = fn3;// 最后累计出来的函数function (...args: any) &#123; return (function(...args) &#123; return fn1(fn2(...args)); &#125;)(fn3(...args));&#125;; 当我们调用最后累计出来的函数(既第二次调用 compose)时，就会先调用 fn3、fn2、fn1 这样的顺序去执行，但从源码中是把 store.dispatch 为参数传入 1dispatch = compose&lt;typeof dispatch&gt;(...chain)(store.dispatch) 而我们每个 fn 都是嵌套函数，如: 12345function fn1(next: any) &#123; return function (targs1: any) &#123; next(targs1); &#125;;&#125; 当我们 compose 第二次调用完后返回的 fn1 的内层函数 123function(targs1: any)&#123; next(targs1); &#125;; 然后当我们第三次调用 compose 时就会执行 fn1 内层函数，而 next 是 fn2 的内层函数，所以执行顺序为 fn1、fn2、fn3 的内层函数，并把 fn1 的 targs1 一层层传递下去，让每一层对其进行改造或获取处理等然后继续传递下去，直到遇到真正的 dispatch,既 store.dispatch,最后触发 redux 数据更新。 总结:compose(funcs)(dispatch)(action),首先会把函数数组改造成嵌套数组，然后第二次调用 dispatch，第三次传入需要修改的数据 action执行顺序为 *代表内层函数 123fn1(fn2(fn3(dispatch)))fn3-&gt;fn2-&gt;fn1-&gt;fn1*-&gt;fn2*-&gt;fn3* 洋葱模型 applyMiddleware 实现源码: 12345678910111213141516171819202122232425262728function applyMiddleware( ...middlewares: Middleware[]): StoreEnhancer&lt;any&gt; &#123; return (createStore: StoreCreator) =&gt; &lt;S, A extends AnyAction&gt;( reducer: Reducer&lt;S, A&gt;, ...args: any[] ) =&gt; &#123; const store = createStore(reducer, ...args) let dispatch: Dispatch = () =&gt; &#123; throw new Error( 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.' ) &#125; const middlewareAPI: MiddlewareAPI = &#123; getState: store.getState, dispatch: (action, ...args) =&gt; dispatch(action, ...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose&lt;typeof dispatch&gt;(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; applyMiddleware 是三层，第一次调用传递中间件数组 middlewares，而第二次调用 applyMiddleware 传递 createStore 创建 Store 的，第三次调用传递 reduces 与初始化 State(preloadedState)。 而 applyMiddleware 调用二三次都在createStore.ts里 1234return enhancer(createStore)( reducer, preloadedState as PreloadedState&lt;S&gt; ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext 然后中间件需要编写三层函数，第一层是为了传递getState与改造的dispatch的，二三层是为了 compose 实现的，而改造的 dispatch 是如上的fn1*，这样只要不是调用到真正的 dispatch，那么 dispatch 后都会把所有的中间件都走一遍并把数据 action 也传递进去了，那样中间就可以灵活的处理数据。 thunk 实现1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123; if (typeof action === \"function\") &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; thunk 也是先接受改造的 dispatch 与 getState，然后接受 next，从上可知 next 最后一个就是真实的 dispatch，而 thunk 为了实现异步，判断了 action 是否为函数，如果是函数就把改造的 dispatch 与 getState，这样就简单的实现了 redux 只是异步的操作。 而中间件的实现最少要三层函数，因为第一层是给 applyMiddleware 内把改造的 dispatch 与 getState 传入的，而第二三层是给 compose 使用的，因为 compose 调用中间件函数的第一次传入 next(下一次函数)或 dispatch，第二次传入 action 数据，而 action 数据也是 redux 需要的数据，用过 redux 的都知道 reduce 的 action，而这个 action 与这里的是一样的。 从 redux 实现的中间件机制可知，只要我们明确功能是干什么的，核心是什么，那么我们就可以从核心内容在合理的范围内进行实现可预测的扩展机制，从而使功能尽量可面对未来的各种变化而进行扩展适配来符合变化，而 redux 的核心就是变化的数据与触发数据变化的方法，所以我们可以从这方面下手。","tags":[{"name":"redux","slug":"redux","permalink":"https://793338023.github.io/tags/redux/"}]},{"title":"了解react-router的实现","date":"2020-05-30T04:37:36.000Z","path":"2020/05/30/了解react-router的实现/","text":"前言react-router 的路由是是基于 history 实现的，而我们可以根据不同的使用场景，使用不同的包，如浏览器上使用react-router-dom,而react-router是一个 monorepo 项目，使用 yarn 的工作空间管理 node_modules 的包，所以 package 目录下的包是没有 node_modules 的，在scripts\\build.js里有它的打包方式，是进入每个 package 的包目录下进行打包，而且是使用了 roullup 打包。 1234567891011121314151617const path = require(\"path\");const execSync = require(\"child_process\").execSync;function exec(cmd) &#123; execSync(cmd, &#123; stdio: \"inherit\", env: process.env &#125;);&#125;const cwd = process.cwd();[\"react-router\", \"react-router-dom\", \"react-router-config\"].forEach( (packageName) =&gt; &#123; process.chdir(path.resolve(__dirname, \"../packages/\" + packageName)); exec(\"yarn build\"); &#125;);process.chdir(cwd); 而react-router包是其他包的基础包，就是其他包都会去引用它，就是其他包都在基础包的功能上新增功能来实现到符合不同场景的使用，所以有部分的功能都是直接包基础包的功能进行导出或增强而已。 而react-router只是进行了组件层的实现，真正的路由逻辑都在 history 这个包里面，如 Prompt、Route、Router 等组件的实现，而纯粹地址变化的路由实现是 history 实现的，包含三种模式createBrowserHistory H5 的 history 模式、createHashHistory URL 的 hash 模式、createMemoryHistory 无输入地址栏的内存记录模式，这是对 Native 场景很有用。 react-router组件间数据的传递使用了React.createContext，而Router组件是数据提供方，而其他组件基本上都是数据消费方，所以我们都要使用Router放置在组件的顶层，让其他的组件都包含在它之下使用。 Router我们在使用的react-router-dom导出的 BrowserRouter 与 HashRouter 其实在实现上是没有很大的区别的，只是在使用 createBrowserHistory 与 createHashHistory 的区别，它们都是简单的封装了 Router。 如 HashRouter: 1234567class HashRouter extends React.Component &#123; history = createHashHistory(this.props); render() &#123; return &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125; /&gt;; &#125;&#125; 就调用了 createHashHistory 让路由设置为 hash 模式的路由，而 Router 的使用方式都是一样的。 Routeroute 组件实现关键在match，因为这是路由匹配决定是否加载组件。 12345const match = this.props.computedMatch ? this.props.computedMatch // &lt;Switch&gt; already computed the match for us : this.props.path ? matchPath(location.pathname, this.props) : context.match; 从以下可以知道 route 组件渲染路由匹配组件，而第一层三元表达式就是决定是否加载组件，而其他的三元表达式是根据在 route 组件传入组件方式进行组件加载，从中可以看出 props 传入的加载组件顺序是 children、component、render 12345678910111213141516171819&lt;RouterContext.Provider value=&#123;props&#125;&gt; &#123;props.match ? children ? typeof children === \"function\" ? __DEV__ ? evalChildrenDev(children, props, this.props.path) : children(props) : children : component ? React.createElement(component, props) : render ? render(props) : null : typeof children === \"function\" ? __DEV__ ? evalChildrenDev(children, props, this.props.path) : children(props) : null&#125;&lt;/RouterContext.Provider&gt; Switch组件的子组件要的是 route 组件，因为它主要的作用使用只要匹配中后就不再匹配，就只渲染当前的 route 组件，而它实现是React.Children.forEach遍历所有的子组件，所以要实现只匹配一次，那么就要使用它包囊，否则无法生效。 1234567891011React.Children.forEach(this.props.children, (child) =&gt; &#123; if (match == null &amp;&amp; React.isValidElement(child)) &#123; element = child; const path = child.props.path || child.props.from; match = path ? matchPath(location.pathname, &#123; ...child.props, path &#125;) : context.match; &#125;&#125;); element 当前组件，match 为匹配情况，如果匹配中，从判断match == null可知就再也无法进入遍历的赋值逻辑。 PromptPrompt 是 react-router 唯一的路由守卫，不像 vue-router 钩子特别丰富，它的作为就是路由离开时的操作，需要匹配 history 的 getUserConfirmation 使用，因为真正拦截路由的时 getUserConfirmation，而 Prompt 只是一个离开时是否渲染的组件，它的实现很简单，就是基于 Lifecycle 生命周期组件做了一些添加信息，而它的作用就是在全局的路由里进行一些离开是否需要提示或二次确认是否离开的操作，如我们实现一个有大量填写内容的页面，如果误操作直接路由离开，那么可以会因为丢失数据，这样的用户体验是很差的，所以我们可以使用这个功能就是二次确认，来提示用户是否要放弃这些数据。 123456789101112131415161718192021import React from \"react\";class Lifecycle extends React.Component &#123; componentDidMount() &#123; if (this.props.onMount) this.props.onMount.call(this, this); &#125; componentDidUpdate(prevProps) &#123; if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps); &#125; componentWillUnmount() &#123; if (this.props.onUnmount) this.props.onUnmount.call(this, this); &#125; render() &#123; return null; &#125;&#125;export default Lifecycle; 而添加信息，它调用的是 history 的 block，block 会接受一个入参 prompt，然后会把 prompt 保存起来，当调用 getUserConfirmation 会当一个参数传入，而它的第二参数为 callback，当 callback 传入为 true 时就跳转路由，传入为 false 则停止跳转，而 history 内部路由跳转实现也是基于 getUserConfirmation 实现的。 123456789101112transitionManager.confirmTransitionTo( location, action, getUserConfirmation, (ok) =&gt; &#123; if (ok) &#123; setState(&#123; action, location &#125;); &#125; else &#123; revertPop(location); &#125; &#125;); confirmTransitionTo 的第四个参数就是决定了是否跳转路由。 history 的属性了解123456789101112131415&#123; length, // 历史堆栈高度 action, // 当前导航动作有 pushpopreplace 三种 location: &#123; pathname, // 当前 url search, // queryString hash, // url hash &#125;, push(path[state]), // 将一个新的历史推入堆栈 (可以理解为正常跳转) replace(path[state]), // 替换当前栈区的内容 (可以理解为重定向) go(number), // 移动堆栈指针 goBack(number), // 返回上一历史堆栈指针 -1 goForward(number), // 前进到下一历史堆栈指针 +1 block(string | (location, action) =&gt; &#123;&#125;) // 传入提示信息，监听并阻止路由变化&#125; react-router 其实它的实现没有想象那么复杂，可以说只是实现了路由该有的功能，而一些扩展功能，它完全没有实现，保留最大的灵活性给使用者，让使用者根据需要自己完成所需的扩展实现，如鉴权，我们要根据二次封装 Route 组件实现一个鉴权路由，没有使用那些所谓的路由守卫的功能，因此我们可以通俗的理解为 react-router 就是一个普通的组件，在我们需要的时候就加载使用，不需要时就不加载，只是它比我们的组件多了一个根据路由匹配出需要加载的组件而已。 而实现 keep-alive，我们可以考虑使用react-activation,这个可以查看react-组件缓存的方式 而 hooks 方面可以使用 useHistory、useLocation、useParams、useRouteMatch 获取数据或方法，就不必使用 withRouter。 basename 设置路由的默认前缀路径，就是基础路径 basePath。","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"ora-终端loading动画与shellJs","date":"2020-05-27T14:09:42.000Z","path":"2020/05/27/ora-终端loading动画与shellJs/","text":"ora如果有深入进行过前端构建的，一定会遇到除了 webpack 等构建工具之外的实现前端自动化的过程，比如编译、git 提交、发布一步完成，无需开发者进行多次的指令操作等，那么一般当我们合并这些流程后等待时由于命令行界面就只有我们输入的内容外没有任何的提示而卡在这等待会感觉体验特别差，而 ora 就是为了解决这个问题的，就是我们在客户端界面上发送请求后需要一个 loadding 的动画一样，而 ora 就是让命令行界面有一个spinner旋转动画的效果。 使用方式例子: 123456789const ora = require(\"ora\");const spinner = ora(\"npm publish .\").start();setTimeout(() =&gt; &#123; spinner.succeed(\"成功\"); // 或 // spinner.fail(\"失败\");&#125;, 2000); ora 方法的入参为开始显示的内容，成功或失败后的入参为结果的内容。 如果没有特殊要求就是那么简单，而且操作的体验效果也很棒。 以下是ora的官方例子 ora 的例子代码 shellJs就是让我们可以使用 node 的方式，写 shell 脚本，就像平时操作 Linux 上的 shell 一样， 比如 Linux 上，在 temp 目录下生成 test.js 文件: 1touch temp/test.js 而使用 ShellJs 也可以实现，而且不需要考虑操作系统的问题 123const shell = require(\"shelljs\");const &#123; touch &#125; = shell;touch(\"temp/test.js\"); 效果是一样的 使用 sed 添加 package 版本号 123456sed( \"-i\", /(version.*:[\\W]*)\\d+\\.\\d+\\.[\\w-]+/, \"$10.1.190\", path.resolve(__dirname, \"../../package.json\")); $1 为匹配中的第一组内容，那么我们可以使用匹配中的组加上替换的版本号，就可以直接对 package.json 的版本进行替换 而 shellJs 中exec是我觉得最有用的方法，因为它可以进行执行的指令，如npm run build 如: 123456789101112131415161718192021222324252627282930const shell = require(\"shelljs\");const chalk = require(\"chalk\");const ora = require(\"ora\");const &#123; which, exec &#125; = shell;function installYalc() &#123; return new Promise(function (res, rej) &#123; console.log(`全局安装: $&#123;chalk.green(\"yalc\")&#125;`); const spinner = ora(\"install yalc\").start(); exec(\"npm i -g yalc\", &#123; silent: true &#125;, function (code, stdout) &#123; if (code !== 0) &#123; spinner.fail(stdout); rej(); &#125; else &#123; spinner.succeed(stdout); res(); &#125; &#125;); &#125;);&#125;async function hasYalc() &#123; if (!which(\"yalc\")) &#123; await installYalc(); return true; &#125;&#125;module.exports = hasYalc; 而 exec 最好是使用异步，否则会卡着终端。 shell 例子 yalc最好的 link 方法 它的使用很简单，就是全局安装，然后当前项目发布，联调项目 add 就行了，联调完后yalc remove --all 参考资料yalc github","tags":[{"name":"node","slug":"node","permalink":"https://793338023.github.io/tags/node/"}]},{"title":"umi体验","date":"2020-05-18T04:11:35.000Z","path":"2020/05/18/umi体验/","text":"umi 体验","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"np与组件模板生成","date":"2020-05-16T14:29:36.000Z","path":"2020/05/16/np与组件模板生成/","text":"np 与组件模板生成","tags":[{"name":"npm","slug":"npm","permalink":"https://793338023.github.io/tags/npm/"}]},{"title":"前端开发规范","date":"2020-05-15T15:39:07.000Z","path":"2020/05/15/前端开发规范/","text":"前端开发规范 git 提交规范","tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://793338023.github.io/tags/代码规范/"}]},{"title":"代码规范eslint","date":"2020-05-08T15:27:44.000Z","path":"2020/05/08/代码规范eslint与stylelint/","text":"eslintESLint 是一个 Javascript Linter，帮助我们规范代码质量，提高团队开发效率。 现在搭建项目一般都是使用现有的脚手架然后进行调整。 而且 typescript 的代码 lint 检查也转战为 eslint 了，tslint 已经是历史了。 eslint 带来的好处: 避免代码错误 写出最佳实践的代码 规范变量使用方式 规范代码格式 更好的使用新的语法 现在大家比较认可的代码规范: standardjs airbnb ESLint 的规则已经完全插件化了。每一个规则都是一个插件并且你自由的添加修改规则。 ESLint 中文官网 Prettiereslint 虽然能帮助我们提高代码质量，但并不能完全统一编码风格，因为这些代码规范的重点并不在代码风格上，虽然有一定的限制。 prettier 是一个能够统一团队编码风格的工具，能够极大的提高团队执行效率，统一的编码风格能很好的保证代码的可读性。 而且我们能把 Prettier 集成到 eslint 里。 使用 安装初始项目 1npx create-react-app eslint-demo --typescript 安装 ESLint 解析 TypeScript 的依赖 1yarn add eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin -D 初始配置 1npx eslint --init 根据需要选择需要的配置，然后安装初始需要的包，最后会生成一个.eslintrc.js，里面已经初始化好一些配置了。 我们把由Create React App团队提供的规则&quot;react-app&quot;添加进去。 12345module.exports = &#123;... extends: [&quot;plugin:@typescript-eslint/recommended&quot;, &quot;react-app&quot;],...&#125;; 我们对 TypeScript 和 React 进行了 规范，此时需要选择一种代码格式化程序。前面提到的 Prettier 将是首选工具，因为它在检测和修复样式错误方面做的很出色，并且和 ESLint 有很好的集成。 安装 prettier 依赖 1yarn add prettier eslint-config-prettier eslint-plugin-prettier -D 12345module.exports = &#123;... extends: [&quot;plugin:@typescript-eslint/recommended&quot;, &quot;react-app&quot;,&quot;plugin:prettier/recommended&quot;],...&#125;; 最后添加提交检测具体操作查看 具体参考，可查看 GitHub 例子的配置github 的 Demo 例子 由于这种方式是不是在开发热更新报错，若需要这方面的，需要另外设置 资料使用 ESLint+Prettier 规范 React+Typescript 项目自搭 react+webpack 的 ESlint","tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://793338023.github.io/tags/代码规范/"}]},{"title":"react-组件缓存的方式","date":"2020-05-05T09:02:14.000Z","path":"2020/05/05/react-组件缓存的方式/","text":"缓存方式 数据缓存，把组件的数据保持起来 从显示上实现，样式上的显示隐藏方式，如display:none 伪造组件，然后把真实所需的组件移位，渲染到 HTML 的节点保持与伪造组件一致 数据缓存这是最常用的缓存方式，而且也是最符合 react 的，因为 react 就是为了 UI 层实现的，从数据到数据被直观的显示。react 是一个面向数据的，所以我们可以把所有的内容保存为一份数据，然后当我们需要这份数据时让它经过 react 转换为我们显示的页面。 但这种方式实现缓存也是最辛苦的，首先我们要把界面上操作的信息保存为数据，然后我们还要对浏览器操作的行为也转换为数据，如滚动高度，而且需要每个需要缓存的页面都进行这样的操作，这个工作量是很大的，并且还需要考虑性能问题，定制缓存策略，否则一些数据量的页面保存那么几份就可以把客户端玩崩。 数据缓存的方式: redux这也是最好的方式 本地缓存如果数据需要跨客户端 Tabs 或缓存时效，那么这也是比较好的方式，只是它的存储量有限 利用模块化的闭包如果对 redux 操作觉得很麻烦，而且会触发状态更新，那么可以新建一个文件进行数据保存 利用上层组件状态机保存数据如果缓存的数据只想在某个组件没有被卸载时进行缓存操作，也可以使用上层数据进行数据保存 从显示上实现对组件添加display:none。 简单粗暴，因为没有卸载组件，所以可以不用管页面的数据状态的保存情况。只需要管理好恢复显示、隐藏与正常 re-render，再恢复滚动位置即可。 伪造组件伪造组件的实现思路是利用包囊组件 children 方式把 children 传递出现，在一个缓存组件区内被渲染，而当前组件正常卸载重载，并且卸载这个组件也把它传递出去的 children 的 DOM 节点 remove 了，而重新加载这个组件时由于虚拟 DOM 的部分已经缓存了，还有 DOM 节点的 node 也保存了一份，而使用 react，最重要的就是虚拟 DOM 这部分了(既 FiberNode)，因为组件的实例就在这里，而数据就在实例里，而 react 就是根据最后处理出的虚拟 DOM 的结构来进行渲染的，所以只要虚拟 DOM 不被卸载，那么组件其实就存在，只是 DOM 节点被删除了，所以当伪造组件被加载后重新把保存的 node 节点 append 到 HTML 结构上那么就能在当前页面正常显示了，这样在 HTML 结构查看时就和正常的组件一模一样，只是使用 react 的工具查看结构时才会发现缓存组件区里的组件实例是没有卸载的，FiberNode 还是存在的。 伪造组件例子伪造组件启发是来源这个 github react-activation，react 的实现真的很大层度给予开发最大灵活性 而目前来看我觉得react-activation的缓存实现是入侵性最小的，不像别的组件缓存，都把 react-router 包都替换了，因为是个人开发的，如果有一天不维护了或你使用它出现很大 BUG，作者不能及时修复，又或者跟不上 react-router 的更新，那么我觉得它就是一个大坑。 还有别的零散的组件缓存包，但我觉得大同小异，但react-activation实现与使用都是比它们好一些的，而且如果出现的 BUG，作者不及时修改，我们也可以快速去除它，及时止损，因为一般使用缓存都是前进后退这样的，所以对项目来说还是可以接受的范围，如果与核心功能有关，去除后影响很大，那也可以使用display:none替换为方案，只是要干掉路由，所以从耦合性比较，react-activation还是值得使用的，而且只要你了解它的源码，出问题后也可以自行修复。 使用 react-activation 例子 总结以上的就是组件的缓存方式的思路，因为 react 的机制问题，react 没有实现缓存，路由没有实现缓存，因为 react 给我们最大权限去操作代码，所以 API 方面会很少，而且如果没有良好缓存策略，会导致很严重的性能问题，而 vue 的 keep-alive 使用了 LRU 算法限制缓存数量来让缓存占用内存限制一个区间内。","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"qiankun微前端爽一把","date":"2020-05-03T08:07:44.000Z","path":"2020/05/03/qiankun微前端爽一把/","text":"为什么不使用 Iframe 微前端现在越来越火，因为大家尝到微服务的甜头，而前端行业，都是别人好的东西往家里搬，所以大家都纷纷搭建属于自己的那个微前端架子，那么最好的方式当然开箱即用，所以就有了 qiankun，qiankun 在使用者推动下会越来越符合大众的微前端方案。 qiankun 微前端 Demo 与文档 例子使用了 react 脚手架与 vue 脚手架","tags":[{"name":"微前端","slug":"微前端","permalink":"https://793338023.github.io/tags/微前端/"}]},{"title":"react/hooks之二","date":"2020-05-02T14:24:20.000Z","path":"2020/05/02/react-hooks之二/","text":"动机使用 hooks 的动机: 在组件之间复用状态逻辑很难； class 组件要实现复用逻辑，通常会以高阶组件的形式实现或render props,但它们需要重新组织你的组件结构并让组件嵌套变深，代码难以理解，形成“嵌套地狱”。 复杂组件变得难以理解； 当一个简单的组件，由于需要的迭代，组件间的状态散布到生命周期的各个时期里，而状态之间既互相关联又互相不影响，导致代码拆分困难，组件的逻辑与代码越来越庞大，变得难以阅读理解。 class 让开发人员与计算机都难理解，而表现为函数式编程比 OOP 更加简单； class 你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器，当然可以使用箭头函数解决。class 不能很好的压缩，并且会使热重载出现不稳定的情况。 useReduceruseState 其实就是阉割版的 useReducer,但在实际开发中 useState 才是主要被使用的,而 useReducer 是 useState 的替代方案。 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。 比如直接在函数组件里调用请求之类的，需要等请求的数据回来后才进行某些操作，那么你就要维护一个 loading 与 data 的 state，而异步的 state 是 useState 后就立刻 render 一次，那么执行两次 useState，就会执行两次的 render，这就有可能出现一些执行顺序上的 BUG 问题，所以我们可以使用 useReducer 把它们维护到一个 state 上，并且 useReducer 里的 reducer 可以执行一些逻辑上的操作。如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; useReducer, useEffect &#125; from &quot;react&quot;;interface InitState &#123; data: any[]; page: &#123; [key: string]: any &#125;; loading: boolean;&#125;const initState: InitState = &#123; data: [], page: &#123; total: 10, record: 10 &#125;, loading: true,&#125;;function reducer( state: InitState, action: &#123; type: string; payload: InitState &#125;) &#123; switch (action.type) &#123; case &quot;a&quot;: return &#123; ...action.payload &#125;; case &quot;b&quot;: return &#123; ...action.payload &#125;; default: return state; &#125;&#125;const useRequest = () =&gt; &#123; const [state, dispatch] = useReducer(reducer, initState); useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; const data = &#123; type: &quot;a&quot;, payload: &#123; data: [&quot;zhhh&quot;, &quot;xxx&quot;, 3, 4], page: &#123; total: 51, record: 999 &#125;, loading: false, &#125;, &#125;; dispatch(data); &#125;, 1000); &#125;, []); return state;&#125;;export default useRequest; github 例子 官方 usereducer 说明 问题hooks 接入 React-Redux 后 mapDispatchToProps 的第二参数是有问题的，如果使用了第二参数，那么每当 connected 的组件接收到新的 props 时，mapDispatchTopProps 都会被调用，这意味着组件会返回一个新的 props，导致使用 useEffect 监听 props 的属性的都会被触发掉而出现一些 BUG 问题，当然如果有正确判断规则，那么这个对于项目来说问题不大，就是多了一次 render 机会，不会严重影响程序与用户体验。 Redux with Hooks 源码浅析 React 通过单链表来管理 Hooks 按 Hooks 的执行顺序依次将 Hook 节点添加到链表中 每个 Hook 节点通过循环链表记住所有的更新操作 在 update 阶段会依次执行 update 循环链表中的所有更新操作，最终拿到最新的 state 返回 FiberNdoe 节点中会又一个 updateQueue 链表来存放所有的本次渲染需要执行的 effect。 mountEffect 阶段和 updateEffect 阶段会把 effect 挂载到 updateQueue 上。 updateEffect 阶段，deps 没有改变的 effect 会被打上 NoHookEffect tag，commit 阶段会跳过该 Effect。 为什么只能在函数顶层使用 Hooks 而不能在条件语句等里面使用 Hooks? 其实 hooks 就是把挂载与更新分开来了，如果组件第一次加载那么就会走 mount 的函数，更新后走 update 的函数，由于函数组件其实就是 render 函数，所以每次的更新都会把整个函数都重新执行一遍，那么执行的函数里的钩子就要与第一次执行时是一致，这是为什么，你可以想象一下，数组，数组只有下标，而每次执行函数后函数里的数组都是重新 push 一遍内容的，那么如果组件第一次加载时保存一个全局钩子数组，与这次的钩子的 push 进去的不一致，那么全局钩子与更新的钩子匹配时整个更新就会错乱。 而像 preact 模拟 hooks 直接就使用数组，没有使用链表结构，然后每次获取当前 hooks 钩子都是 index 索引加一方式。 useState 的实现与 useReducer 是一样的，因为 useState 返回的就是一个 state 与 dispatch，只是它的 action 是内容实现的，action 就是更新的内容，不需要有 type 这样的字段。 资料React Hooks 源码解析（3）：useStateReact Hooks 源码模拟与解读React Hooks 源码解析，原来这么简单～","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"linux002","date":"2020-05-02T06:59:42.000Z","path":"2020/05/02/linux002/","text":"平时使用，记事内容 惯用账号密码:rootadmin123 virtualbox 虚拟机的使用-关于没有 IP 地址https://www.cnblogs.com/caizhw3/articles/virtualbox_net_surfingInternetBasic.html msconfig 递归创建目录mkdir -p zz/xx/cc 删除非空目录rm -rf zz 创建空文件touch aa.js bb.js copy 文件cp aa.txt /bb 整个文件夹cp -r aa /bb copy 移动文件mv 重命名\\移动目录或文件 只读文件内容cat -n 只读 ls &gt;&gt;a.txt当 a.txt 不存在，创建，存在覆盖，把指令的内容追加输出 a.txtls &gt; a.txt如上，但是是覆盖 指令&gt;&gt;追加&gt;覆盖 echo aaabbb &gt;&gt; a.txt cal 时间 head -n 行数 文件查看前几行tail -f 文件实时监听尾部几行 tail -100f 文件尾部 100 行 查看历史记录history [n] history 10 查看最近十次的指令 find 查看指定目录下查找文件或目录 find [搜索·范围][选项] 12345find / -name \\*.txt 按文件名查找find / -size +20M 大于 20M 的文件find / -size -20M 小于find / -size 20M 等于20k grep 管道符号| grep [选项] 查找内容 源文件 -n 显示行号-i 忽略大小写 ##文件名+内容grep -r “查询内容” 文件目录 ##只显示包含内容的文件名grep -r -l “查询内容” 文件目录 ##文件名+内容find 文件目录 -type f |xargs grep “查询内容”; grep -r -l zhangzhi ./ zip/unzip zip -r my.zip /home-r 专门压缩目录的，压缩后文件名称 压缩文件路径 unzip -d /opt/temp/ my.zip -d 解压到的目录， 解压后目录 解压的文件路径 tar解压tar -zxvf aa.tar.gz压缩，指定压缩文件名称，可以多个文件，tar -zcvf aa.tar.gz a.txt b.txt 关机halt -p wifi 查看netsh wlan show profiles查看某个 wifi 的密码netsh wlan show profiles 名称 key=clear 临时关闭防火墙/etc/init.d/iptables stop查看关闭后的状态/etc/init.d/iptables status iptables: Firewall is not running.","tags":[{"name":"linux","slug":"linux","permalink":"https://793338023.github.io/tags/linux/"}]},{"title":"gulp底层vinyl-fs","date":"2020-05-02T02:52:30.000Z","path":"2020/05/02/gulp底层vinyl-fs/","text":"vinyl-fs当你只想处理文件到文件的文件处理场景时可以使用vinyl-fs,而不必使用 gulp，因为 gulp 的 src、pipe、dest 的实现，就是使用了它。而 webpack\\rollup 都是模块化打包工具，这里模块一般都是把文件当成一个模块，然后处理完之后把所有模块整合，所以有时不符合场景，当然也是用 babel 的 cli，但它的处理可能会出现一些小问题，如目录里是单目录时输出的结构不符合等情况，所以结合总总的还是使用 vinyl-fs 进行文件流的处理比较简单方便且可以直接使用围绕 gulp 生态的包与使用 node 编程，完美。 当然 webpack\\rollup tree-shaking 加模块化打包机制，可以解决很多场景问题，所以推荐尽量使用 webpack\\rollup。 请查看 github","tags":[{"name":"gulp","slug":"gulp","permalink":"https://793338023.github.io/tags/gulp/"}]},{"title":"使用chrome排查内存泄露","date":"2020-05-01T06:09:14.000Z","path":"2020/05/01/使用chrome排查内存泄露/","text":"使用 chrome 排查内存泄露内存分析使用的工具包括 chrome 任务管理器、chrome 时间轴（低版本是 Timeline，高版本对应 performance）、chrome memory（低版本是 chrome profiles，主要用 JS 堆快照、JS 堆动态分配时间轴） chrome 的工具里提供了很多种方式去排查明确内存情况，但我觉得会其中的一些就够了，就好像使用 js API 一样，我们会 js API 里的某些就可以了，其他的不会，也可以使用我们懂的进行模拟，或快速上手其他 API。 而我喜欢使用Head snapshot生成某个时刻的内存快照，然后多进行几次进行比较，得出我的结果。 使用 Summary 如图 Constructor：构造函数，节点下的对象都是由改构造函数创建而来。 Distance：与根节点的距离。 Objects Count：对象个数及百分占比。 Shallow size：对象的直接内存总数，直接内存是指对象自身占用的内存大小。 Retained size：对象的最大保留内存，保留内存是指对象被删除后可以释放的那部分内存。 点击展开构造函数，可以看到所有构造函数相关的对象实例，@后面的数字是该对象实例的唯一标识符。 使用比较快照的，comparison Contructor - 表示使用此构造函数创建的所有对象 Distance - 显示使用节点最短简单路径时距根节点的距离 Shallow Size - 显示通过特定构造函数创建的所有对象浅层大小的总和。浅层大小是指对象自身占用的内存大小（一般来说，数组和字符串的浅层大小比较大） Retained Size - 显示同一组对象中最大的保留大小。某个对象删除后（其依赖项不再可到达）可以释放的内存大小称为保留大小。 #New - Comparison 特有 - 新增项 #Deleted - Comparison 特有 - 删除项 #Delta - Comparison 特有 - 增量 Alloc. Size - Comparison 特有 - 内存分配大小 Freed Size - Comparison 特有 - 释放大小 Size Delta - Comparison 特有 - 内存增量 常见的顶层构造函数： (global property)：全局对象和普通对象的中间对象，和常规思路不同。比如在 Window 上定义了一个 Person 对象，那么他们之间的关系就是[global] =&gt; (global property) =&gt; Person。之所以使用中间对象，是出于性能的考虑。 (closure)：使用函数闭包的对象。 (array, string, number, regexp)：一系列对象类型，其属性指向 Array/String/Number/Regexp。 HTMLDivElement/HTMLAnchorElement/DocumentFragment：元素的引用或者代码引用的指定文档对象。 在 Class filter(类过滤器)文本框中输入 Detached 可以搜索分离的 DOM 树。 一般来说排查过程是一个细心的活，因为 chrome 的工具提供了很多信息给我们，但代码方面可能不是自己写的，不能很明确这部分是否是真的有问题，因此我们只能根据 chrome 提供的文件名、方法、实例对象、DOM 节点等等去尝试这部分变化是否能给应用带来改进，而我觉得最常出问题应该是闭包这类。","tags":[{"name":"chrome","slug":"chrome","permalink":"https://793338023.github.io/tags/chrome/"}]},{"title":"React16/fiber","date":"2020-04-28T14:41:51.000Z","path":"2020/04/28/React16-fiber/","text":"前言react 在进行组件渲染时，从 setState 开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js 执行会占据主线程时间较长，会导致页面响应度变差，使得 react 在动画、手势等应用中效果比较差。 所以在 react v15 之前使用它做一些动画效果或大数据量处理渲染之类的都可能会出现卡顿等性能问题。 react v15 是函数调用栈，递归的方式，从父节点（Virtual DOM）开始遍历，以找出不同。将所有的 Virtual DOM 遍历完成后，reconciler 才能给出当前需要修改真实 DOM 的信息，并传递给 renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的 vDOM 树来说，reconciliation 过程会很长(大于浏览器渲染帧的时间 16ms)，在这期间，主线程是被 js 占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。 破解 JavaScript 中同步操作时间过长的方法其实很简单——分片。把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。React Fiber 把更新过程碎片化，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。维护每一个分片的数据结构，就是 Fiber。 React Fiber在 React Fiber 中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。 因为一个更新过程可能被打断，所以 React Fiber 一个更新过程被分为两个阶段(Phase)：第一个阶段 协调阶段 和第二阶段 提交阶段。 在第一阶段协调阶段，React Fiber 会找出需要更新哪些 DOM，这个阶段是可以被打断的；但是到了第二阶段 提交阶段，那就一鼓作气把 DOM 更新完，绝不会被打断。 这两个阶段大部分工作都是 React Fiber 做，和我们相关的也就是生命周期函数。 以 render 函数为界，第一阶段可能会调用下面这些生命周期函数，说是“可能会调用”是因为不同生命周期调用的函数不同。 第一阶段:componentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate 第二阶段:componentDidMountcomponentDidUpdatecomponentWillUnmount 因为第一阶段的过程会被打断而且“重头再来”，就会造成意想不到的情况。 例如已经执行到某个 Fiber 内的生命周期函数 componentWillUpdate，但由于已经到了一个渲染帧的时间，需要把控制权让出，让浏览器查看是否有任务需要执行，若有则废弃当前 Fiber，执行浏览器的任务，等浏览器让出控制权后重新执行这个 Fiber，所以才会出现二次执行生命周期 componentWillUpdate 的情况。 因此第一阶段中的生命周期函数在一次加载和更新过程中可能会被多次调用！ 但某些使用者在使用生命周期函数时会做一些奇怪的操作上，既违背这个生命周期提供的意义，如果出现二次调用就会出现各种 BUG，所以 react 把某些生命周期在过渡版本提示为废弃钩子，componentWillMount，componentWillReceiveProps，componentWillUpdate。 fiber 执行单元fiber 的实现方式为时间分片 + 链表结构，一个组件实例对应有一个 fiber fiber 其实就是虚拟 Dom。 fiber 维护了一个分片的数据结构，就是可终止可恢复的链表式数据结构。 如一个&lt;Card /&gt;组件的 fiber: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// FiberNode 结构如下：&#123; // 定义fiber节点类型，类组件指向构造函数，dom元素指向标签名称 type: Card, // Fiber类型，将React Element映射成对应的Fiber类型，用于说明协调过程中需要完成的工作 // HostRoot|HostComponent|ClassComponent|FunctionComponent... tag: 1, // 不同tag代表不同类型的副作用 effectTag: 1, firstEffect: null, lastEffect: null, // 单链表结构，方便遍历fiber树上有副作用的节点 nextEffect: FiberNode|null, // 第一个子fiber child: FiberNode|null, // 指向父fiber，表示当前节点处理完毕后，应该向谁提交自己的结果effect list return: FiberNode|null // 兄弟fiber slibing: FiberNode|null, // 当前父fiber中的位置 index: 0, // fiber实例对象，指向当前组件实例 stateNode: Card, // setState待更新状态，回调，DOM更新的队列 updateQueue: null, // 当前UI的状态，反映了UI当前在屏幕上的表现状态 memoizedState: &#123;&#125;, // 前次渲染中用于决定UI的props memoizedProps: &#123;&#125;, // 即将应用于下一次渲染更新的props pendingProps: &#123;&#125;, // 和组件Element中的key,ref一致 key: null, ref: null, // fiber更新时基于当前fiber克隆出的镜像，更新时记录两个fiber diff的变化；更新结束后alternate替换之前的fiber成为新的fiber节点 alternate: &#123;&#125;, // 标记子树上待更新任务的优先级 （最新版的react做了变更，改由过期时间实现，时间越大，setState越频繁，优先级就越高） pendingWorkPriority: number&#125; 通过 child, slibing, return 的结构关联，可知它是一个单链表结构。 时间分片实现时间分片的目的只是为了在做一些大批量 DOM 渲染时，让客户端不要给客户出现卡顿的不流畅现象。 而使用浏览器提供的 API 是最好的，requestIdleCallback 和 requestAnimationFrame，如果需要兼容低版本浏览器，可以使用 setTimeout 模拟，但可能会出现一瞬间的白屏情况。 setTimeout 闪屏现象在 js 引擎里，setTimeout 的事件处理函数会先等待到目标时间后执行，然后进入事件队列里等待主线程的空闲，因此 setTimeout 的实际执行时间可能会比其设定的时间晚一些。 那么我们在 setTimeout 设置的时间与浏览器的渲染时间很大可能是不一致的，而且很大可能是 setTimeout 被主线程处理比渲染要晚一些，导致 setTimeout 里的渲染内容只能在下一帧渲染时被渲染，这是丢帧现象。 例子 没有用时间分片 1234567891011121314151617// 记录任务开始时间let now = Date.now();// 插入十万条数据const total = 100000;// 获取容器let ul = document.getElementById(\"app\");// 将数据插入容器中for (let i = 0; i &lt; total; i++) &#123; let li = document.createElement(\"li\"); li.innerText = ~~(Math.random() * total); ul.appendChild(li);&#125;console.log(\"JS运行时间：\", Date.now() - now);setTimeout(() =&gt; &#123; console.log(\"总运行时间：\", Date.now() - now);&#125;, 0); 十万条数据渲染时会出现很明显的卡顿白屏等现象。 requestAnimationFrame 实现时间分片 123456789101112131415161718192021222324252627//需要插入的容器let ul = document.getElementById(\"app\");// 插入十万条数据let total = 100000;// 一次插入 20 条let once = 20;//总页数let page = total / once;//每条记录的索引let index = 0;//循环加载数据function loop(curTotal, curIndex) &#123; if (curTotal &lt;= 0) &#123; return false; &#125; //每页多少条 let pageCount = Math.min(curTotal, once); window.requestAnimationFrame(function () &#123; for (let i = 0; i &lt; pageCount; i++) &#123; let li = document.createElement(\"li\"); li.innerText = curIndex + i + \" : \" + ~~(Math.random() * total); ul.appendChild(li); &#125; loop(curTotal - pageCount, curIndex + pageCount); &#125;);&#125;loop(total, index); 在操作时很顺畅，体验很好。 宝藏资料这可能是最通俗的 React Fiber(时间分片) 打开方式React FiberReact Fiber 是什么fiberReact Fiber 初探","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"LRU算法","date":"2020-04-25T14:00:24.000Z","path":"2020/04/25/LRU算法/","text":"LRU 算法","tags":[{"name":"算法","slug":"算法","permalink":"https://793338023.github.io/tags/算法/"}]},{"title":"AST抽象语法树","date":"2020-04-18T00:49:52.000Z","path":"2020/04/18/AST抽象树/","text":"抽象语法树 AST在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。 (详细查看请 github 例子)[https://github.com/793338023/ast-tree]","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"npm安装机制","date":"2020-04-11T10:07:36.000Z","path":"2020/04/11/npm安装机制/","text":"从输入 npm install 后 项目下有 package.json，输入npm i,查询 node_modules 是否存在，不存在新增，存在在此下安装模块。 根据 package.json 的依赖模块，查询 node_modules 目录之中是否已经存在指定模块，若存在，不再重新安装，若不存在， npm 向 registry 查询模块压缩包的网址，下载压缩包，存放在本地的缓存目录里，解压压缩包到当前项目的 node_modules 目录。 这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm 目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。 1npm config get cache 获取模块，根据 dependencies 和 devDependencies 属性中的模块，递归获取，既工程本身是整棵依赖树的根节点(首层)，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。 获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 package.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。 获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。 查找该模块依赖，如果有依赖则回到第 1 步，如果没有则停止。 当前 npm 工程如果定义了钩子此时会被执行（按照 preinstall、install、postinstall、prepublish、prepare 的顺序），最后一步是生成或更新版本描述文件package-lock.json，npm install 过程完成。 缓存目录npm install或npm update命令，从 registry 下载压缩包之后，都存放在本地的缓存目录。 这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm 目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。 1npm config get cache 缓存目录可以加速某些操作如npm search或npm view都会先去缓存目录里查询，然后查询不符合条件的情况下才会请求远程仓库。 由于缓存目录的存在，我们可以使用 npm 的下载缓存包来实现离线下载的功能，这个就不描述。 但由于有了package-lock.json后，我们会经常遇到一些由于缓存问题而无法下载包的问题，因为npm install之后会计算每个包的 sha1 值，然后将包与他的 sha1 值关联保存在 package-lock.json 里面,下次 npm install 的时候会根据 package-lock.json 里面保存的 sha1 值去文件夹 %AppData%/npm-cache 里面寻找包文件，如果存在，就不用再次从远程仓库下载。 因为 npm 不同版本算出来的 sha1 有可能不完全一样，所以 npm 升级了，直接用不同版本 npm 生成的package-lock.json会报 sha1 不匹配的 error。 清除缓存npm cache verify重新计算%AppData%/npm-cache 下的文件是否与 sha1 值匹配，如果不匹配可能删除。 npm cache clean --force删除所有缓存文件 注意:npm 5 使用了新的包管理模式，所以在升级之后，请先清空一下本地缓存 1234npm cache clean --force// 清除失败，使用这个npm cache clear --force &amp;&amp; npm install --no-shrinkwrap --update-binary 模块扁平化由于 npm2 安装多级的依赖模块采用嵌套的安装方式，可能造成相同模块大量冗余的问题。所以 npm3 后会尽量把逻辑上某个层级的模块在物理结构上全部放在项目的第一层级(首层)里。 具体概括为以下三种情况： 在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级 在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块 在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方，既在当前二级模块下生成一个 node_modules 存放依赖模块。 2 实际上：npm3 后 仍然可能出现模块冗余的情况，如因为一级目录下已经有 v1.0 的 C 模块了，所以所有的 v2.0 只能作为二级依赖模块被安装，这样你就会看到如下的情况 1 而这种怎么解决了，我们要把依赖 v1.0 的模块更新到 v2.0，然后npm dedupe把 v2.0 放置到一个目录里，去除冗余模块 3 重复模块定义它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。因为package.json里的依赖包默认情况下使用^,这只能确定大版本相同，而这也导致每次根据package.json安装依赖时依赖包有版本偏差的问题，如作者修改一个 BUG，发布了个小版本，而你刚刚好又重新安装了，然后你没有问题，而你同事没有安装，出现 BUG，但从package.json上是无法体现的，在不了解^的情况下是很难排查的，但你可以根据package-lock.json知道你那个包更新了、和你同事不一致或在项目下载依赖时都根据package-lock.json去下载。 npm ci1npm ci 该命令与相似 npm-install，不同之处在于它用于自动化环境（例如测试平台，持续集成和部署），或者在任何情况下都要确保干净安装依赖项。通过跳过某些面向用户的功能，它可以比常规的 npm 安装快得多。它也比常规安装更加严格，这可以帮助捕获大多数 npm 用户增量安装的本地环境引起的错误或不一致。 简而言之，使用 npm install 和之间的主要区别 npm ci 是： 该项目必须具有现有的 package-lock.json 或 npm-shrinkwrap.json。 如果程序包锁中的依赖项与中的不匹配 package.json，npm ci 则将退出并显示错误，而不是更新程序包锁。 npm ci 一次只能安装整个项目：不能使用此命令添加单个依赖项。 如果 node_modules 已经存在，它将在 npm ci 开始安装之前自动删除。 它将永远不会写入 package.json 或执行任何软件包锁：安装实际上是冻结的。 npm 模块安装机制简介npm install 的实现原理","tags":[{"name":"npm","slug":"npm","permalink":"https://793338023.github.io/tags/npm/"}]},{"title":"webpack之plugin实现与vscode调试方式","date":"2020-04-06T15:09:35.000Z","path":"2020/04/06/webpack之plugin实现与vscode调试方式/","text":"Plugin由于 loader 作用范围是很明显的，所以就有了它的边界，那么超出这个边界的事情我们就可以使用 Plugin 去实现，这样 webpack 就可以适用用各种各样的场景，如 loader 很困难直接对多种规则的内容进行最后的整合然后输出，而且 loader 之间有顺序规则之类，如果规则与规则之间有关联且要按某种顺序进行执行，那么就很难实现，而这是使用 Plugin 实现是最好的。 Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。 一旦我们打开了 webpack 编译器和每个单独编译的大门，我们可以使用引擎做的事情是无限可能的。我们可以重新格式化存在的文件、创建派生文件、完全伪造一个新文件。 编一个 PluginTestPlugin 123456789101112131415161718192021222324252627282930313233class TestPlugin &#123; constructor(doneCallback, failCallback) &#123; this.doneCallback = doneCallback; this.failCallback = failCallback; &#125; apply(compiler) &#123; compiler.hooks.emit.tapAsync(&quot;生成md&quot;, (compilation, callback) =&gt; &#123; var filelist = &quot;构成生成的文件:\\n\\n&quot;; for (var filename in compilation.assets) &#123; filelist += &quot;- &quot; + filename + &quot;\\n&quot;; &#125; compilation.assets[&quot;filelist.md&quot;] = &#123; source: function () &#123; return filelist; &#125;, size: function () &#123; return filelist.length; &#125;, &#125;; callback(); &#125;); compiler.hooks.done.tap(&quot;完成成功&quot;, (stats) =&gt; &#123; this.doneCallback(stats); &#125;); compiler.hooks.failed.tap(&quot;完成失败&quot;, (err) =&gt; &#123; this.failCallback(err); &#125;); &#125;&#125;module.exports = TestPlugin; webpack.config.js 12345678910plugins: [ new TestPlugin( (p) =&gt; &#123; console.log(&quot;w完成-&quot;, p); &#125;, () =&gt; &#123; console.log(&quot;w失败-&quot;, p); &#125; ),], Webpack 启动后，在读取配置的过程中会先执行 new TestPlugin(options) 初始化一个 TestPlugin 获得其实例。在初始化 compiler 对象后，再调用 TestPlugin.apply(compiler) 给插件实例传入 compiler 对象。插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。并且可以通过 compiler 对象去操作 Webpack。但 Compiler 和 Compilation 都继承自 Tapable，所以我们可以使用 compilation.hooks.someHook.tap(…)等监听到广播出来的事件。但 apply 与 plugin 自定义比较简单。 1234567891011121314/*** 广播出事件* event-name 为事件名称，注意不要和现有的事件重名* params 为附带的参数*/compiler.apply(&apos;event-name&apos;,params);/*** 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。* 同时函数中的 params 参数为广播事件时附带的参数。*/compiler.plugin(&apos;event-name&apos;,function(params) &#123;&#125;); 调试不管是 npm 还是 webpack 都是基于 nodejs 的工具。所以最终是调试 node。 npm 方式调试package.json 文件 scripts 项中添加一个 key 为 debug 的配置，内容如下 123&quot;scripts&quot;: &#123; &quot;debug&quot;: &quot;node --inspect-brk=5858 ./node_modules/webpack/bin/webpack&quot; &#125; vscode Ctrl+shift+D切换为调试，选择Add Configuration。vscode 会自动生成一个 launch.json 文件，将文件的内容调整为以下内容 1234567891011121314151617&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;build&quot;, &quot;stopOnEntry&quot;: false, &quot;runtimeExecutable&quot;: &quot;npm&quot;, &quot;runtimeArgs&quot;: [&quot;run&quot;, &quot;debug&quot;], &quot;port&quot;: 5858 &#125; ]&#125; runtimeExecutable 要运行的 shell,runtimeArgs shell 运行时需要的的参数，这个类似 Node.js 的 child_process 模块的 spawn。 其中端口 port 配置需要和 inspect-brk 配置的端口保持一致。stopOnEntry 为 true 表示在运行的第一行代码中添加断点,点击开始调试按钮，即可进入如下界面 然后我们就可以在代码的行数上点击出现小红点，就为打上断点了。 运行 node 调试由于上面的调试方式需要在 package 里配置，program 将要进行调试的程序的路径，但 program 可以把运行路径写入，那么就可以直接触发 webpack 而进入调试，不用在项目加入任何配置。 123456789101112131415&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;webpack&quot;, &quot;stopOnEntry&quot;: false, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/node_modules/webpack/bin/webpack&quot; &#125; ]&#125; 当然我们还可以把调试放到 chrome 里，这个就不在这里配置了。 所谓的调试都是在 node 上进行了，而已都需要 --inspect-brk开启出一个调试服务。 一些常用配置说明123456789101112131415161718192021222324252627282930&#123; // 配置名称，将会在启动配置的下拉菜单中显示 &quot;name&quot;: &quot;C++ Launch (GDB)&quot;, // 配置类型，这里只能为cppdbg &quot;type&quot;: &quot;cppdbg&quot;, // 请求配置类型，可以为launch（启动）或attach（附加） &quot;request&quot;: &quot;launch&quot;, // 调试器启动类型，这里只能为Local &quot;launchOptionType&quot;: &quot;Local&quot;, // 生成目标架构，一般为x86或x64, // 可以为x86, arm, arm64, mips, x64, amd64, x86_64 &quot;targetArchitecture&quot;: &quot;x86&quot;, // 将要进行调试的程序的路径 &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, // miDebugger的路径，注意这里要与MinGw的路径对应 &quot;miDebuggerPath&quot;:&quot;D:\\\\mingw\\\\bin\\\\gdb.exe&quot;, // 程序调试时传递给程序的命令行参数，一般设为空即可 &quot;args&quot;: [], // 设为true时程序将暂停在程序入口处，一般设置为false &quot;stopAtEntry&quot;: false, // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, // 调试时是否显示控制台窗口，一般设置为true显示控制台 &quot;externalConsole&quot;: true, // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &quot;preLaunchTask&quot;: &quot;g++&quot; //传递给运行时可执行文件的可选参数。 &quot;runtimeArgs&quot;:[]&#125; 1234567891011$&#123;workspaceRoot&#125; VS Code当前打开的文件夹$&#123;file&#125; 当前打开的文件$&#123;relativeFile&#125; 相对于workspaceRoot的相对路径$&#123;fileBasename&#125; 当前打开文件的文件名$&#123;fileDirname&#125; 所在的文件夹，是绝对路径$&#123;fileExtname&#125; 当前打开文件的拓展名，如.json github 例子资料 这篇资料讲的很详细，上面就不进行详细了。Webpack 原理-编写 Plugin如何开发一个 plugin 例子 以下都是钩子的 API，不懂的可以进行查询webpack 官网-Tapablewebpack 官网-compiler APIwebpack 官网-compilation API 以下都是 vscode 调试相关的，比如怎么调试 webpack 插件或 loadervscode 调试 webpackvscode 中 launch.json 部分配置项解释VS Code 调试","tags":[{"name":"webpack","slug":"webpack","permalink":"https://793338023.github.io/tags/webpack/"}]},{"title":"webpack-externals","date":"2020-04-05T09:21:37.000Z","path":"2020/04/05/webpack-externals/","text":"前言webpack5 出了 federated-modules，对于对微前端有需求的项目来说，无疑是一个好消息，因为它解决跨应用之间的共享模块。而这也是微前端的核心功能之一。 github 例子federated-modules 资料 而这个功能还在试行阶段，在这之前一般都是使用 externals 解决这种跨应用问题，当然 externals 不止这些作用，还可以优化编译速度。 externalsexternals 是 webpack 的外部扩展，例如我们想引用一个库，但是又不想让 webpack 打包，并且又不影响我们在程序中以 CMD、AMD 或者 window/global 全局等方式进行使用，那就可以通过配置 externals。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用，从中可知完全符合微前端糅合项目。 当然它在优化方面是很棒的。如我们在使用 js 库如 react-dom 或者 react 等的时候，webpack 会将他们一起打包，react 和 react-dom 文件就好几百 k，全部打包成一个文件，可想而知，这个文件会很大，用户在首次打开时往往会出现白屏等待时间过长的问题，这时，我们就需要将这类文件抽离出来，那么我们就可以 externals 的方式引入。也就是说，自己的库本身不打包这个 react-dom、react，需要用户环境提供，也优化了开发与打包的编译速度。 项目中正常使用 12import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;; webpack 配置 1234externals: &#123; react: &quot;React&quot;, &quot;react-dom&quot;: &quot;ReactDOM&quot;, &#125;, 需要 html 引入 js 直接 index.html 引入 12&lt;script src=&quot;https://cdn.bootcss.com/react/16.13.1/umd/react.production.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.13.1/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; html-webpack-plugin 方式引入，因为 html-webpack-plugin 可以使用 ejs 12345678910111213plugins: [ //... new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: `/public/template.ejs`, //... // 添加参数SCRIPTS，后面母版页会使用 SCRIPTS: [https://cdn.bootcss.com/react/16.13.1/umd/react.production.min.js,https://cdn.bootcss.com/react-dom/16.13.1/umd/react-dom.production.min.js ], &#125;), ], template.ejs 123&lt;% htmlWebpackPlugin.options.SCRIPTS.forEach(function(url)) &#123; %&gt;&lt;script src=&quot;&lt;%=url %&gt;&quot;&gt;&lt;/script&gt;&lt;% &#125;) %&gt; 如果你写的库要支持各种环境，你需要设置 output 中的 libraryTarget 为 umd，也就是将打包的文件，生成为 umd 规范，适用于各种环境。libraryTarget 和 externals 关系紧密，如果出现不符合的，你可以使用 webpack 打包为 umd，webpack 打包出的名称与 externals 的 value 保持一致。 externals 配置一般都是使用 object，如: 12345678910111213externals: &#123; &quot;lodash&quot;: &#123; commonjs: &quot;lodash&quot;,//如果我们的库运行在Node.js环境中，import _ from &apos;lodash&apos;等价于const _ = require(&apos;lodash&apos;) commonjs2: &quot;lodash&quot;,//同上 amd: &quot;lodash&quot;,//如果我们的库使用require.js等加载,等价于 define([&quot;lodash&quot;], factory); root: &quot;_&quot;//如果我们的库在浏览器中使用，需要提供一个全局的变量‘_’，等价于 var _ = (window._) or (_); &#125;&#125;或externals: &#123; react: &quot;React&quot;&#125; externals 详细资料externals 是需要网络环境的支持的，如果一定要本地就支持，可以使用 DllPlugin只是 DllPlugin 需要在项目里配置符合它的打包配置，项目内有一个专门打包静态不常变的配置与存放它的文件，因为与项目打包文件夹在每次打包都要被删除的，所以不能放在那。 ProvidePluginwebpack 配置 ProvidePlugin 后，在使用时将不再需要 import 和 require 进行引入，直接使用即可。既配置它后我们可以直接在 window 上获取到方法，不用模块导入。 webpack ProvidePluginProvidePlugin 资料","tags":[{"name":"webpack","slug":"webpack","permalink":"https://793338023.github.io/tags/webpack/"}]},{"title":"超简单的搭建功能完善的组件开发库","date":"2020-04-04T12:11:56.000Z","path":"2020/04/04/超简单的搭建功能完善的组件开发库/","text":"前言搭建组件开发库，往往要有很多打包工具知识，从中选择符合当前需求的，如要有 webpack、rollup、gulp、单元测试、eslint、typescript 等等知识，如果想搭建一个理想好用的，还要会使用 node 写命令或脚手架。 但阿里的前端工具生态已经有很好用工具可开箱即可，免去入门门槛，dumi。 详细文档请移步 github 查看，里面有个例子项目 2020/4/4 清明-全国哀悼首先默哀三分钟 今天看到网站都是灰色的，怎么做到了，使用了 filter 的 grayscale 实现的，只要在顶层 html 使用 filter，就实现了整个网站灰色 1234html &#123; -webkit-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);&#125;","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"职责链模式","date":"2020-04-01T12:43:07.000Z","path":"2020/04/01/职责链模式/","text":"职责链的定义使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 在以下场景中可以考虑使用责任链模式 一个系统的审批需要多个对象才能完成处理的情况下，例如报销系统等。 代码中存在多个 if-else 语句的情况下，此时可以考虑使用责任链模式来对代码进行重构。 代码例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export class Stack &#123; next: any = null; fn: Function | any = null; constructor(fn: Function) &#123; this.fn = fn; &#125; setNextStack = (stack: any) =&gt; &#123; this.next = stack; &#125;; passRequest = (...args: any[]) =&gt; &#123; const [status, ret] = this.fn(...args); if (typeof status === &quot;boolean&quot; &amp;&amp; status) &#123; if (this.next) &#123; if (Array.isArray(ret)) &#123; this.next.passRequest(...ret); &#125; else &#123; this.next.passRequest(ret); &#125; &#125; &#125; return ret; &#125;;&#125;---------------------function coupon100(pay: number, num: number) &#123; if (pay * num &gt; 100) &#123; console.log(`已经优惠了100，实付$&#123;pay * num - 100&#125;`); return [false, `已经优惠了100，实付$&#123;pay * num - 100&#125;`]; &#125; else &#123; return [true, [pay, num]]; &#125;&#125;function coupon50(pay: number, num: number) &#123; if (pay * num &gt; 50) &#123; console.log(`已经优惠了50，实付$&#123;pay * num - 50&#125;`); return [false, `已经优惠了50，实付$&#123;pay * num - 50&#125;`]; &#125; else &#123; return [true, [pay, num]]; &#125;&#125;function coupon200(pay: number, num: number) &#123; if (pay * num &gt; 200) &#123; console.log(`已经优惠了200，实付$&#123;pay * num - 200&#125;`); return [false, `已经优惠了200，实付$&#123;pay * num - 200&#125;`]; &#125; else &#123; return [true, [pay, num]]; &#125;&#125;const stack200 = new Stack(coupon200);const stack100 = new Stack(coupon100);const stack50 = new Stack(coupon50);stack200.setNextStack(stack100);stack100.setNextStack(stack50);stack200.passRequest(43, 2);","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://793338023.github.io/tags/设计模式/"}]},{"title":"chrome插件开发与为什么数据埋点请求使用图片","date":"2020-03-29T12:52:24.000Z","path":"2020/03/29/chrome插件开发与为什么数据埋点请求使用图片/","text":"chrome 插件-使用 vue 实现为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片 避免跨域（img 天然支持跨域） 利用空白 gif 或 1x1 px 的 img 是互联网广告或网站监测方面常用的手段，简单、安全、相比 PNG/JPG 体积小，1px 透明图，对网页内容的影响几乎没有影响，这种请求用在很多地方，比如浏览、点击、热点、心跳、ID 颁发等等， 图片请求不占用 Ajax 请求限额 GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节） 不会阻塞页面加载，影响用户的体验，只要 new Image 对象就好了，一般情况下也不需要 append 到 DOM 中，通过它的 onerror 和 onload 事件来检测发送状态。 例子:首先要在服务器上放一张 1X1 的 gif 图 1234567&lt;script type=&quot;text/javascript&quot;&gt; var thisPage = location.href; var referringPage = (document.referrer) ? document.referrer : &quot;none&quot;; var beacon = new Image(); beacon.src = &quot;http://img.soogif.com/00VBBS2KfqyZJb18GVJyL9jUuw1iSTDF.gif?page=&quot; + encodeURI(thisPage) + &quot;&amp;ref=&quot; + encodeURI(referringPage);&lt;/script&gt;","tags":[{"name":"chrome","slug":"chrome","permalink":"https://793338023.github.io/tags/chrome/"}]},{"title":"fiddler代理方式","date":"2020-03-25T15:31:05.000Z","path":"2020/03/25/fiddler代理方式/","text":"请求转发到本地文件身为一名前端，当为了调试某些情况下请求的返回参数需要人为改动来调试时，可以使用 AutoResponder如: 本地转发 配置规则为 123regex:https://www.juhe.cn/loginStatusC:\\Users\\M\\Desktop\\data.json 带 regex:为正则匹配，否则就是完全匹配。 使用 fiddlerScript 代理fiddlerScript 时 js 代码，灵活度比较高。我们只要操作 oSession 对象即可 首先我们现在请求前OnBeforeRequest方法添加要修改的地址。如: 1234// 电影天堂替换为动漫if(oSession.url.IndexOf(&quot;www.dytt8.net&quot;)&gt;-1)&#123; oSession.url = oSession.url.Replace(&quot;www.dytt8.net&quot;,&quot;www.hkdm688.com&quot;); &#125; 1 1 1 当我们请求www.dytt8.net地址时就会替换为www.hkdm688.com然后再做真正的请求。 而 fiddlerScript 的OnBeforeRequest是优先于 AutoResponder 的，所以我们在 fiddlerScript 修改的，可以在 AutoResponder 再次调整。 资料","tags":[{"name":"调试","slug":"调试","permalink":"https://793338023.github.io/tags/调试/"}]},{"title":"设计模式之工厂模式","date":"2020-03-12T15:11:51.000Z","path":"2020/03/12/设计模式之工厂模式/","text":"前言工厂模式的目的是为了创建对象，它通常在类或者类的静态方法中实现，具有以下目标： 当创建相似对象时执行重复操作当编译时不知道具体类型的情况下，为工厂客户提供一个创建对象的接口与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。 这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类类定义需要创建的对象类型。 使用123456789101112131415161718192021222324252627var func = (function () &#123; const Car = (model, year, miles)=&gt; &#123; this.model = model; this.year = year; this.miles = miles; &#125;; const Bus = (color,sign,size)=&gt;&#123; this.color = color; this.sign = sign; this.size = size; &#125; const obj=&#123; car: Car, bus: Bus &#125; return function (...args) &#123; const [type,...rargs] = args; const Exa = obj[type]; return new Exa(...rargs); &#125;;&#125;)();var a = func(&quot;car&quot;,&quot;xom&quot;, 200, 899);var b = func(&quot;bus&quot;, &quot;red&quot;, &quot;rr&quot;,10); 上面的是简单工厂模式 当然还有工厂方法模式与抽象工厂模式，简单工厂模式应该就够实现大部分需要工厂模式的场景。 设计模式只是为了解决一些问题，其实它们之间有时是比较类似的，只是实现时有点差异，其实工作久了，也会不知不觉就使用上设计模式。 场景 那么什么时候使用工厂模式呢，以下几种情景下工厂模式特别有用： 对象的构建十分复杂需要依赖具体环境创建不同实例处理大量具有相同属性的小对象 什么时候不该用工厂模式： 不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://793338023.github.io/tags/设计模式/"}]},{"title":"设计模式-策略模式","date":"2020-03-11T15:09:23.000Z","path":"2020/03/11/设计模式-策略模式/","text":"策略模式定义：定义一系列算法，把他们各自封装成策略类，然后把不变的部分和变化的部分分离开来，其中包括策略类和环境类(Context)。 这里的算法可以理解为用于处理逻辑的方法。 使用 经典例子: 1234567891011121314const strategies = &#123; &quot;Q2&quot;:(s)=&gt; s*2, &quot;Q3&quot;:(s)=&gt; s*3, &quot;Q4&quot;:(s)=&gt; s*4, &quot;Q5&quot;:(s)=&gt; s*5&#125;const calculateBouns = (name,param)=&gt;&#123; return strategies[name](param);&#125;console.log(calculateBouns(&quot;Q2&quot;,23));console.log(calculateBouns(&quot;Q3&quot;,23));console.log(calculateBouns(&quot;Q4&quot;,23)); 使用calculateBouns 环境类调用对应的策略方法。 使用前先找到判断的不同点，当参数传入，共同点放在环境类里，然后根据入参值选择对应的策略方法。 而常用在一些判断规则明确的场景，如表单校验方法，根据场景选择运动算法。 以上的场景在网上都很容易找到，以下结合实际在 redux 中使用。 reducer 使用策略模式 123456789101112131415161718192021// 策略类const makeTitle = (state, action)=&gt;&#123; return &#123; ...state, title: action.payload &#125;;&#125;const makeTitle2 = (state, action)=&gt;&#123; return &#123; ...state, title2: action.payload &#125;;&#125;let reducerMap = &#123;&#125;;reducerMap[actionType.PG_COMMON_TITLE] = makeTitle;reducerMap[actionType.PG_COMMON_TITLE2] = makeTitle2;// 环境类export default function reducer(state,action) &#123; const &#123; type &#125; = action; if (reducerMap.hasOwnProperty(type)) &#123; return reducerMap[type](state, action); &#125; return state;&#125; 由于使用 redux 频繁时会出现switch/case或if/else，那么导致在这里函数庞大且不好理解，圈复杂度很高，但我们把 action 对应的 reduce 处理逻辑分到对应的函数里时，那么处理逻辑清晰且好维护。 在的组件的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from &quot;react&quot;;const Input = () =&gt; &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; /&gt; &lt;/div&gt; );&#125;;const Select = () =&gt; &#123; return ( &lt;div&gt; &lt;select name=&quot;a&quot; id=&quot;a&quot;&gt; &lt;option value=&quot;q&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; );&#125;;const Empty = () =&gt; &#123; return &lt;div&gt;没有选中&lt;/div&gt;;&#125;;// 定义策略const COMPONENTS = &#123; select: Select, text: Input&#125;;// 定义环境类组件export default class EnvComponent extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; const componentType = this.props.type; const SelectedComponent = COMPONENTS[componentType] || Empty; return &lt;SelectedComponent &#123;...this.props&#125; /&gt;; &#125;&#125; 使用 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &quot;react&quot;;export default class demo extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; components: [ &#123; type: &quot;text&quot;, value: &quot;123&quot; &#125;, &#123; type: &quot;select&quot;, value: &quot;4&quot; &#125;, &#123; type: &quot;xxx&quot;, value: &quot;123&quot; &#125; ] &#125;; &#125; render() &#123; const &#123; components &#125; = this.state; return ( &lt;div&gt; &#123;components.map((item, index) =&gt; &#123; return &lt;EnvComponent key=&#123;index&#125; &#123;...item&#125; /&gt;; &#125;)&#125; &lt;/div&gt; ); &#125;&#125; 策略模式在明确判断规则并且圈复杂度比较高的，可以考虑使用策略模式。 优缺点优点： 1、利用组合、委托和多态技术和思想，可以避免多重条件选择语句；2、将算法封装在独立的策略类里，使得易于切换，易于理解，易于扩展；3、策略模式可以复用在系统的其他地方，从而避免重复的复制粘贴工作；4、策略模式利用组合和委托让环境类拥有执行算法的能力，从而替代继承。 缺点： 1、程序中会增加许多策略类或者策略对象；2、使用策略类必须要对所有的策略类算法了解清楚，否则不知道怎么选择，就是对判断规则有规律可循，那么就可以想出对应的环境类，由经过环境类选择策略类。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://793338023.github.io/tags/设计模式/"}]},{"title":"npm install的坑","date":"2020-03-08T12:42:58.000Z","path":"2020/03/08/install的坑/","text":"packagepackage 有两种依赖 dependencies —— 运行依赖，依赖的项该是正常运行该包时所需要的依赖项，就是开发的项目需要的包，如 ui 框架包，react 包之类的。 devDependencies —— 开发依赖，开发的时候需要的依赖项，像一些进行单元测试之类的包或 webpack 打包需要的包。 package 版本号详解在 npm 中安装固定的版本号 package，只需要在其后加 @版本号 1npm i babel-core@7.0.0 -S package.json 中库的版本号详解： ~ 匹配最近的小版本依赖包，比如~7.0.0 会匹配所有 7.0.x 版本，但是不包括 7.1.0，如果 7.0.x 最新的版本是 7.0.8，那么就会安装这个版本 ^ 匹配最新的大版本依赖包，比如^7.0.0 会匹配所有 7.x.x 的包，包括 7.9.0，但是不包括 8.0.0，如 7.x.x 最新的版本是 7.8.7，那么就会安装这个版本 * 意味着安装最新版本的依赖包 坑由于在 package.json 中依赖包大部分都是一个范围的版本，如babel:^7.0.0，那么每个从仓库拉下来的开发者都会遵循装包规则，安装这个范围版本最新的，那么就导致一个现象就是你与同事的依赖包不一致，而你的包有 BUG，但你同事没有，而导致有时难以确认问题所在，或者公司自己搭建了 npm 私仓，但最近在 npm 仓库上有新的包更新，但公司的私仓没有同步到位，导致装包时找不到包，但由于这个包是依赖包的包，导致你也不能固定它的版本而导致你无法正常下载包的问题。 解决方法: 那么这些问题其实可以使用package-lock.json解决，因为它记录了整个 node_modules 文件夹的树状结构，甚至连模块的下载地址都记录了，npm install时会根据 package-lock.json 文件指定的结构来下载模块，并不会理会 package.json 文件，而它也提升了装包速度。 但以后修改 package.json 文件相应模块的版本号，再执行 npm install 不会更新了，只能手动 npm install name@version 指定版本号来安装。 若项目里没有package-lock.json，那么我们可以使用 yarn 去解决，因为 yarn 出现就是为了解决 npm 的一些缺陷，它与 npm 功能类似而且完全兼容，在项目中可以切换使用，它们都是一个对包操作的工具而已，而 yarn 对某些不存在的包版本但这个版本范围之类还是有包存在的会出现询问交互操作，那么我们就可以选定某个版本，而 npm 就不行，当版本不存在，它就会报错，让人无法安装包，然后 yarn 生成 yarn.lock，这个和package.json一样的，最早时 yarn 实现的，为了版本一致，提升速度。 123yarn install --non-interactive禁用询问交互，比如当没有合适版本的依赖时 123456789yarn install --flat安装所有依赖，但每个依赖只允许有一个版本存在。 第一次运行这个命令时，会提示你在每个依赖包的多个版本范围中选择一个版本。 这会被添加到你的 package.json 文件的 resolutions 字段。&quot;resolutions&quot;: &#123; &quot;package-a&quot;: &quot;2.0.0&quot;, &quot;package-b&quot;: &quot;5.0.0&quot;, &quot;package-c&quot;: &quot;1.5.2&quot;&#125; 123456// 将准确地安装yarn.lock中的内容。不更新锁定yarn install --frozen-lockfile不生成 yarn.lock 锁文件，并且，如果需要更新则会报错。如果需要可重现的依赖环境（比如在持续集成系统中），应该传入 --frozen-lockfile 标志。","tags":[{"name":"npm","slug":"npm","permalink":"https://793338023.github.io/tags/npm/"}]},{"title":"npm进阶-node_modules与自动部署装包速度提升","date":"2020-03-03T13:37:57.000Z","path":"2020/03/03/npm进阶-node-modules与自动部署装包速度提升/","text":"自动部署装包速度提升现在程序的开发都提倡能用技术放开双手，那就要技术解决，所以现在无论是构建、代码检查、部署或者测试，这些都有一定程度的自动化过程，减少人为操作失误，而这的主题是 npm 装包耗时过长的优化方案。 当我们本地使用 npm 装包时，因为在本地环境中安装依赖是有状态的，如 node_modules，~/.npmrc，~/.npm 一系列硬盘目录及文件，无不构成状态。而在生产环境中，往往结合 CICD 工具，每次分配的 Runner 不一定是一台服务器(容器)，往往被视为无状态，因而无法有效利用缓存而导致 CI 中部署用时过长。 但也正因为 CICD Runner 的无状态化，这意味着你只要参考构建脚本，如 .gitlab-ci.yaml，.travis.yaml 或者 .github/workflows/deploy.yaml，就可以从零把项目跑起来，而避免过多在熟悉新项目时求助他人。 那么我们应该怎么让 npm 在 CICD 上跑的更快呢？ 优化一:使用 –production 可以只安装 package.json 中 dependencies 中的依赖项，只把要安装在 CI 中需要使用到的依赖。在生产环境部署时可以指定 –production。 1npm install --production 但这样以后装包要严格遵守装包的规则，项目使用到的都要装到 dependencies 里，这是一个缺点，会出现人为的失误导致的 BUG。 优化二:使用私有镜像仓库，既公司自己搭建 npm 仓库，然后包都从公司仓库拉取。对于企业级项目的生产环境来说，在集群内部搭建私有仓库是一个更好的选择，也更能缩短时延。 流量能在局域网完成的，就不需要去互联网中溜圈了。 12如:npm config set registry https://registry-npm.sisis.tech/ 优化三:正如 http cache 一样，npm install 也可以充分利用缓存，npm 的缓存在 linux 系统中存在于以下路径: 命令 npm cache verify 可以校验缓存，如下所示: 12345npm cache verifyCache verified and compressed (~/.npm/_cacache):Content verified: 4415 (156612117 bytes)Index entries: 6239Finished in 14.017s 结合 npm install --prefer-offline 缓存优先策略充分利用缓存 既 12npm cache verifynpm install --prefer-offline 优化四:使用npm ci装包它安装依赖时，默认是缓存优先的，它会充分利用缓存，从而加速装包。npm ci 可以减少将近一半的的依赖安装时间。 优化五:每次对比上一次 MR 的 package.json 与这次 MR 的 package.json，筛选出不同的地方，如包的版本不一样，新增包等，然后只安装这部分的包 npm 进阶-node_modulesnodejs 中 package.json 中的依赖必须每个项目都有自己的 node_modules 文件夹，而无法在多个项目之间共用一套 node_modules（不像 Java 中的 Maven 那样共享一个全居仓库）。 没法共用一个 node_modules 会导致互相依赖的项目当使用是同一个包时，但由于包保存了数据需要获取出来使用而导致的报错，因为它们不是依赖同一个包，如 redux，react-router-dom 等。 依赖管理是每个现代语言的标配。在 Java 中，maven 同时兼具 依赖管理 和 打包 两大功能，而前段领域这两个功能是两种不同的工具分别提供： npm 负责依赖管理 webpack 负责打包 1依赖管理最难解决的问题就是版本问题。库A依赖库B，库C也依赖库B，但是库A跟库C所依赖的库B不是同一版本，如果库B的这两个版本兼容还好，如果不兼容就坑大发了，这是无解的问题。 Java 中的 Maven 仓库在开发者电脑上是全局的，所有项目的依赖都集中存放在本地仓库中。每个项目都有 pom.xml 指明依赖本地仓库中的哪些库，如果本地仓库没有会从局域网仓库或网络仓库下载至本地仓库。Node 中的依赖如果你不写 package.json，那么依赖的就是全局的库；如果写了 package.json，就会把所有依赖下载到 node_modules 文件夹 Node 这种 node_modules 文件夹的方式有利有弊。 好处: 使用 package.json 安装好之后，node_modules 文件夹中没有版本信息，从而 package.json 可以删掉了。 移动/复制/打包项目比较简单，对于开发、部署都有好处 对于设计 npm 的人来说，这是最省事的包依赖方法。这就好比 maven 安装依赖之后自动将 jar 包安装到项目的 lib 里面。 随意改代码。安装在 node_modules 里面的东西，你可以随便改，无需担心对其它项目的影响。在 Java 中使用 maven 管理项目时，如果想要定制某个库，就需要更改这个库的源代码，这时就需要把这个库的源代码复制到项目中，跟 node_modules 是一个道理。npm 的设计者大概认为：前端都是经常修改库的源代码的。 坏处: 每次都需要安装依赖，费流量，网速慢时很费时间 浪费磁盘空间，每个 node_modules 中包含的工具很多，动辄 20M 但我觉得这些坏处都不是很大的问题，应该也就浪费一些流量和几十分钟的时间，而且也不是经常全量安装包，后续开发就会单独新增包，单独安装包是很快的，并且 npm 或 yarn 之类的工具都在不断的优化，装包只会越来越快，再不济也可以是使用国内镜像或公司搭建私仓下载，这也是对装包速度很大的提升。","tags":[{"name":"npm","slug":"npm","permalink":"https://793338023.github.io/tags/npm/"}]},{"title":"react-微前端","date":"2020-03-02T14:59:22.000Z","path":"2020/03/02/react-微前端/","text":"当前微前端技术栈统一，仓库只有一个。 适用场景: 项目大，工程多，而都是由一个技术团队负责。 github 项目详情","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"webpack-离线应用","date":"2020-02-15T13:23:53.000Z","path":"2020/02/15/webpack-离线应用/","text":"前言离线缓存应用，意思就是没有网络的情况下，被缓存的资源能从本地直接返回，让应用在一定范围内能正常运行。 离线应用有以下优点： 在没有网络的情况下也能打开网页。 由于部分被缓存的资源直接从本地加载，对用户来说可以加速网页加载速度，对网站运营者来说可以减少服务器压力以及传输流量费用。 实现离线缓存的技术有两种: AppCache 又叫 Application Cache，目前已经从 Web 标准中删除，请尽量不要使用它。 Service Workers 是目前最新的离线缓存技术，是 Web Worker 的一部分。 Service Workers 通过拦截网络请求实现离线缓存，比 AppCache 更加灵活。它也是构建 PWA 应用的关键技术之一。 出于安全原因，Service Workers 要求必须在 HTTPS 下才能运行。 在本地开发中，我们可以在启动 chrome 时让本地应用设置为安全，可以不使用 https，而使用 http，否则会报错。如启动的本地应用地址为http://localhost:8080/; 12// 在终端启动chrome，chrome文件路径&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot; --unsafely-treat-insecure-origin-as-secure=http://localhost:8080/ Service Workers 兼容性目前 Chrome、Firefox、Opera 都已经全面支持 Service Workers，但对于移动端浏览器就不太乐观了，只有高版本的 Android 支持。由于 Service Workers 无法通过注入 polyfill 去实现兼容，所以在你打算使用它前请先调查清楚你的网页的运行场景。 判断浏览器是否支持 Service Workers 的最简单的方法是通过以下代码： 1234// 如果 navigator 对象上存在 serviceWorker 对象，就表示支持if (navigator.serviceWorker) &#123; // 通过 navigator.serviceWorker 使用&#125; 注册要给网页接入 Service Workers，需要在网页加载后注册一个描述 Service Workers 逻辑的脚本。所以编写一个 sw.js 专门包含 Service Workers 逻辑的脚本，比如缓存内容，sw.js 更新后重新加载缓存内容等等，而 sw.js 文件需要在应用入口文件加载注册。如 main.js 为 webpack 的入口文件: 12345678910require(&apos;./main.css&apos;);if (navigator.serviceWorker) &#123; window.addEventListener(&apos;DOMContentLoaded&apos;,function() &#123; // 调用 serviceWorker.register 注册，参数 /sw.js 为脚本文件所在的 URL 路径 navigator.serviceWorker.register(&apos;sw.js&apos;); &#125;);&#125;window.document.getElementById(&apos;app&apos;).innerText = &apos;Hello,Webpack&apos;; 一旦这个脚本文件被加载，Service Workers 的安装就开始了。这个脚本被安装到浏览器中后，就算用户关闭了当前网页，它仍会存在。也就是说第一次打开该网页时 Service Workers 的逻辑不会生效，因为脚本还没有被加载和注册，但是以后再次打开该网页时脚本里的逻辑将会生效。 在 Chrome 中可以通过打开网址 chrome://inspect/#service-workers 来查看当前浏览器中所有注册了的 Service Workers。 使用 Service Workers 实现离线缓存Service Workers 在注册成功后会在其生命周期中派发出一些事件，通过监听对应的事件在特点的时间节点上做一些事情。 在 Service Workers 脚本中，引入了新的关键字 self 代表当前的 Service Workers 实例。 在 Service Workers 安装成功后会派发出 install 事件，需要在这个事件中执行缓存资源的逻辑，实现代码如下： 1234567891011121314151617181920// 当前缓存版本的唯一标识符，用当前时间代替var cacheKey = new Date().toISOString();// 需要被缓存的文件的 URL 列表var cacheFileList = [ &apos;/index.html&apos;, &apos;/app.js&apos;, &apos;/app.css&apos;];// 监听 install 事件self.addEventListener(&apos;install&apos;, function (event) &#123; // 等待所有资源缓存完成时，才可以进行下一步 event.waitUntil( caches.open(cacheKey).then(function (cache) &#123; // 要缓存的文件 URL 列表 return cache.addAll(cacheFileList); &#125;) );&#125;); 接下来需要监听网络请求事件去拦截请求，复用缓存，代码如下： 1234567891011121314self.addEventListener(&apos;fetch&apos;, function(event) &#123; event.respondWith( // 去缓存中查询对应的请求 caches.match(event.request).then(function(response) &#123; // 如果命中本地缓存，就直接返回本地的资源 if (response) &#123; return response; &#125; // 否则就去用 fetch 下载资源 return fetch(event.request); &#125; ) );&#125;); 以上就实现了离线缓存。 更新缓存线上的代码有时需要更新和重新发布，如果这个文件被离线缓存了，那就需要 Service Workers 脚本中有对应的逻辑去更新缓存。这可以通过更新 Service Workers 脚本文件做到。浏览器针对 Service Workers 有如下机制： 每次打开接入了 Service Workers 的网页时，浏览器都会去重新下载 Service Workers 脚本文件（所以要注意该脚本文件不能太大），如果发现和当前已经注册过的文件存在字节差异，就将其视为“新服务工作线程”。 新 Service Workers 线程将会启动，且将会触发其 install 事件。 当网站上当前打开的页面关闭时，旧 Service Workers 线程将会被终止，新 Service Workers 线程将会取得控制权。 新 Service Workers 线程取得控制权后，将会触发其 activate 事件。 新 Service Workers 线程中的 activate 事件就是最佳的清理旧缓存的时间点，代码如下： 123456789101112131415161718// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 keyvar cacheWhitelist = [cacheKey];self.addEventListener(&apos;activate&apos;, function(event) &#123; event.waitUntil( caches.keys().then(function(cacheNames) &#123; return Promise.all( cacheNames.map(function(cacheName) &#123; // 不在白名单的缓存全部清理掉 if (cacheWhitelist.indexOf(cacheName) === -1) &#123; // 删除缓存 return caches.delete(cacheName); &#125; &#125;) ); &#125;) );&#125;); sw.js 完整代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 当前缓存版本的唯一标识符，用当前时间代替var cacheKey = new Date().toISOString();// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 keyvar cacheWhitelist = [cacheKey];// 需要被缓存的文件的 URL 列表var cacheFileList = [ &apos;/index.html&apos;, &apos;app.js&apos;, &apos;app.css&apos;];// 监听 install 事件self.addEventListener(&apos;install&apos;, function (event) &#123; // 等待所有资源缓存完成时，才可以进行下一步 event.waitUntil( caches.open(cacheKey).then(function (cache) &#123; // 要缓存的文件 URL 列表 return cache.addAll(cacheFileList); &#125;) );&#125;);// 拦截网络请求self.addEventListener(&apos;fetch&apos;, function (event) &#123; event.respondWith( // 去缓存中查询对应的请求 caches.match(event.request).then(function (response) &#123; // 如果命中本地缓存，就直接返回本地的资源 if (response) &#123; return response; &#125; // 否则就去用 fetch 下载资源 return fetch(event.request); &#125; ) );&#125;);// 新 Service Workers 线程取得控制权后，将会触发其 activate 事件self.addEventListener(&apos;activate&apos;, function (event) &#123; event.waitUntil( caches.keys().then(function (cacheNames) &#123; return Promise.all( cacheNames.map(function (cacheName) &#123; // 不在白名单的缓存全部清理掉 if (cacheWhitelist.indexOf(cacheName) === -1) &#123; // 删除缓存 return caches.delete(cacheName); &#125; &#125;) ); &#125;) );&#125;); z 这些都是没有接入 webpack 时实现的。 接入 Webpack使用 webpack 要使用serviceworker-webpack-plugin插件。 1npm i -D serviceworker-webpack-plugin webpack-dev-server webpack 例子: 1234567891011121314151617181920212223242526272829303132333435363738394041424344const path = require(&quot;path&quot;);const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);const &#123; WebPlugin &#125; = require(&quot;web-webpack-plugin&quot;);const ServiceWorkerWebpackPlugin = require(&quot;serviceworker-webpack-plugin&quot;);module.exports = &#123; entry: &#123; app: &quot;./main.js&quot; // Chunk app 的 JS 执行入口文件 &#125;, output: &#123; filename: &quot;[name].js&quot;, publicPath: &quot;&quot; &#125;, module: &#123; rules: [ &#123; test: /\\.css/, // 增加对 CSS 文件的支持 // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: [&quot;css-loader&quot;] // 压缩 CSS 代码 &#125;) &#125; ] &#125;, plugins: [ // 一个 WebPlugin 对应一个 HTML 文件 new WebPlugin(&#123; template: &quot;./template.html&quot;, // HTML 模版文件所在的文件路径 filename: &quot;index.html&quot; // 输出的 HTML 的文件名称 &#125;), new ExtractTextPlugin(&#123; filename: `[name].css` // 给输出的 CSS 文件名称加上 hash 值 &#125;), new ServiceWorkerWebpackPlugin(&#123; // 自定义的 sw.js 文件所在路径 // ServiceWorkerWebpackPlugin 会把文件列表注入到生成的 sw.js 中 entry: path.join(__dirname, &quot;sw.js&quot;) &#125;) ], devServer: &#123; // Service Workers 依赖 HTTPS，使用 DevServer 提供的 HTTPS 功能。 // https: true, &#125;&#125;; devServer 的 https 可以不开启，如果 chrome 启动设置不禁止 http；使用了 ServiceWorkerWebpackPlugin 后可以在 sw.js 里 global.serviceWorkerOption 下获取 assets，里面包含了 webpack 输出的所有静态文件。 123456789Version: webpack 3.12.0Time: 16ms Asset Size Chunks Chunk Names app.css 21 bytes 0 [emitted] appindex.html 332 bytes [emitted] sw.js 7.13 kB [emitted] global.serviceWorkerOption.assets --- [&quot;/app.js&quot;, &quot;/app.css&quot;, &quot;/index.html&quot;] 而 ServiceWorkerWebpackPlugin 内置了注册启动 123import runtime from &quot;serviceworker-webpack-plugin/lib/runtime&quot;;// 调用 serviceWorker.register 注册，参数 /sw.js 为脚本文件所在的 URL 路径var registration = runtime.register(); ServiceWorkerWebpackPlugin 事件 12345678910111213141516171819import registerEvents from &quot;serviceworker-webpack-plugin/lib/browser/registerEvents&quot;;registerEvents(registration, &#123; onInstalled: () =&gt; &#123; pushLog(&quot;onInstalled&quot;); &#125;, onUpdateReady: () =&gt; &#123; pushLog(&quot;onUpdateReady&quot;, true); &#125;, onUpdating: () =&gt; &#123; pushLog(&quot;onUpdating&quot;); &#125;, onUpdateFailed: () =&gt; &#123; pushLog(&quot;onUpdateFailed&quot;); &#125;, onUpdated: () =&gt; &#123; pushLog(&quot;onUpdated&quot;); &#125; &#125;); ServiceWorkerWebpackPlugin 更新后手动更新 12345import applyUpdate from &quot;serviceworker-webpack-plugin/lib/browser/applyUpdate&quot;;// 当为onUpdateReady时，可以使用applyUpdate触发更新操作applyUpdate().then(() =&gt; &#123; window.location.reload(); &#125;); 验证通过打开开发者工具的 Application-Service Workers 一栏，就能看到当前页面注册的 Service Workers，正常的效果如图： 01 通过打开开发者工具的 Application-Cache-Cache Storage 一栏，能看到当前页面缓存的资源列表，正常的效果如图： 02 为了验证网页在离线时能访问的能力，需要在开发者工具中的 Network 一栏中通过 Offline 选项禁用掉网络，再刷新页面能正常访问，并且网络请求的响应都来自 Service Workers，正常的效果如图： 03 从图上可以看到红字的为没有缓存的，而有 ServiceWorker 的为有缓存的。 完整项目例子","tags":[{"name":"webpack","slug":"webpack","permalink":"https://793338023.github.io/tags/webpack/"}]},{"title":"重温webpack-02","date":"2020-01-18T15:03:56.000Z","path":"2020/01/18/重温webpack-02/","text":"前言配置 Entrycontext OutputfilenamechunkFilenamepathpublicPathcrossOriginloadinglibraryTargetlibrarylibraryExport 在使用 Babel 的项目中接入 React 框架很简单，只需要加入 React 所依赖的 Presets babel-preset-react 与 Babel 相比， Typescript 的优点在于，它原生支持 JSX 语法，不需要重新安装新的依赖，只需修改一行配置。但 TypeScript 的不同之处在于: 使用了 JSX 语法的文件后缀必须是 tsx; 由于 React 不是采用 Typescript 编写的，所以需要安装 react 和 react-dom 对应的 Type Script 接口描述模块＠ types/react 和＠ types/react-dom 才能通过编译。 动态链接库react-router 缓存组件","tags":[{"name":"webpack","slug":"webpack","permalink":"https://793338023.github.io/tags/webpack/"}]},{"title":"重温webpack-01","date":"2020-01-12T03:47:12.000Z","path":"2020/01/12/重温webpack-01/","text":"前言webpack 当下最流行的前端架构工具。 Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。 一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。 webpack 为什么需要模块化模块化是指把一个复杂的系统分解到多个模块以方便编码。在没有出现模块化概念时，解决 js 代码组织问题，比较流行的是命名空间的方式，如 JQuery。但无法解决以下问题: 命名空间冲突，两个库可能会使用同一个名称，例如 Zepto 也被放在 window.\\$ 下； 无法合理地管理项目的依赖和版本； 无法方便地控制依赖的加载顺序。 当项目特别庞大并依赖特别多时，加载的类库就会显得特别笨重，在显示上会出现页面不流畅的情况，在代码上，会出现难以维护的现象。 而技术的发展就是为了编写更好易懂的代码，减少人为规范，而出现模块化开发，象征的就是 requirejs、CommonJS、seaJs 等等，而后随着 js 发展，ECMA 提出的 JavaScript 模块化规范 ES6 模块化，它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块化例子: 1234567// 导出export const method = ()=&gt;&quot;ES6 模块化&quot;;export default &#123; es6:&quot;es6 代码&quot;&#125;// 导入import React, &#123; useState &#125; from &quot;react&quot;; ES6 模块化虽然是模块化解决方案，但浏览器支持力不高，所以需要架构工具帮助转义为浏览器可识别的代码。 工具对比scriptsnpm 是在安装 Node.js 时附带的包管理器,Npm Script 则是 Npm 内置的一个功能，允许在 package.json 文件里面使用 scripts 字段定义任务。 123456&#123; &quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;webpack-dev-server&quot;, &quot;start&quot;:&quot;node script/index&quot; &#125;&#125; 里面的 scripts 字段是一个对象，每个属性对应一段 Shell 脚本，以上代码定义了两个任务 dev 和 pub。 其底层实现原理是通过调用 Shell 去运行脚本命令，如执行npm run start,执行的是node script/index node 程序，但这个功能很单一，没法使用与复杂场景。 GulpGulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面 5 个方法就可以胜任几乎所有构建场景： 12345通过 gulp.task 注册一个任务；通过 gulp.run 执行任务；通过 gulp.watch 监听文件变化；通过 gulp.src 读取文件；通过 gulp.dest 写文件。 它的特点流的方式，而且使用也比较简单，把需要编译内容分成一个个任务gulp.task编写即可，而在任务中使用gulp.src读取文件，而它可以正则，使用方式如 glob,然后使用pipe传递加载到文件内容给插件，而 gulp 的插件编写也比较简单，基本上都是对 node 的使用，最后经过 pipe 传递给gulp.dest进行输出操作，这些是 gulp 基本操作，以下为一个例子: 1234567891011121314151617181920212223242526272829303132// 引入 Gulpvar gulp = require(&apos;gulp&apos;);// 引入插件var jshint = require(&apos;gulp-jshint&apos;);var sass = require(&apos;gulp-sass&apos;);var concat = require(&apos;gulp-concat&apos;);var uglify = require(&apos;gulp-uglify&apos;);// 编译 SCSS 任务gulp.task(&apos;sass&apos;, function() &#123; // 读取文件通过管道传给插件 gulp.src(&apos;./scss/*.scss&apos;) // SCSS 插件把 scss 文件编译成 CSS 文件 .pipe(sass()) // 输出文件 .pipe(gulp.dest(&apos;./css&apos;));&#125;);// 合并压缩 JSgulp.task(&apos;scripts&apos;, function() &#123; gulp.src(&apos;./js/*.js&apos;) .pipe(concat(&apos;all.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&apos;./dist&apos;));&#125;);// 监听文件变化gulp.task(&apos;watch&apos;, function()&#123; // 当 scss 文件被编辑时执行 SCSS 任务 gulp.watch(&apos;./scss/*.scss&apos;, [&apos;sass&apos;]); gulp.watch(&apos;./js/*.js&apos;, [&apos;scripts&apos;]);&#125;); Gulp 的优点是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。其缺点是集成度不高，要写很多配置后才可以用，无法做到开箱即用。还一点就是不会像 webpack 那样把所有文件看作模块打包成一个整体，它是把当前处理的文件看成一个整体，所以处理多少个文件就输入多少个文件。 RollupRollup 是一个和 Webpack 很类似但专注于 ES6 的模块打包工具。 Rollup 的亮点在于能针对 ES6 源码进行 Tree Shaking 以去除那些已被定义但没被使用的代码，以及 Scope Hoisting 以减小输出文件大小提升运行性能。 然而 Rollup 的这些亮点随后就被 Webpack 模仿和实现。 由于 Rollup 的使用和 Webpack 差不多，而它们的差别是： 1234Rollup 是在 Webpack 流行后出现的替代品；Rollup 生态链还不完善，体验不如 Webpack；Rollup 功能不如 Webpack 完善，但其配置和使用更加简单；Rollup 不支持 Code Spliting，但好处是打包出来的代码中没有 Webpack 那段模块的加载、执行和缓存的代码。 Rollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。 但功能不够完善，很多场景都找不到现成的解决方案。 webpack前言以对它进行简述了。Webpack 的优点是： 12345专注于处理模块化的项目，能做到开箱即用一步到位；通过 Plugin 扩展，完整好用又不失灵活；使用场景不仅限于 Web 开发；社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；良好的开发体验。 Webpack 的缺点是只能用于采用模块化开发的项目。 webpack 的简单使用安装webpack 安装 1npm i webpack webpack-cli -D babel 安装 1234567npm i -D @babel/cli @babel/core babel-loader// babel 插件npm i -D @babel/plugin-transform-arrow-functions @babel/plugin-transform-arrow-functions// babel presetsnpm i -D @babel/preset-env @babel/preset-react css 处理安装 1npm i -D css-loader postcss-loader postcss-normalize postcss-preset-env postcss-flexbugs-fixes mini-css-extract-plugin style-loader 当打包时使用 mini-css-extract-plugin 分离 css 为单独文件，而开发时使用 style-loader 在项目热加载模式下使用，因为 mini-css-extract-plugin 在热加载使用不了。 html 处理 1npm i -D html-webpack-plugin 完整 package.json1234567891011121314151617181920212223242526272829303132333435&#123; &quot;name&quot;: &quot;webpack01&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;w&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;@babel/cli&quot;: &quot;^7.8.0&quot;, &quot;@babel/core&quot;: &quot;^7.8.0&quot;, &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.8.0&quot;, &quot;@babel/plugin-transform-arrow-functions&quot;: &quot;^7.8.0&quot;, &quot;@babel/preset-env&quot;: &quot;^7.8.0&quot;, &quot;@babel/preset-react&quot;: &quot;^7.8.0&quot;, &quot;babel-loader&quot;: &quot;^8.0.6&quot;, &quot;css-loader&quot;: &quot;^3.4.2&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^0.9.0&quot;, &quot;postcss-flexbugs-fixes&quot;: &quot;^4.1.0&quot;, &quot;postcss-loader&quot;: &quot;^3.0.0&quot;, &quot;postcss-normalize&quot;: &quot;^8.0.1&quot;, &quot;postcss-preset-env&quot;: &quot;^6.7.0&quot;, &quot;webpack&quot;: &quot;^4.41.5&quot;, &quot;webpack-cli&quot;: &quot;^3.3.10&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;@babel/polyfill&quot;: &quot;^7.8.0&quot;, &quot;react&quot;: &quot;^16.12.0&quot;, &quot;react-dom&quot;: &quot;^16.12.0&quot; &#125;&#125; 完整 webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const postcssNormalize = require(&quot;postcss-normalize&quot;);const babel = require(&quot;./babel.config&quot;);const moduleFileExtensions = [ &quot;web.mjs&quot;, &quot;mjs&quot;, &quot;web.js&quot;, &quot;js&quot;, &quot;json&quot;, &quot;web.jsx&quot;, &quot;jsx&quot;];module.exports = &#123; entry: &quot;./src/index.jsx&quot;, output: &#123; // path: &apos;/dist&apos;, path: __dirname + &quot;/dist&quot;, filename: &quot;bundle.js&quot; &#125;, resolve: &#123; extensions: moduleFileExtensions.map(ext =&gt; `.$&#123;ext&#125;`) &#125;, module: &#123; rules: [ &#123; test: /\\.jsx$/, exclude: /node_modules/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; ...babel &#125; &#125; &#125;, &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: require.resolve(&quot;postcss-loader&quot;), options: &#123; ident: &quot;postcss&quot;, plugins: () =&gt; [ require(&quot;postcss-flexbugs-fixes&quot;), require(&quot;postcss-preset-env&quot;)(&#123; autoprefixer: &#123; flexbox: &quot;no-2009&quot; &#125;, stage: 3 &#125;), postcssNormalize() ], sourceMap: true &#125; &#125; ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: &quot;[name].[chunkhash:8].css&quot;, chunkFilename: &quot;[id].css&quot; &#125;), new HtmlWebpackPlugin(&#123; inject: true, template: &quot;public/index.html&quot; &#125;) ]&#125;; babel.config.js 123456789101112131415const presets = [ &quot;@babel/preset-react&quot;, [ &quot;@babel/preset-env&quot;, &#123; useBuiltIns: &quot;entry&quot; &#125; ]];const plugins = [ &quot;@babel/plugin-transform-arrow-functions&quot;, &quot;@babel/plugin-proposal-class-properties&quot;];module.exports = &#123; presets, plugins &#125;;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://793338023.github.io/tags/webpack/"}]},{"title":"liunx-pm2与nginx","date":"2019-12-31T16:16:23.000Z","path":"2020/01/01/liunx-pm2与nginx/","text":"pm2日志管理：应用程序日志保存在服务器的硬盘中~/.pm2/logs/ 负载均衡：PM2 可以通过创建共享同一服务器端口的多个子进程来扩展您的应用程序。这样做还允许您以零秒停机时间重新启动应用程序。 终端监控：可以在终端中监控您的应用程序并检查应用程序运行状况（CPU 使用率，使用的内存，请求/分钟等）。 SSH 部署：自动部署，避免逐个在所有服务器中进行 ssh。 静态服务：支持静态服务器功能 多平台支持：适用于 Linux（稳定）和 macOS（稳定）和 Windows（稳定） pm2 安装1npm install pm2 -g 创建软链,进入 node 的安装文件夹下，找到 bin，里面有 pm2 的软链，如果环境变量 path 上已经有 node 的配置，那么可以不创建软链，因为在/usr/local/bin/创建的软链就是为了全局调用。 12// 我的node文件目录ln -s /opt/nodeJs/bin/pm2 /usr/local/bin/ pm2 使用在项目下使用 pm2 替代 node 启动项目 12345678910111213141516171819202122pm2 start app.js //启动app.js应用pm2 start app.js --name demo //启动应用并设置namepm2 start app.sh //脚本启动pm2 stop all //停止所有应用pm2 stop [AppName] //根据应用名停止指定应用pm2 stop [ID] //根据应用id停止指定应用pm2 delete all //关闭并删除应用pm2 delete [AppName] //根据应用名关闭并删除应用pm2 delete [ID] //根据应用ID关闭并删除应用pm2 start app.js --watch //当文件发生变化，自动重启//静态服务器pm2 serve ./dist 9090 //将目录dist作为静态服务器根目录，端口为9090pm2 reload app.js //重新启动所有进程，始终保持至少一个进程在运行pm2 gracefulReload all //优雅地以群集模式重新加载所有应用程序pm2 logs //查看所有应用日志 123456789// 查看进程pm2 ls┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐│ id │ name │ namespace │ version │ mode │ pid │ uptime │ ↺ │ status │ cpu │ mem │ user │ watching │├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤│ 0 │ www │ default │ 0.1.0 │ fork │ 2217 │ 89m │ 0 │ online │ 0.8% │ 32.1mb │ root │ disabled │└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘ pm2 还可以实现自动部署的能力，在文件下配置 ecosystem 即可。 如: ecosystem.js 12345678910111213141516171819202122232425262728293031module.exports = &#123; apps : [&#123; name : &apos;API&apos;, //应用名 script : &apos;app.js&apos;, //应用文件位置 env: &#123; PM2_SERVE_PATH: &quot;.&quot;, //静态服务路径 PM2_SERVE_PORT: 8080, //静态服务器访问端口 NODE_ENV: &apos;development&apos; //启动默认模式 &#125;, env_production : &#123; NODE_ENV: &apos;production&apos; //使用production模式 pm2 start ecosystem.config.js --env production &#125;, instances:&quot;max&quot;, //将应用程序分布在所有CPU核心上,可以是整数或负数 watch:true, //监听模式 output: &apos;./out.log&apos;, //指定日志标准输出文件及位置 error: &apos;./error.log&apos;, //错误输出日志文件及位置，pm2 install pm2-logrotate进行日志文件拆分 merge_logs: true, //集群情况下，可以合并日志 log_type:&quot;json&quot;, //日志类型 log_date_format: &quot;DD-MM-YYYY&quot;, //日志日期记录格式 &#125;], deploy : &#123; production : &#123; user : &apos;node&apos;, //ssh 用户 host : &apos;212.83.163.1&apos;, //ssh 地址 ref : &apos;origin/master&apos;, //GIT远程/分支 repo : &apos;git@github.com:repo.git&apos;, //git地址 path : &apos;/var/www/production&apos;, //服务器文件路径 post-deploy : &apos;npm install &amp;&amp; pm2 reload ecosystem.config.js --env production&apos; //部署后的动作 &#125; &#125;&#125; 参考资料 01参考资料 02 nginxnginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 作用：集群（提高吞吐量，减轻单台服务器压力），反向代理（不暴露真实 IP 地址），虚拟服务器，静态服务器（动静分离）。解决跨域问题，使用 nginx 搭建企业级 api 接口网关 nginx 的功能强大 nginx 安装 安装依赖包 12// 一键安装上面四个依赖yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载并解压安装包 1234567//创建一个文件夹cd /usr/localmkdir nginxcd nginx//下载tar包wget http://nginx.org/download/nginx-1.13.7.tar.gztar -zxvf nginx-1.13.7.tar.gz 安装 nginx 12345678//进入nginx目录cd /usr/local/nginx//执行命令./configure//执行make命令make//执行make install命令make install 配置 nginx.conf 进入配置文件 1vim /usr/local/nginx/conf/nginx.conf 修改端口 1234server &#123; listen 3100; ...&#125; 报错 1234567nginx: [alert] could not open error log file: open() &quot;/usr/local/nginx/logs/error.log&quot; failed (2: No such file or directory)2016/09/13 19:08:56 [emerg] 6996#0: open() &quot;/usr/local/nginx/logs/access.log&quot; failed (2: No such file or directory)在nginx/目录下没有logs文件夹解决方法：mkdir logschmod 700 logs 创建软件 123ln -s /usr/local/nginx/sbin/nginx /usr/local/bin//usr/local/bin/就是环境变量目录 测试是否安装成功 123456nginx -t正常情况的信息输出：nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 1234567891011121314启动 nginx:nginx查看 nginx 进程：ps -ef | grep nginx关闭：nginx -s stop配置文件修改重装载命令：nginx -s reload正常停止或关闭Nginx:nginx -s quit location 模块location 在 nginx 是比较常用的，所以需要有所了解。官方文档 location 分为两类 普通 location 和 正则 location普通 location 既不带任何修饰符，如/app,它是前缀匹配，也在正则的范围内，但它是从根路径开始匹配的。 正则 location 带[ = | ~ | ~ * | ^~ ]这些前缀的。 1234567891011121314151617= 表示精确匹配，只有完全匹配上才能生效location = /uri^~ 开头对URL路径进行前缀匹配，并且在正则之前location ^~ /uri开头表示区分大小写的正则匹配location ~ pattern开头表示不区分大小写的正则匹配location ~* pattern不带任何修饰符，也表示前缀匹配，但是在正则匹配之后location /uri通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的defaultlocation / 多个 location 配置的情况下匹配顺序为: 首先精确匹配 = 其次前缀匹配 如:^~ 其次是按文件中顺序的正则匹配 然后匹配不带任何修饰的前缀匹配。 最后是交给 / 通用匹配 当有匹配成功时候，停止匹配，按当前匹配规则处理请求 注意： 1234567891011121314前缀匹配，如果有包含关系时，按最大匹配原则进行匹配。比如在前缀匹配：location /app 与 location /app/goods如有请求http://localhost/app/goods/file将最终匹配到location /app/goods 这个location上如果在正则表达式里面有&#123;&#125;，这会与location模块的&#123;&#125;冲突，这时候需要将正则表达式用单引号或者双引号起来。如:location ~ &quot;/([\\S]&#123;8&#125;)&quot; &#123; proxy_pass http://127.0.0.1:3000/;&#125; 简单使用加载静态资源配置 nginx 的静态文件有两个指令，一个 root 和一个 alias。 root 是指定项目的根目录，适用与 server 和 location。可以指定多个，如果 locaiton 没有指定，会往其外层的 server 或 http 中寻找继承。 如: 1234567location /static &#123; root /root/webapp/sourceCode/sell;&#125;http://localhost:3100/static/aa.jpg经过nginx等于http://localhost:3100//root/webapp/sourceCode/sell/static/aa.jpg alias 它并不是替换匹配后的 url 地址，而是替换匹配部分的 url。alias 指令也可以有多个。如: 1234567location /static &#123; alias /root/webapp/sourceCode/sell;&#125;http://localhost:3100/static/aa.jpg经过nginx等于http://localhost:3100/root/webapp/sourceCode/sell/aa.jpg 通常最佳实际是配置一个项目的根 root，其他的文件夹则使用 alias，毕竟 alias 更加灵活。 index 指令的作用在前后端分离的基础上，通过 Nginx 配置，指定网站初始页。该指令拥有默认值，index index.html ，即，如果没有给出 index，默认初始页为 index.html。 在没有给出明确的文件名称，index 才会启动，index 的作用就是在你没有给出一个明确名称，会自动分配。 1234location / &#123; root /root/webapp/sourceCode/sell; index index.html index.htm;&#125; proxy_pass在 nginx 中配置 proxy_pass 代理转发时，如果在 proxy_pass 后面的 url 加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也加到代理路径上。 如:http://localhost:3100/proxy/bb.html 进行访问。 1234567891011121314151617181920212223242526第一种：location /proxy/ &#123; proxy_pass http://localhost:8080/;&#125;代理到URL：http://localhost:8080/bb.html第二种（相对于第一种，最后少一个 / ）location /proxy/ &#123; proxy_pass http://localhost:8080;&#125;代理到URL：http://localhost:8080/proxy/bb.html第三种：location /proxy/ &#123; proxy_pass http://localhost:8080/aaa/;&#125;代理到URL：http://localhost:8080/aaa/bb.html第四种（相对于第三种，最后少一个 / ）location /proxy/ &#123; proxy_pass http://localhost:8080/aaa;&#125;代理到URL：http://localhost:8080/aaabb.html 以上有四种情况，但实际就两种情况，第一种与其他三种，只是其他三种有点迷惑性，其实都是一种。 1Nginx实现反向代理，使用Module ngx_http_proxy_module模块，proxy_pass指令，设置请求头为真正的客户端地址proxy_set_header X-Real-IP $remote_addr; 报错: 1nginx: [emerg] &quot;proxy_pass&quot; cannot have URI part in location given by regular expression 这是由于使用了正则 location，但 proxy_pass 的 ip+host 后面有路经，正则匹配后无法拼接上而报错。 解决: 1234567location ^~ /proxy/aaa/ &#123; proxy_pass http://localhost:8080;&#125;或location /proxy/ &#123; proxy_pass http://localhost:8080/aaa;&#125; 当然 nginx 还有很多配置使用，按照自己需要一点一点的查。","tags":[{"name":"liunx","slug":"liunx","permalink":"https://793338023.github.io/tags/liunx/"}]},{"title":"npm、nrm与npx","date":"2019-12-25T15:00:00.000Z","path":"2019/12/25/npm与npx/","text":"前言NPM 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题，如允许用户从 NPM 服务器下载别人编写的第三方包到本地使用、允许用户从 NPM 服务器下载并安装别人编写的命令行程序到本地使用、允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。 以下的操作系统都已 window 的为主，且主要介绍一些我觉得有意思的东西，如简化命令，package.json 里的属性作用等，还有 npm 周边的辅助工具 npx 与 nrm, npmnpm 安装与初始化npm 随着 node 一起安装了，但有时由于 npm 版本不够而需要更新，可以直接更新 npm。 1234// 查看版本npm -v// 更新版本npm install npm -g 如果我们初始化一个模块，那么就会执行 npm init，但这样要填写一些信息，然后输出一个初始化的 package.json，我们可以简化它，然后后面有必要再手动填入。 12// 快速创建npm init -y 依赖包安装依赖管理是 npm 的核心功能，原理就是执行 npm install 从 package.json 中的 dependencies, devDependencies 将依赖包安装到当前目录的 ./node_modules 文件夹中。 而单独安装一个包时，执行 npm install &lt;package&gt; 命令即可，但在 npm 里，除了简单的指定包名, package 还可以是一个指向有效包名的 http(网上资源)、url/git(git 上资源，如 github 或私仓的 gitlab 之类)、url/文件夹路径(本地资源)。 其实只要符合 package 的规则就可以安装到 node_modules 里使用。package的规则有: a) 包含由 package.json 文件描述的程序的文件夹。 b) 含有（a）的压缩的压缩文件，如 module.tar.gz。 c) 解析为（b）的 URL(通常是 http(s) url)。 d) 一个格式为 &lt;name&gt;@&lt;version&gt; 的字符串，可指向 npm 源(通常是官方源 npmjs.org)上已发布的可访问 url，且该 url 满足条件 (c)。 e) 一个格式为 &lt;name&gt;@&lt;tag&gt; 的字符串，在 npm 源上该&lt;tag&gt;指向某 &lt;version&gt; 得到 &lt;name&gt;@&lt;version&gt;，后者满足条件 (d)。 f) &lt;name&gt;具有 latest 满足（e）的标签的模块。 g) 一个 git/url, 该 url 所指向的代码库满足条件 (a)。 本地包/git 上的包的安装这对于私有的不方便 publish 到远程源（即使是私有源），或者需要对某官方源的包进行改造，但依然需要把包共享出去的场景来说非常实用。 如场景一:本地模块引用nodejs 应用开发中不可避免有模块间调用，例如在实践中经常会把需要被频繁引用的配置模块放到应用根目录；于是在创建了很多层级的目录、文件后，很可能会遇到这样的代码: 1const config = require(&apos;../../../../config.js&apos;); 除了看上去很丑以外，这样的路径引用也不利于代码的重构。并且身为程序员的自我修养告诉我们，这样重复的代码多了也就意味着是时候把这个模块分离出来供应用内其他模块共享了。例如这个例子里的 config.js 非常适合封装为 package 放到 node_modules 目录下，共享给同应用内其他模块。无需手动拷贝文件或者创建软链接到 node_modules 目录，npm 有更优雅的解决方案。 实践方式:创建 config 包: 新增 config 文件夹; 重命名 config.js 为 config/index.js 文件; 创建 package.json 定义 config 包; 12345&#123; &quot;name&quot;: &quot;config&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;version&quot;: &quot;0.1.0&quot;&#125; 在应用层 package.json 文件中新增依赖项，然后执行 npm install; 或直接执行第 3 步 （等价于第 2 步）直接在应用目录执行 npm install file:../config此时，查看 node_modules 目录我们会发现多出来一个名为 config，指向同级 config/ 文件夹的软链接(可以看作快捷文件夹)。这是因为 npm 识别 file: 协议的 url，得知这个包需要直接从文件系统中获取，会自动创建软链接到 node_modules 中，完成“安装”过程。相比手动软链，我们既不需要关心 windows 和 linux 命令差异，又可以显式地将依赖信息固化到 dependencies 字段中，开发团队其他成员可以执行 npm install 后直接使用。 例子: 123456789101112131415161718192021项目目录结构├─project ├─package.json ├─index.js ├─packages ├─config ├─package.json ├─index.js ├─demo ├─package.json ├─index.js当前demo关联confignpm i ../config当demo安装上config后就不必再安装，因为是软链接，所以config的改变，demo里的node_modules/config也会一起改变，就像对象引用关系一样，他们都是同一个地址，互相影响而在使用webpack的热加载时，node_modules的包的变化也会触发热加载的，所以当node_modules/config被引用后，如果有修改，那么热加载也会触发。但如果出现包里的文件被引用，然而文件改变为删除后重新创建，那么热加载可能有出问题，就是会出现无法找到文件的报错 场景二:私有 git 共享 package有些时候，我们一个团队内会有一些代码/公用库需要在团队内不同项目间共享，但可能由于包含了敏感内容，或者代码太烂拿不出手等原因，不方便发布到源。 这种情况下，我们可以简单地将被依赖的包托管在私有的 git 仓库中，然后将该 git/url 保存到 dependencies 中. npm 会直接调用系统的 git 命令从 git 仓库拉取包的内容到 node_modules 中。 npm 支持的 git url 格式: 1234&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]// 一般使用http(s),使用ssh需要设置ssh信息，比较麻烦npm i https://github.com/facebook/react.git 场景 3: 开源 package 问题修复使用某个 npm 包时发现它有某个严重 bug，但也许最初作者已不再维护代码了，也许我们工作紧急，没有足够的时间提 issue 给作者再慢慢等作者发布新的修复版本到 npm 源。而私自修改 node_modules 里包的内容是很容易出现覆盖等现象，再根源上没有解决而导致问题重现。 解决正确方式:最好的办法应当是 fork 原作者的 git 库，在自己所属的 repo 下修复问题后，将 dependencies 中相应的依赖项更改为自己修复后版本的 git/url 即可解决问题。（Fork 代码库后，也便于向原作者提交 PR 修复问题。上游代码库修复问题后，再次更新我们的依赖配置也不迟。） npm5 与 package-locknpm5 这一版本最大的变化是增加了 package-lock.json 文件。package-lock.json 的作用是锁定依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件层级结构是一一对应的。 以依赖关系为:webpack 构建项目为例, 其 package-lock 文件包含了这样的片段。 123456789101112131415161718192021222324252627282930&#123;&quot;name&quot;: &quot;react-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;lockfileVersion&quot;: 1, &quot;requires&quot;: true, &quot;dependencies&quot;:&#123; //...其他依赖包 &quot;webpack-dev-middleware&quot;: &#123; &quot;version&quot;: &quot;3.7.0&quot;, &quot;resolved&quot;: &quot;https://registry.npmjs.org/webpack-dev-middleware/-/webpack-dev-middleware-3.7.0.tgz&quot;, &quot;integrity&quot;: &quot;sha512-qvDesR1QZRIAZHOE3iQ4CXLZZSQ1lAUsSpnQmlB1PBfoN/xdRjmge3Dok0W4IdaVLJOGJy3sGI4sZHwjRU0PCA==&quot;, &quot;dev&quot;: true, &quot;requires&quot;: &#123; &quot;memory-fs&quot;: &quot;^0.4.1&quot;, &quot;mime&quot;: &quot;^2.4.2&quot;, &quot;range-parser&quot;: &quot;^1.2.1&quot;, &quot;webpack-log&quot;: &quot;^2.0.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;mime&quot;: &#123; &quot;version&quot;: &quot;2.4.4&quot;, &quot;resolved&quot;: &quot;https://registry.npmjs.org/mime/-/mime-2.4.4.tgz&quot;, &quot;integrity&quot;: &quot;sha512-LRxmNwziLPT828z+4YkNzloCFC2YM4wrB99k+AV5ZbEyfGNWfG8SO1FUXLmLDBSo89NrJZ4DIWeLjy1CHGhMGA==&quot;, &quot;dev&quot;: true &#125; &#125; &#125;, //...其他依赖包 &#125;&#125; package-lock 其主要字段是 version, resolved, integrity, requires, dependencies 这几个字段而已。version, integrity, resolved 用来记录包的准确版本号、内容 hash、安装源的，决定了要安装的包的准确“身份”信息。 从 dependencies: {} 里的内容我们会发现，整个文件的 JSON 配置里的 dependencies 层次结构与文件系统中 node_modules 的文件夹层次结构是完全对照的，除最外层的 requires 属性为 true 以外, 其他层的 requires 属性都对应着这个包的 package.json 里记录的自己的依赖项 dependencies 属性，而 dependencies 对应既这个包里 node_modules 所拥有的文件。如图: node 因为这个文件记录了 node_modules 里所有包的结构、层级和版本号甚至安装源，它也就事实上提供了 “保存” node_modules 状态的能力。只要有这样一个 lock 文件，不管在那一台机器上执行 npm install 都会得到完全相同的 node_modules 结果。 package-lock 文件致力于优化的场景:在从前仅仅用 package.json 记录依赖，由于 包依赖的版本范围的机制；一个月前由 A 生成的 package.json 文件，B 在一个月后根据它执行 npm install 所得到的 node_modules 结果很可能许多包都存在不同的差异，虽然这个机制的限制使得同一份 package.json 不会得到大版本不同的依赖包，但同一份代码在不同环境安装出不同的依赖包，依然是可能导致意外的潜在因素。 而禁止它在.npmrc 设置或命令设置 1234// 在当前项目新建 .npmrcpackage-lock=false// 命令设置，会禁用所有项目package-lock.jsonnpm config set package-lock false npm scriptsnpm scripts 是 npm 另一个很重要的特性。通过在 package.json 中 scripts 字段定义一个脚本，例如： 12345&#123; &quot;scripts&quot;: &#123; &quot;echo&quot;: &quot;echo hello world&quot; &#125;&#125; 我们就可以通过 npm run echo 命令来执行这段脚本，像在 shell 中执行该命令 echo hello world 一样，看到终端输出 hello world.npm scripts 的基本使用就是这么简单，它提供了一个简单的接口用来调用工程相关的脚本。 简单的总结一下: npm run 命令执行时，会把 ./node_modules/.bin/ 目录添加到执行环境的 PATH 变量中，因此如果某个命令行包未全局安装，而只安装在了当前项目的 node_modules 中，通过 npm run 一样可以调用该命令。 执行 npm 脚本时要传入参数，需要在命令后加 – 标明, 如 npm run test – –grep=”pattern” 可以将 –grep=”pattern” 参数传给 test 命令。 npm 提供了 pre 和 post 两种钩子机制，可以定义某个脚本前后的执行脚本。 运行时变量：在 npm run 的脚本执行环境内，可以通过环境变量的方式获取许多运行时相关信息，以下都可以通过 process.env 对象访问获得： npm_lifecycle_event - 正在运行的脚本名称 npm_package_&lt;key&gt; - 获取当前包 package.json 中某个字段的配置值：如 npm_package_name 获取包名 npm_package_&lt;key&gt;_&lt;sub-key&gt; - package.json 中嵌套字段属性：如 npm_pacakge_dependencies_webpack 可以获取到 package.json 中的 dependencies.webpack 字段的值，即 webpack 的版本号。 npm bin上面所说的 node_modules/.bin 目录，保存了依赖目录中所安装的可供调用的命令行包。何谓命令行包？例如 webpack 就属于一个命令行包。当我们把 webpack 安装到项目的 node_modules 里时当前包里 package.json 的 bin 字段就会配置的 node_modules/.bin 目录里，让我们可以在局部执行避免全局包版本不一致导致的问题。 webpack 在 package.json 文件中定义了 bin 字段为: 12345&#123; &quot;bin&quot;: &#123; &quot;webpack&quot;: &quot;./bin/webpack.js&quot; &#125;&#125; 而安装在 node_modules/.bin 里的一般通过 npm scripts，否则只能安装到全局里，如: 1npm i webpack -g 这样就可以直接在 cmd 命令行工具使用。 但 npm 也提供了别的方式调用项目里的命令行包，为 npx，下面会单独描述。 npm 发布 你需要一个 npm账号。这是流程的一部分。 在当前项目打开终端输入: 1npm login 你会得到一个让你输入 username、password 和 email 的提示。把它们填在相应的位置吧！ 在当前项目打开终端输入: 1npm publish npm 不许发布已有的包名与相同的版本的包，所以每次发布都需要修改 package.json 的 version。 修改 version 的命令: 1234567// version x.y.z// 自增znpm version patch// 自增ynpm version minor// 自增xnpm version major 发布到私仓里，需要 package.json 配置 12345&#123; &quot;publishConfig&quot;:&#123; &#123;&quot;registry&quot;:&quot;私仓地址&quot;&#125; &#125;&#125; 而发布的时注意 devDependencies 与 dependencies 里的依赖，因为安装在 dependencies 的包会在项目下载这个包时一并下载，而安装到 devDependencies 里的依赖就不会被下载，因为 devDependencies 是开发使用的依赖，而 dependencies 是包需要的依赖，所以在开发 npm 包时需要注意这样的区别，否则包下载会因为不必要的依赖而导致下载缓慢。 撤销发的包其实发的包,可能会有人下载了,并在使用,所以撤销包,需要慎重。 12345//撤销发布,需要在24小时内完成操作,下一次再发包,不能发同名的了$ npm unpublish//更好的一个做法,是声明遗弃$ npm deprecate &lt;pkgname&gt; 基本快捷方式与命令我们从最基本的开始,学习最常见的 npm 快捷方式从长远来将会节省很多时间。 1234567891011121314151617安装 — 常规：npm install，简写：npm i。测试 — 常规：npm test，简写：npm t。帮助 — 常规：npm --help，简写：npm -h。全局标志 — 常规：--global，简写：-g。保存为开发依赖 - 常规： --save-dev，简写：-D。保存为项目依赖 - 常规: --save，简：-S。包更新 - 常规: npm update ,简写: npm up包删除 - 常规: npm uninstall,简写: npm unnpm init 默认值 - 常规：npm init --yes 或 npm init --force，简写：npm init -y 或 npm init -f 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859查看项目中模块所在的目录npm root查看全局安装的模块所在目录npm root -g查看某个包的信息npm view 包名&lt;指定版本&gt;若不指定版本，则为最新版本如:npm view chalk查看本地下载包的版本信息如:查看项目内的reactnpm ls react查看全局的reactnpm ls react -g检查包里所有的过期依赖npm outdated查看npm使用的所有文件夹，就是npm的帮助文档，基本上npm的使用都有，了解使用npm很有用npm help folders访问package.json的字段文档，package.json帮助文档，了解使用package.json很有用npm help json发布一个npm包的时候，需要检验某个包名是否已经存在npm search 模块名清除npm的缓存，没必要，最好不要使用，具体可以使用npm help folders了解npm cache clean查看某个模块的bugs列表界面,打开包的github仓库的issuenpm bugs 模块名如:npm bugs react打开包的github仓库界面npm repo 模块名如:npm repo antd打开某个模块的文档，如打开readme.md文档或打开官网npm docs 模块名打开某个模块的主页，如打开readme.md文档或打开官网npm home 模块名清除未被使用到的模块npm pruneNPM 5.7.0 引入了一种新的安装依赖的方式npm ci npm ci 资料一npm ci 资料二npm view 更多资料 根的快捷方式. 符号通常用于表示应用程序的根目录，npm 术语中的应用程序入口点，即 package.json 中指定为“main”的值。 123&#123; &quot;main&quot;: &quot;index.js&quot;&#125; 当我们需要发布一个包时，直接引用包名就可以使用包，如 1234npm i react// 当前项目就可以使用import react from &apos;react&apos;// 会直接查看package.json的main字段路径 npx这个是在 npmv5.2.0 引入的一条命令，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。 举个例子，我们开发中要运行 webpack 命令来打包，以前有这么几种方式： 全局安装 webpack，但有时不同项目使用不同版本，不允许使用全局包，只能考虑下面一些方法 使用 npm scripts，在 package.json 加一个 script 12345&#123; &quot;scripts&quot;: &#123; &quot;webpack&quot;: &quot;webpack&quot; &#125;&#125; 然后执行 npm run webpack 将 node_modules 的可执行目录(.bin)加到 PATH 中 1alias npmx=PATH=$(npm bin):$PATH 然后执行 npmx webpack 指定可执行命令路径 1./node_modules/.bin/webpack 现在我们有了 npx 命令，就不在需要考虑以上方法了（其实 npx 是对方法 3 的封装）。当我们执行 webpack 时，会自动去./node_modules/.bin 目录下搜索。如: 1npx webpack -p 参数用于指定 npx 所要安装的模块 1npx -p node@0.12.8 node -v 上面命令先指定安装 node@0.12.8，然后再执行 node -v 命令。 nrm开发的 npm registry 管理工具 nrm, 能够查看和切换当前使用的 registry,一个比较废的功能，因为我们可以使用npm config edit修改配置文件的 registry 达到同样的效果，但可以了解一下。 nrm 的安装 1npm install -g nrm nrm 命令: 1234567nrm ls // 查看所有的支持源（有*号的表示当前所使用的源,以下[name]表示源的名称）nrm use [name] // 将npm下载源切换成指定的源nrm help // 查看nrm帮助nrm home [name] // 跳转到指定源的官网 当切换源后使用 npm 下载时就会从当前源下载。","tags":[{"name":"npm","slug":"npm","permalink":"https://793338023.github.io/tags/npm/"}]},{"title":"liunx-虚拟机使用","date":"2019-12-21T03:13:11.000Z","path":"2019/12/21/liunx-虚拟机使用/","text":"工具virtualBox + CentOS-6.8 virtualBox 官网下载即可。 CentOS-6.8 这个镜像有点旧，网上下载一个最新版的镜像，否则在安装一些环境时会出现 libc.so.6 与 GLIBCXX\\* 的错误，比如在安装 node 时我就出现这些错误，但此类的问题在网上都可以搜索到解决方法，都是下载 libc.so.6 与 GLIBCXX\\*的适合版本，然后安装，重新建立软链，但在删除/lib64/libc.so.6，后 LD_PRELOAD 执行与 ln 软链要一起执行，否则会出现无法执行软链的情况。 12345// 先删除先前的 libc.so.6 软链rm -rf /lib64/libc.so.6// 在执行 LD_PRELOAD 与 lnLD_PRELOAD=/lib64/libc.2.4.so ln -s libc.2.4.so libc.so.6 linux 调用 so 的库文件时，搜素路径为当前路径，再是系统 lib 目录。但是提供了一个 LD_PRELOAD 系统变量来改变这个顺序。设置 LD_PRELOAD 了后，库加载的顺序就改为：搜素路径为： LD_PRELOAD ，当前路径，再是系统 lib 目录。 glibc 版本下载 virtualbox-CentOS 安装 virtualbox-Ubuntu 安装 其实 CentOS 与 Ubuntu 安装区别不大，主要 Ubuntu 的操作方便，界面优美。 注意:安装好后使用 root 用户登陆,由于是自己测试的尽量使用最大权限，否则安装一些环境之类的就无法操作 网络设置虚拟机连接网络有好几种，作用也不一样，而我这里使用的时 NAT 连接，而 virtualbox 可以设置局部的 NAT，也可以设置全局的 NAT，NAT 是虚拟机与主机之间共用网络，所以可以设置为同一网段即可互相通信。 具体操作可以看VirtualBox 在 NAT 模式下主机连接虚拟机的方法 如果不了解自己的设置后为什么不能直接使用 liunx 的 ip:端口被主机访问，可以使用端口转发功能，设置主机 ip 与被转发的端口、liunx 的 ip 与转发端口。 如: 1192.168.92.1 22 10.0.2.4 22 重启网络 1service network restart 安装 nodenode 下载地址:https://nodejs.org/download/release/ 选择适合版本下载如: 1wget https://nodejs.org/download/release/latest/node-v13.5.0-linux-x64.tar.xz wget 是一个下载文件的工具，它用在命令行下。对于 Linux 用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。 wget 支持 HTTP，HTTPS 和 FTP 协议，可以使用 HTTP 代理。所谓的自动下载是指，wget 可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个 wget 下载任务，然后退出系统，wget 将在后台执行直到任务完成。 node 安装过程12345678解压tar -xvf node-v13.5.0-linux-x64.tar.xz重命名mv node-v13.5.0-linux-x64.tar.xz nodeJs移动到/opt目录mv nodeJs /opt /opt 主机额外安装软件所摆放的目录。默认是空的。一般安装软件的时候，可以自己指定安装到这个目录下，便于查找和管理。 12345678910111213添加环境变量vim /etc/profile并在文件的末尾添加三行NODE_PATH=/opt/nodeJsPATH=$NODE_PATH/bin:$PATHexport PATH NODE_PATH配置完成后执行,否则配置不起效果source /etc/profile测试node -v /etc/profile文件的改变会涉及到系统的环境,也就是有关 Linux 环境变量的东西。 export 设置或显示环境变量。 Linux 环境变量配置资料 主机访问 liunx 的部署项目新建 webapp 文件夹，在当前目录下执行，创建项目 1234npx koa-generator -e project(项目名称)cd projectnpm installnpm start 如果 NAT 模式下不能直接访问的，先添加端口转发，然后进行访问项目 如 12345端口转发配置192.168.92.1 3000 10.0.2.4 3000然后主机浏览器访问即可http://192.168.92.1:3000/","tags":[{"name":"liunx","slug":"liunx","permalink":"https://793338023.github.io/tags/liunx/"}]},{"title":"koa例子","date":"2019-12-07T07:06:16.000Z","path":"2019/12/07/koa例子/","text":"前言koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 脚手架1234567891011121.安装 cli：npm install -g koa-generator2.新建项目koa2 [name]3.安装依赖cd [name]npm i4.运行npm run dev 使用使用 koa 脚手架搭建的，基本上已经满足开发了，但为了方便开发，可以把路由调整一下，因为每次添加路由都操作 app.js 文件，有点麻烦。koa 官网 app.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const Koa = require(&quot;koa&quot;);const app = new Koa();const views = require(&quot;koa-views&quot;);const json = require(&quot;koa-json&quot;);const onerror = require(&quot;koa-onerror&quot;);const bodyparser = require(&quot;koa-bodyparser&quot;);const logger = require(&quot;koa-logger&quot;);const routes = require(&quot;./router&quot;);// error handleronerror(app);// middlewaresapp.use( bodyparser(&#123; enableTypes: [&quot;json&quot;, &quot;form&quot;, &quot;text&quot;] &#125;));app.use(json());app.use(logger());app.use(require(&quot;koa-static&quot;)(__dirname + &quot;/public&quot;));app.use( views(__dirname + &quot;/views&quot;, &#123; extension: &quot;pug&quot; &#125;));// loggerapp.use(async (ctx, next) =&gt; &#123; const start = new Date(); await next(); const ms = new Date() - start; console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);&#125;);// routesroutes(app);// error-handlingapp.on(&quot;error&quot;, (err, ctx) =&gt; &#123; console.error(&quot;server error&quot;, err, ctx);&#125;);module.exports = app; router.js 123456789101112131415const routesArr = [&quot;index&quot;, &quot;users&quot;];const baseUrl = &quot;./routes&quot;;function routes(app) &#123; const newRouters = routesArr.map(url =&gt; &#123; return `$&#123;baseUrl&#125;/$&#123;url&#125;`; &#125;); newRouters.forEach(url =&gt; &#123; const router = require(url); app.use(router.routes(), router.allowedMethods()); &#125;);&#125;module.exports = routes; 但还可以弄得更加方便，就是使用 fs，读取出所有的路由文件，自动注册路由。 123456789101112131415161718192021222324252627282930const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const baseUrl = &quot;./routes&quot;;// 递归目录 读取文件function readFileList(dir, filesList = []) &#123; const files = fs.readdirSync(dir); files.forEach((item, index) =&gt; &#123; var fullPath = path.join(dir, item); const stat = fs.statSync(fullPath); if (stat.isDirectory()) &#123; readFileList(path.join(dir, item), filesList); //递归读取文件 &#125; else &#123; filesList.push(fullPath); &#125; &#125;); return filesList;&#125;function routes(app) &#123; let filesList = []; readFileList(path.resolve(process.cwd(), baseUrl), filesList); filesList.forEach(url =&gt; &#123; const router = require(url); app.use(router.routes(), router.allowedMethods()); &#125;);&#125;module.exports = routes;","tags":[{"name":"node","slug":"node","permalink":"https://793338023.github.io/tags/node/"}]},{"title":"react与rc-form","date":"2019-11-30T08:00:58.000Z","path":"2019/11/30/react与rc-form/","text":"前言在选择使用 react 技术栈的时，往往都会选择一套成熟好用而且自己熟悉的 UI 框架，而我使用比较多的ant Design,这样可以减少开发成本与风险，因为自己开发的组件总会有考虑不周的 BUG，而 antd 里有很多优秀的组件，但我觉得在表单方面，antd 的这个组件做的很优秀，也很灵活，它的核心也在校验，这篇主要是 Form 校验。 表单作用真正需要表单的时候，一般都因为以下功能： 收集各表单项的数据。 按照要求，对表单项数据进行校验，并显示校验结果。 最总获取所有的表单数据，并表单中所有数据进行校验。 而这些功能 antd 都可以直接按官网案例使用，简单快速，但 antd 实现这些功能也是很简单的，主要是因为它把数据收集与校验都交给了 rc-form 去实现，剩下的 UI 展示才是 antd 实现的。 antd 的 Form 实现Form.tsx 在 form 的 Form.tsx 只是简单的实现了 Form 的 UI 与 rc-form 的 create 表单，使用 createReactContext 传递了通用布局属性。 1234567891011121314151617181920212223242526// 此处为Form.create的实现，主要调用了createBaseForm// fieldMetaProp规定了重造组件里存储的表单规则，如校验等，fieldDataProp规定了表单的数据，所以获取到react组件，就可以知道表单属性设置与数据 static create = function create&lt;TOwnProps extends FormComponentProps&gt;( options: FormCreateOption&lt;TOwnProps&gt; = &#123;&#125;, ): FormWrappedProps&lt;TOwnProps&gt; &#123; return createDOMForm(&#123; fieldNameProp: &apos;id&apos;, ...options, fieldMetaProp: FIELD_META_PROP, fieldDataProp: FIELD_DATA_PROP, &#125;); &#125;;// 创建表单与createReactContext传递UI布局属性 render() &#123; const &#123; wrapperCol, labelAlign, labelCol, layout, colon &#125; = this.props; return ( &lt;FormContext.Provider value=&#123;&#123; wrapperCol, labelAlign, labelCol, vertical: layout === &apos;vertical&apos;, colon &#125;&#125; &gt; &lt;ConfigConsumer&gt;&#123;this.renderForm&#125;&lt;/ConfigConsumer&gt; &lt;/FormContext.Provider&gt; ); &#125; FormItem.tsx 实现了需要校验组件的布局与校验信息显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 通过这两个方法获取到组件上的所有表单信息，如值、校验信息，获取的方式就是在组件的props的FIELD_META_PROP与FIELD_DATA_PROP上。 getMeta() &#123; return this.getChildProp(FIELD_META_PROP); &#125; getField() &#123; return this.getChildProp(FIELD_DATA_PROP); &#125;// 通过getValidateStatus获取校验的状态 getValidateStatus() &#123; const onlyControl = this.getOnlyControl(); if (!onlyControl) &#123; return &apos;&apos;; &#125; const field = this.getField(); if (field.validating) &#123; return &apos;validating&apos;; &#125; if (field.errors) &#123; return &apos;error&apos;; &#125; const fieldValue = &apos;value&apos; in field ? field.value : this.getMeta().initialValue; if (fieldValue !== undefined &amp;&amp; fieldValue !== null &amp;&amp; fieldValue !== &apos;&apos;) &#123; return &apos;success&apos;; &#125; return &apos;&apos;; &#125;// renderValidateWrapper根据校验状态，选择html结构与css类名，显示校验信息 renderValidateWrapper( prefixCls: string, c1: React.ReactNode, c2: React.ReactNode, c3: React.ReactNode, ) &#123; const &#123; props &#125; = this; const onlyControl = this.getOnlyControl; const validateStatus = props.validateStatus === undefined &amp;&amp; onlyControl ? this.getValidateStatus() : props.validateStatus; let classes = `$&#123;prefixCls&#125;-item-control`; if (validateStatus) &#123; classes = classNames(`$&#123;prefixCls&#125;-item-control`, &#123; &apos;has-feedback&apos;: props.hasFeedback || validateStatus === &apos;validating&apos;, &apos;has-success&apos;: validateStatus === &apos;success&apos;, &apos;has-warning&apos;: validateStatus === &apos;warning&apos;, &apos;has-error&apos;: validateStatus === &apos;error&apos;, &apos;is-validating&apos;: validateStatus === &apos;validating&apos;, &#125;); &#125; let iconType = &apos;&apos;; switch (validateStatus) &#123; case &apos;success&apos;: iconType = &apos;check-circle&apos;; break; case &apos;warning&apos;: iconType = &apos;exclamation-circle&apos;; break; case &apos;error&apos;: iconType = &apos;close-circle&apos;; break; case &apos;validating&apos;: iconType = &apos;loading&apos;; break; default: iconType = &apos;&apos;; break; &#125; const icon = props.hasFeedback &amp;&amp; iconType ? ( &lt;span className=&#123;`$&#123;prefixCls&#125;-item-children-icon`&#125;&gt; &lt;Icon type=&#123;iconType&#125; theme=&#123;iconType === &apos;loading&apos; ? &apos;outlined&apos; : &apos;filled&apos;&#125; /&gt; &lt;/span&gt; ) : null; return ( &lt;div className=&#123;classes&#125;&gt; &lt;span className=&#123;`$&#123;prefixCls&#125;-item-children`&#125;&gt; &#123;c1&#125; &#123;icon&#125; &lt;/span&gt; &#123;c2&#125; &#123;c3&#125; &lt;/div&gt; ); &#125; 所以使用 antd Form 需要把组件放到 Form 与 FormItem 里,否则会出现 UI 问题。 rc-formrc-form 的实现是使用了高阶组件，这里不说高阶组件，然后利用闭包的收集数据，类似与全局变量，创建一个对象，根据 ID 收集放到对应的 ID 里，简单就是这样。源码主要看 createBaseForm 与 createFieldsStore，createBaseForm 主要是实现功能，如校验，获取数据等等，而 createFieldsStore 主要实现数据收集与处理，然后让 createBaseForm 使用。 createBaseForm 数据的更新是使用了 forceUpdate，这是 react 强制更新组件的方法，可以在没有触发 setState 时触发 render 来实现数据更新，它的实现与 setState 差不多。 mapPropsToFields 的实现: 123456789101112// 初始化getInitialState() &#123; const fields = mapPropsToFields &amp;&amp; mapPropsToFields(this.props); this.fieldsStore = createFieldsStore(fields || &#123;&#125;);...&#125;// 父组件state变化componentWillReceiveProps(nextProps) &#123; if (mapPropsToFields) &#123; this.fieldsStore.updateFields(mapPropsToFields(nextProps)); &#125; &#125; 由于在创建组件时都用 Form 包含，所以组件之间需要经过 Form，那么就可以利用这个实现数据映射关系。 所有的校验都会统一走 validateFieldsInternal 方法，而一般的回填与映射是不会触发校验的，只有符合事件的或手动调用校验才会触发校验，而校验使用的async-validator这个包。 注意事项: 由于 rc-form 的 ID 允许嵌套，所以 ID 避免实现”.”与[,如 abc.mm,abc[0] rc-form 校验的 type 为 Array 时，避免 ID 带数字，如 abc111m1 具体实现可以查看资料","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"git提交前代码检查","date":"2019-11-19T13:19:24.000Z","path":"2019/11/19/git提交前代码检查/","text":"前言当项目在团队上开发时，总要遵循一些规范，就算使用了 tslint 或 eslint 等，但上交代码时由于没有禁止不良代码，有些人在不遵守规范时，还是会提交那么很坑的代码，让我们的项目挂了，这个时候，所以一切的代码在不经过检查，都不能信任，而这一层的把关，我交给 git 的钩子。 原理当我们使用 git 时，都会有一个.git 的文件夹，而它底下有所有的钩子，在 hooks 目录下，我们可以看到目录下有 commit-msg.sample、pre-commit.sample 等文件，这些都是案例文件，不会执行，要想执行的话把后面的.sample 后缀去掉就可以了。钩子执行顺序是有先后的 前置（pre）钩子，在动作完成前调用 后置（post）钩子，在动作完成后执行 而我们利用这个钩子实现提交前检查代码，不符合的，就停止提交。 安装插件12345npm install husky lint-staged --D检查代码使用eslint或tslintnpm install eslint --Dnpm install tslint --D eslint：进行 JavaScript 代码检查的基础包； tslint: TypeScript 代码检查的基础包； husky：在 .git/4 hooks 中写入 pre-commit 等脚本激活钩子，在 Git 操作时触发； lint-staged：参考 Git 中 staged 暂存区概念，在每次提交时只检查本次提交的文件。 使用在 package.json 配置 husky 与 lint-staged。 tslint: 123456789101112&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot; // pre-commit，提交前的钩子 &#125; &#125;, &quot;lint-staged&quot;: &#123; // 此处可以配置文件夹和文件类型的范围 &quot;src/**/*.&#123;txs,ts&#125;&quot;: [ &quot;tslint&quot;, // 再使用tslint &quot;git add&quot; // 所有通过的话执行git ] &#125; eslint: 123456789101112&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot; // pre-commit，提交前的钩子 &#125; &#125;, &quot;lint-staged&quot;: &#123; // 此处可以配置文件夹和文件类型的范围 &quot;src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125;&quot;: [ &quot;eslint --fix&quot;, // 再使用eslint进行自动修复 &quot;git add&quot; // 所有通过的话执行git ] &#125; 至于 eslint 或 tslint 的配置，这个就需要自己百度。 tslint 例子 123456789101112131415161718192021222324252627282930&#123; &quot;extends&quot;: &quot;tslint&quot;, &quot;rules&quot;: &#123; &quot;no-parameter-properties&quot;:false, // 禁止给类的构造函数的参数添加修饰符 &quot;triple-equals&quot;:false, &quot;no-debugger&quot;: true, // 禁止行尾有空格 &quot;no-trailing-whitespace&quot;: false, &quot;member-ordering&quot;:false, &quot;no-this-assignment&quot;: [true, &#123;&quot;allowed-names&quot;: [&quot;^self$&quot;,&quot;^that$&quot;], &quot;allow-destructuring&quot;: true&#125;], // 必须使用箭头函数，除非是单独的函数声明或是命名函数 &quot;only-arrow-functions&quot;: [ false, &quot;allow-declarations&quot;, &quot;allow-named-functions&quot; ], // 禁止出现空代码块，允许 catch 是空代码块 &quot;no-empty&quot;: [ false, &quot;allow-empty-catch&quot; ], // 禁止无用的类型断言 &quot;no-unnecessary-type-assertion&quot;: false, // 使用 return; 而不是 return undefined; &quot;return-undefined&quot;: false, // 禁止对 array 使用 for in 循环 &quot;no-for-in-array&quot;: false, &quot;comment-format&quot;: [true, &quot;check-space&quot;] // 单行注释格式化规则 &#125;&#125; eslint 例子: 123456789101112131415161718192021222324252627&#123; &quot;extends&quot;: [&quot;airbnb&quot;, &quot;plugin:prettier/recommended&quot;], // eslint扩展规则 &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 7, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125; &#125;, &quot;parser&quot;: &quot;babel-eslint&quot;,// 解决ES6 improt会报错 &quot;env&quot;: &#123; // eg如果不配置browser，window就会被eslint报undefined的错 &quot;es6&quot;: true, &quot;browser&quot;: true, &quot;node&quot;: true &#125;, &quot;plugins&quot;: [&quot;react&quot;, &quot;jsx-a11y&quot;, &quot;import&quot;], &quot;rules&quot;: &#123; &quot;class-methods-use-this&quot;: 0, &quot;import/no-named-as-default&quot;: 0, &quot;react/jsx-filename-extension&quot;: [ &quot;error&quot;, &#123; &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;] &#125; ] &#125;&#125; 当然我们还可以使用 prettier 美化提交的代码。prettier 配置资料(https://blog.csdn.net/visionke/article/details/92817269)","tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://793338023.github.io/tags/代码规范/"}]},{"title":"微前端之systemJS与lerna","date":"2019-11-13T15:06:29.000Z","path":"2019/11/13/微前端之systemJS与lerna/","text":"前言微前端架构是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。 由此带来的变化是，这些前端应用可以独立运行、独立开发、独立部署。以及，它们应该可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。 可以解决的问题:拆分工程，解决打包速度的问题，减少一个工程太多人开发出现的互相冲突的问题，降低项目的复杂度，提高项目可维护性与修改性的问题，无论在管理上还是代码上都大大提高工作效率。 这里只是描述一下微前端，最要还是 systemJS 与 lerna，因为他们在微前端上是核心。 微前端实现的方式 使用 HTTP 服务器的路由来重定向多个应用 在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA 通过组合多个独立应用、组件来构建一个单体应用 iFrame。使用 iFrame 及自定义消息传递机制 使用 Web Components 构建应用 第一种是目前比较传统的方式，如 A 项目与 B 项目互相跳转，那么我们只要在 URL 上带上个项目需要参数即可，就是很简单的页面跳转方式，也是很通用的方式，就是会页面刷新并且互相之间不能嵌套或复用。 第二种方式，是符合现在单页面应用的方式，而且可以互相复用，但需要基于 webpack 等打包工具。 第三种其实就是一个应用，只是把它分开开发，所以必须使用同一个框架，统一依赖，规范应用的组件及路由，共享通用代码，制定代码规范，比如使用 lerna 管理项目。 第四种 iFrame 其实与第一种差不多，只是它可以嵌套在别的项目里，实现互相嵌套的模式。 第五种 Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 Web 应用中使用它们，它的引用方式与 iframe 类似，组件拥有自己独立的 Scripts 和 Styles，以及对应的用于单独部署组件的域名，但它不成熟，不过它很有可能是以后微前端的技术方向，因为它很适合，且将来浏览器应该都支持，而不需要构建工具，浏览器支持才是最 nice 的。 systemJSsystemJS 其实就是一个模块化加载器，本意是解决项目在运行时加载模块的问题，因为 webpack 等打包工具都是编译好后再到客户端上，而想在客户端上加载时不可能的。但 systemJS 无法直接使用 import 加载后使用，只能在 html 里 script 引入。 123456789101112&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/system.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/amd.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/named-exports.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/named-register.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/6.1.1/extras/use-default.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; System.import( &quot;http://localhost:8000/static/js/main-bundle-11a3188c.js&quot; ).then(() =&gt; &#123; // console.log($); &#125;);&lt;/script&gt; 但可以 npm 安装。 1npm i systemjs webpack 打包的，要让 systemjs 可以加载，那么就要设置 libraryTarget 为 umd 12345output: &#123; filename: &quot;static/js/[name]-bundle-[hash:8].js&quot;, library: &quot;app&quot;, //类库名称 libraryTarget: &quot;umd&quot; //类库加载方式 &#125; 而微服务里比较流行的是 single-Spa，它其实就是一个顶级的路由，只是它是以项目为维度的，而且它兼容很多目前比较流行的技术的项目的路由，如 react，vue，angular 等等，他可以糅合它们，而且不需要前期考虑是否使用微前端，之后后期需要，就可以使用它进行重新改造，且付出代价也是最小的，可能就是需要修改一个路由的层级，因为一级路由以为项目使用。 资料 基本使用 single-Spa single-Spa 使用 lernalerna 是 GitHub 上面开源的一款 js 代码库管理软件， 用来对一系列相互耦合比较大、又相互独立的 js git 库进行管理。解决各个库之间修改混乱、难以跟踪的问题。lerna 可以优化这种情形下的工作流。 代码库结构 1234567my-lerna-repo/ package.json packages/ package-1/ package.json package-2/ package.json 由于微前端也是多个项目模块，而且也会互相耦合且独立，所以使用 lerna 管理，在某些场景下，可能会出现意想不到的优势，比如个项目之间的依赖包统一，各项目之间依赖简单，且快速统一更新包等，且只要在外层就可管理到所有的项目。 初始化 1234npm i -g lernamkdir lerna-repocd ./lerna-repolerna init 常用命令 123456789101112131415161. 安装lerna bootstrap使用这个指令代替 npm install相当于在每个 package 下面执行 npm install根据各个 package 下 package.json 里面的 dependencies 和 devDependencies 配置，使用 symlink 在各个 package 的 node_modules 下面建立引用关系2. 添加依赖lerna add &lt;pkg&gt; [globs..]如给 package-1 添加 依赖 vue，scope后要跟package.json里面的名字，而不是文件夹名。如果全部安装，去掉scope即可。lerna add vue --scope=@abc/package-13. 指定源例如使用yarn管理包 lerna bootstrap --npm-client=yarn例如使用cnpm发布包 lerna publish --npm-client=cnpm lerna 的基础使用 lerna 项目中使用","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"webpack之实现loader","date":"2019-10-26T03:59:30.000Z","path":"2019/10/26/webpack之实现loader/","text":"前言在使用 webpack 时，我们一般都会知道 loader 与 plugin,因为在使用 webpack 时，必不可少，而这边主要了解和知道怎么实现 loader。loader 是一种对指定内容的打包方案，如在 webpack 中的 rules 某一条配置的规则 test 是匹配 css 类的文件，当遇到这类 css 格式文件，webpack 就会执行这条 rules 里的 loader,实现我们期望的内容打包处理。而 Npm 上有各种各样的 loader 供我们使用，一般情况下，直接下载使用即可，没有必要自己动手实现，但由于项目的特殊性，npm 无法找到适合的包，那么只能自己实现。 什么是 Loader本质上来说，loader 就是一个 node 模块，既然是 node 模块，那就一定会导出点什么。在 webpack 的定义中，loader 导出一个函数，loader 会在转换源模块（resource）的时候调用该函数。在这个函数内部，我们可以通过传入 this 上下文给 Loader API 来使用它们。简单说，就是与写 node 没有很大区别，只是 webpack 那些 Loader API 都使用需要使用 this 调用。 如: 1234567module.exports = function(content) &#123; if (this.query.isAdd) &#123; return content+&quot;isAdd&quot;; &#125; else &#123; return content; &#125;&#125;; 在 webpack config 里怎么使用自定 loader一般有三种方式: 把编写好的 loader 模块发布到 npm 上或放到 package.json 能把包引入到 node_mudules 的地址上。 npm link 方式关联起来。 使用 require.resolve 或 path.resolve 方式引入。如 123require.resolve(&quot;../loader/add-body-css-loader&quot;)----path.resolve(__dirname, &quot;../loader/add-body-css-loader&quot;) 而 loader 的加载调用顺序是自下而上或自右到左的方式，而 source 是一层层 loader 去处理的，就像加工厂一样。 12345678&#123; test: /\\.module\\.(scss|sass)$/, use: [ require.resolve(&quot;style-loader&quot;), require.resolve(&quot;postcss-loader&quot;), require.resolve(&quot;../loader/add-body-css-loader&quot;) ]&#125; 从 add-body-css-loader-&gt;postcss-loader-&gt;style-loader 然后输出到文件里。 用正确的姿势开发 Loader 单一职责一个 loader 只做一件事，这样不仅可以让 loader 的维护变得简单，还能让 loader 以不同的串联方式组合出符合场景需求的搭配。 链式组合这一点是第一点的延伸。好好利用 loader 的链式组合的特型，可以收获意想不到的效果。具体来说，写一个能一次干 5 件事情的 loader ，不如细分成 5 个只能干一件事情的 loader，也许其中几个能用在其他你暂时还没想到的场景。 Loader 实用工具loader-utilsschema-utils 使用来校验 Options。 例子sass、less 等简单的生成主题处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const log4js = require(&quot;../config/log4js&quot;), logger = log4js.getLogger(&quot;info&quot;);function replace(source) &#123; const theme = this.query.theme; let isBody = false; let content = source; let loader = this.query.loader; Object.keys(theme).forEach(item =&gt; &#123; Object.keys(theme[item]).forEach(item =&gt; &#123; if (~source.indexOf(item)) &#123; isBody = true; &#125; &#125;); &#125;); if (isBody) &#123; if (~loader.indexOf(&quot;less&quot;)) &#123; content = createThemeLessVar(theme, source, loader); &#125; else if (~loader.indexOf(&quot;sass&quot;)) &#123; content = createThemeSassVar(theme, source, loader); &#125; &#125; return content;&#125;function createThemeSassVar(theme, source, loader) &#123; let prefix = &quot;$&quot;; let reg = /(@import[^\\n]*)/g; let importCss = source.match(reg) || &quot;&quot;; if (importCss) &#123; importCss = importCss.join(&quot;\\n&quot;); &#125; let newSource = source.replace(reg, &quot;&quot;); let content = `$&#123;importCss&#125;`; Object.keys(theme).forEach(item =&gt; &#123; let allVar = Object.entries(theme[item]) .map(item =&gt; &#123; return prefix + item[0] + &quot;:&quot; + item[1]; &#125;) .join(&quot;;&quot;) + &quot;;&quot;; content += ` body[data-theme=&quot;$&#123;item&#125;&quot;]&#123; $&#123;allVar&#125; $&#123;newSource&#125; &#125; `; &#125;); return content;&#125;function createThemeLessVar(theme, source, loader) &#123; let prefix = &quot;@&quot;; let reg = /(@import[^\\n]*)/g; let importCss = source.match(reg).join(&quot;\\n&quot;); let newSource = source.replace(reg, &quot;&quot;); let content = `$&#123;importCss&#125;`; Object.keys(theme).forEach(item =&gt; &#123; let allVar = Object.entries(theme[item]) .map(item =&gt; &#123; return prefix + item[0] + &quot;:&quot; + item[1]; &#125;) .join(&quot;;&quot;) + &quot;;&quot;; let cssFn = ` .$&#123;item&#125;()&#123; $&#123;allVar&#125; $&#123;newSource&#125; &#125; `; content += ` $&#123;cssFn&#125; body[data-theme=&quot;$&#123;item&#125;&quot;]&#123; .$&#123;item&#125;(); &#125; `; &#125;); return content;&#125;module.exports = function(content) &#123; if (this.query.isAdd) &#123; return replace.call(this, content); &#125; else &#123; return content; &#125;&#125;; 当内部有异步处理时可以使用 this.async(),会返回一个 callback 函数，调用它，代表当前 loader 已经处理完，到下一个或结束。 1234567891011121314import path from &apos;path&apos;;export default function(source) &#123; var callback = this.async(); var headerPath = path.resolve(&apos;header.js&apos;); this.addDependency(headerPath); fs.readFile(headerPath, &apos;utf-8&apos;, function(err, header) &#123; if(err) return callback(err); //这里的 callback 相当于异步版的 return callback(null, header + &quot;\\n&quot; + source); &#125;);&#125;; async 返回的 callback 入参: 1234567891011this.callback( err: Error | null, content: string | Buffer, sourceMap?: SourceMap, meta?: any);第一个参数必须为Error或null第二个参数是string或Buffer,既处理后的内容。可选：第三个参数必须是可由此模块解析的源映射。可选：webpack忽略的第四个选项可以是任何内容（例如某些元数据）。 例子项目地址","tags":[{"name":"webpack","slug":"webpack","permalink":"https://793338023.github.io/tags/webpack/"}]},{"title":"create-react-app无法在IE下运行","date":"2019-09-14T12:49:26.000Z","path":"2019/09/14/create-react-app无法在IE下运行/","text":"由于 ie 浏览器需要兼容的需求在现在已经越来越少了，所以 react 脚手架对这部分不进行兼容了，但我们可以安装 polyfill 解决。 而目前解决方法就是安装 create-react-app，然后使用。 1npm install react-app-polyfill 然后src/index.js里添加 123// 注意一定要在最顶部添加，否则无效import &apos;react-app-polyfill/ie11&apos;;import &apos;react-app-polyfill/stable&apos;; 再然后修改 package.json 里面的 browserslist 就可以了 1234567891011121314&quot;browserslist&quot;: &#123; &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;not dead&quot;, &quot;not op_mini all&quot;, &quot;ie 11&quot; ], &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safari version&quot;, &quot;ie 11&quot; ] &#125;, 这个需要在ie 11一定要添加，并且建议加到数组的最后。 还有就是最好把 nodemodules 里的所有包都重新安装一次，因为可能我们的配置并没有生效，这是因为 babel-loader 没有检测到 package.json 中的改变，一个最简单的解决方式就是直接删除掉 node_modules/.cache 文件夹，重新编译。 这样我们就可以兼容 ie11 的版本了。 当然，如果 ie11 还报错,可以试一下把babel-polyfill也安装上。 1npm i babel-polyfill -S 然后在 webpack 的配置文件的 entry 里添加&quot;babel-polyfill&quot;。 1234entry:[ &quot;babel-polyfill&quot;, &quot;src/index.js&quot;]","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"react与typescript","date":"2019-08-28T15:15:52.000Z","path":"2019/08/28/react与typescript/","text":"前言TypeScript 是 JS 类型的超集，并支持了泛型、类型、命名空间、枚举等特性，弥补了 JS 在大型应用开发中的不足。使用 TypeScript 的编程体验最直观的是当在键盘上敲下 . 时，后面这一大串的提示真的是很方便，代码质量和效率提升十分明显，习惯后真的会使用不惯 JavaScript。但是 TypeScript 和一些框架结合使用的话坑还是比较多的，例如使用 antd 框架的时候需要去查看框架提供的 .d.ts 的声明文件中一些复杂类型的定义，或者一些没有使用 TypeScript 插件结合起来使用会出现障碍等等。 React在使用 React 时需要把 React 的 TypeScript 模块的声明包安装一下，否则会在使用 React 时无法找到某些模块而报错。 1npm i @types/react @types/react-dom -S 使用 class 类名开发组件如: 12345678910111213141516171819import * as React from &apos;react&apos;interface IProps &#123; color: string, size?: string,&#125;interface IState &#123; count: number,&#125;class App extends React.Component&lt;IProps, IState&gt; &#123; public state = &#123; count: 1, &#125; public render () &#123; return ( &lt;div&gt;Hello world&lt;/div&gt; ) &#125;&#125; TypeScript 可以对 JSX 进行解析，充分利用其本身的静态检查功能，使用泛型进行 Props、 State 的类型定义。定义后在使用 this.state 和 this.props 时可以在编辑器中获得更好的智能提示，并且会对类型进行检查。Component 的泛型如下: 123456789class Component&lt;P, S&gt; &#123; readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;; state: Readonly&lt;S&gt;;&#125;// 只列举了props与state的定义// Component 这个泛型类， P 代表 Props 的类型， S 代表 State 的类型。 Readonly 泛型把传入的值变为只读，如以上 props 定义的类型都变为只读。Readonly 实现源码 node_modules/typescript/lib/lib.es5.d.ts ，是 typescript 自带的。 由于 props 属性被设置为只读，所以通过 this.props.size = ‘sm’ 进行更新时候 TS 检查器会进行错误提示 1Error:(23, 16) TS2540: Cannot assign to &apos;size&apos; because it is a constant or a read-only property state 也一样为只读，而 React 的 state 更新需要使用 setState 方法，直接修改 state TS 检查器会进行错误提示。 使用 Function 开发组件在 React 的声明文件中 已经定义了一个 SFC 类型，使用这个类型可以避免我们重复定义 children、 propTypes、 contextTypes、 defaultProps、displayName 的类型。 使用 SFC 进行无状态组件开发。 1234567891011121314import &#123; SFC &#125; from &apos;react&apos;import &#123; MouseEvent &#125; from &apos;react&apos;import * as React from &apos;react&apos;interface IProps &#123; onClick (event: MouseEvent&lt;HTMLDivElement&gt;): void,&#125;const Button: SFC&lt;IProps&gt; = (&#123;onClick, children&#125;) =&gt; &#123; return ( &lt;div onClick=&#123;onClick&#125;&gt; &#123; children &#125; &lt;/div&gt; )&#125;export default Button; 事件处理我们在进行事件注册时经常会在事件处理函数中使用 event 事件对象，比如 input 输入后需要获取它的 value 值，那么就要使用event.target.value,但没有定义 ts 就无法通过 ts 检查，而定义 any 会失去静态检查的意义，还有一个问题就是对 event 定义 any，那么获取 event.target 下的属性也会报错，因为 any 只对 event 的属性定义的，而自已通过 interface 对 event 对象进行类型声明编写的话又十分浪费时间，幸运的是 React 的声明文件提供了 Event 对象的类型声明。 如: 123456789101112class App extends React.Component &#123; change = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123; console.log(event.target.value); &#125;; public render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.change&#125; /&gt; &lt;/div&gt; ); &#125;&#125; Event 事件对象类型常用 Event 事件对象类型： ClipboardEvent 剪贴板事件对象 DragEvent 拖拽事件对象 ChangeEvent Change 事件对象 KeyboardEvent 键盘事件对象 MouseEvent 鼠标事件对象 TouchEvent 触摸事件对象 WheelEvent 滚轮事件对象 AnimationEvent 动画事件对象 TransitionEvent 过渡事件对象 实现源码的 node_modules/@types/react/index.d.ts 事件处理函数类型当我们定义事件处理函数时有没有更方便定义其函数类型的方式呢？答案是使用 React 声明文件所提供的 EventHandler 类型别名，通过不同事件的 EventHandler 的类型别名来定义事件处理函数的类型。 EventHandler 类型实现源码 node_modules/@types/react/index.d.ts 。 123456789101112131415type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; = &#123; bivarianceHack(event: E): void &#125;[&quot;bivarianceHack&quot;];type ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;type ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;type DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;;type FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;;type FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;;type ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;type KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;type MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;;type TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;;type PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;;type UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;;type WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;;type AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;type TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;; EventHandler 接收 E ，其代表事件处理函数中 event 对象的类型。bivarianceHack 为事件处理函数的类型定义，函数接收一个 event 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。 1234567891011121314151617interface IProps &#123; onClick: React.MouseEventHandler&lt;HTMLInputElement&gt;;&#125;class App extends React.Component&lt;IProps, &#123;&#125;&gt; &#123; public render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;input type=&quot;text&quot; onClick=&#123;this.props.onClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125; Promise 类型在做异步操作时我们经常使用 async 函数，函数调用时会 return 一个 Promise 对象，可以使用 then 方法添加回调函数。 Promise&lt;T&gt; 是一个泛型类型，T 泛型变量用于确定使用 then 方法时接收的第一个回调函数的参数类型。 12345678910111213141516interface IResponse&lt;T&gt; &#123; message: string, result: T, success: boolean,&#125;async function getResponse (): Promise&lt;IResponse&lt;number[]&gt;&gt; &#123; return &#123; message: &apos;获取成功&apos;, result: [1, 2, 3], success: true, &#125;&#125;getResponse() .then(response =&gt; &#123; console.log(response.result) &#125;) 我们首先声明 IResponse 的泛型接口用于定义 response 的类型，通过 T 泛型变量来确定 result 的类型。 然后声明了一个 异步函数 getResponse 并且将函数返回值的类型定义为 Promise&lt;IResponse&lt;number[]&gt;&gt; 。 最后调用 getResponse 方法会返回一个 promise 类型，通过 then 调用，此时 then 方法接收的第一个回调函数的参数 response 的类型为，{ message: string, result: number[], success: boolean}。 Promise 实现源码 node_modules/typescript/lib/lib.es5.d.ts。 工具与泛型的使用技巧ts 提供的一些实用的泛型。实现源码 node_modules/typescript/lib/lib.es5.d.ts typeof一般我们都是先定义类型，再去赋值使用，但是使用 typeof 我们可以把使用顺序倒过来。 123456const options = &#123; result: &#123; abc:&quot;xxx&quot; &#125;&#125;type Options = typeof options 使用字面量类型限制值为固定的参数如限制 props.pick 的值只可以是字符串 a、b、c ，不一定是字符串，当然也可以是数字 number。 123interface IProps &#123; pick: &apos;a&apos; | &apos;b&apos; | &apos;c&apos;,&#125; 使用 Partial 将所有的 props 属性都变为可选值123456789101112131415interface IProps &#123; pick: string; mouu: string; abc: number;&#125;let p:Partial&lt;IProps&gt;;等价于==&gt;interface IProps &#123; pick?: string; mouu?: string; abc?: number;&#125;let p:IProps; 源码: 123type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;上面代码的意思是 keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P , 最后 T[P] 取得相应属性的值，中间的 ? 用来进行设置为可选值。 使用 Required 将所有 props 属性都设为必填项效果与 Partial 相反源码 123type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;-? 的功能就是把可选属性的 ? 去掉使该属性变成必选项，对应的还有 +? ，作用与 -? 相反，是把属性变为可选项。 条件类型条件类型可以根据其他类型的特性做出类型的判断。 1T extends U ? X : Y 如传入 T 与 U，当 T 中的内容在 U 中，那么就 true，返回 X，否则返回 U。 如: 12345678910// 之前条件的判断方法interface Id &#123; id: number&#125;interface Name &#123; name: string &#125;declare function createLabel(id: number): Id;declare function createLabel(name: string): Name;declare function createLabel(name: string | number): Id | Name;// 使用条件类型type IdOrName&lt;T extends number | string&gt; = T extends number ? Id : Name;declare function createLabel&lt;T extends number | string&gt;(idOrName: T): T extends number ? Id : Name; 它是包含关系，如果包含怎么处理，不包含怎么处理，一般如下使用 123456789type aa = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;;type bb = &quot;a&quot; | &quot;c&quot; | &quot;f&quot;;type Inter&lt;T,U&gt; = T extends U ? T : never;let ceshi:Inter&lt;bb,aa&gt;;等价于===let ceshi:&quot;b&quot; | &quot;d&quot;; Exclude&lt;T,U&gt;从 T 中排除那些可以赋值给 U 的类型。 1type T = Exclude&lt;1|2|3|4|5, 3|4&gt; // T = 1|2|5 Extract&lt;T,U&gt;从 T 中提取那些可以赋值给 U 的类型。 1type T = Extract&lt;1|2|3|4|5, 3|4&gt; // T = 3|4 Pick&lt;T,K&gt;从 T 中取出一系列 K 的属性。 123456789interface Person &#123; name: string; age: number; sex: string;&#125;let person: Pick&lt;Person, &apos;name&apos; | &apos;age&apos;&gt; = &#123; // &#123;name: string;age: number;&#125; name: &apos;小王&apos;, age: 21,&#125; Record&lt;K,T&gt;将 K 中所有的属性的值转化为 T 类型。 1234let person: Record&lt;&apos;name&apos; | &apos;age&apos;, string&gt; = &#123; // &#123;name: string;age: string;&#125; name: &apos;小王&apos;, age: &apos;12&apos;,&#125; Omit&lt;T,K&gt;从对象 T 中排除 key 是 K 的属性。 1234567891011 interface Person &#123; name: string, age: number, sex: string,&#125;// 排除 name 属性。let person: Omit&lt;Person, &apos;name&apos;&gt; = &#123; age: 1, sex: &apos;男&apos;&#125; NonNullable 排除 T 为 null 、undefined。 1type T = NonNullable&lt;string | string[] | null | undefined&gt;; // string | string[] ReturnType获取函数 T 返回值的类型。 123456type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;// infer R 相当于声明一个变量，接收传入函数的返回值类型。type T1 = ReturnType&lt;() =&gt; string&gt;; // stringtype T2 = ReturnType&lt;(s: string) =&gt; void&gt;; // void ts 官网 高阶组件由于使用了高阶组件是把原来的组件包一层然后返回，但对于使用了 typescript 后传入到组件里的值经过包的那一层是没有组件的传入值的定义的，所以会报错，那么我们就要对其进行处理。这里我们使用泛型：P 表示传递到 HOC 的组件的 props。React.ComponentType 是 React.FunctionComponent | React.ClassComponent的别名，表示传递到 HOC 的组件可以是类组件或者是函数组件。 12345678910111213import * as React from &quot;react&quot;;export const useInfo = &lt;P extends object&gt;( Component: React.ComponentType&lt;P&gt;) =&gt; &#123; // ...TODO const useTest: React.SFC&lt;P &amp; &#123;&#125;&gt; = props =&gt; &#123; // ...TODO return &lt;Component &#123;...props&#125; /&gt;; &#125;; return useTest;&#125;;","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"使用gulp制作组件化工具","date":"2019-07-10T14:22:57.000Z","path":"2019/07/10/使用gulp制作组件化工具/","text":"前言现在组件化是流行的一种方式，但一般我们都是只是制作适用于当前项目的组件，如使用 react、vue、angular 等前端架构项目，然后把当前复用性比较高的功能抽取出来封装成组件，然后组件有可能是可以使用到另外一个类似项目中去，但目前我们抽取的组件只是限制于在当前项目中，别的项目是没有办法引用这个组件的，那么另外的项目就要重新开发这部分的组件，那么就会做了重复工作了，而且以后同步更新也要修改两套代码，而这时把组件打包放到 npm 上就是可以解决这个重复工作，因为组件的维护都在组件化的项目包里，项目只要使用就行了。 webpack、rollup 与 gulp 选择webpackWebPack 是一种模块化的解决方案。Webpack 的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为浏览器可识别的 JavaScript 文件，但没有抽离公共 js 的情况下都打包到一个 js 文件，但为了更加完美兼容，打包文件里添加了很多代码使文件的可读性很差。 webpack 兼容性等完善，在应用上开发很适合。 rolluprollup 的功能与 webpack 类似，rollup 相对 webpack 而言，要小巧、代码干净利落一些，但不具备 webpack 的一些强大的功能，如热更新，代码分割，公共依赖提取等。而 vue、react 等使用它进行打包，但它的插件、loader 之类比较少，使用的人也比较少，遇到问题难以从网上寻到答案。 在熟悉它的情况开发类库是不错的选择。 gulpGulp 侧重于前端开发的整个过程的控制管理（像是流水线），除非使用插件实现合并操作，而我们可以通过给 gulp 配置不同的 task（通过 Gulp 中的 gulp.task()方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程，而 gulp 的 API 简单且少，学习成本很低，基本可以说会使用 node 就可以了。 而 gulp 不会根据文件的引入别的文件而把引入文件也打包了，它只会根据当前文件打包，而代码合并之类的都需要自己实现 task 来实现。所以在打包多文件时会简单很多且自由度高，因为 gulp 以文件流的形式输入输出，可以对此进行一些操作来实现添加一些逻辑达到某些需要的目标，而 webpack 在这方面就复杂很多，需要自己实现插件来完成某些特殊要求。 选择目前标准: 打包出干净的代码，可读性号 根据组件打包出多个组件文件夹与多个组件文件，包含 ts 文件 可以被 babel-plugin-import 或 ts-import-plugin 实现组件的按需引入 样式文件抽离 打包后的为 es 与 lib 模块 第三方包排除打包 实现起来简单且符合以上条件，webpack 不符合，rollup 勉强符合，但实现多文件与排除第三方等需要多次执行 rollup 配置，遍历的执行，重复执行很多没有必要的重复内容等等，gulp 对多文件打包友好，且可操作流程内容。 gulp 适合，当然也可以别的,如 typescript 或 babel 的命令行工具之类的，但这样如果需要操作文件里的一些信息还要自己写 node 实现一些额外的功能，如遍历目录、过滤、写入某些内容之类等等。 如 babel: 123npm install --save-dev @babel/core @babel/cli// 编译整个 src 目录下的文件并输出到 lib 目录npx babel src --out-dir lib babel 命令行工具资料以下的以 gulp 为准。 gulp 实现打包目录1234567891011121314151617181920212223242526272829|-- gulp打包文件目录 |-- package.json |-- bin // 安装后可执行的命令文件夹 | |-- rzzc-tool-run.js | |-- rzzc-tool.js |-- demo // 例子文件夹 | |-- components | |-- index.tsx | |-- an-test | | |-- index.tsx | | |-- style | | |-- index.scss | | |-- index.tsx | |-- style | | |-- index.scss | | |-- index.tsx | |-- t-ainamte | |-- index.tsx | |-- tAnimateUtil.tsx | |-- img | | |-- 123.jpg | |-- style | |-- index.scss | |-- index.tsx |-- gulpConfig // gulp 配置文件夹 |-- babel.js |-- gulpfile.js |-- postcssConfig.js |-- utils.js 使用到的插件123456789101112131415161718192021222324252627282930313233gulp// typescript转换es6gulp-typescripttypescript// es6 转换成符合浏览器执行版本的js，如es5gulp-babel@babel/core@babel/plugin-proposal-class-properties // class类属性转换@babel/plugin-proposal-decorators // 装饰器转换@babel/plugin-transform-runtime@babel/preset-env@babel/preset-react // react转换// sass转换cssgulp-sassnode-sass// css3兼容性处理gulp-postcssrucksack-cssautoprefixer// react与react-dom的typescript类型@types/react@types/react-dom// 其他merge2 // 合并gulp任务，按顺序执行rimraf // 删除文件或文件夹through2 // 流输出的封装处理colorful // 颜色commander // 自定义指令 gulp 配置文件目录分析 babel.js 相当于 .babelrc 文件 postcssConfig.js css 的转换处理文件 utils.js 工具文件，如获取执行路径之类 gulpfile.js gulp 的配置文件 require.resolve 输入的 path 会以 node_modules 里为起点查询，然后输出绝对路径，不存在会报错。 process.cwd() 当前执行 node 的路径 through2 函数接受的三个参数 file-文件流, encoding-字符编码, next-触发执行下一步流程文件内容在 file.content 里，对 file.content 转换字符编码就可以正常操作，如 file.content.toString(encoding)操作完后使用 Buffer.from 转换为二进制内容，既文件流格式 按需加载与组件文件夹typescript 按需加载: ts-import-pluginbabel 按需加载: babel-plugin-import由于使用的是 antd 的配套按需加载插件，那么一般按一定的目录结构开发才能很好的便利使用。 12345an-test |-- index.tsx // 组件入口 |-- style // 组件样式文件夹 |-- index.scss// 组件样式 |-- index.tsx // 按需加载时加载的样式文件引用 以上的结构是最好兼容开发的，但也可以自定义,只是只能自定义 css。 自定义按需加载: 12345678910&#123; libraryName: &apos;antd&apos;, libraryDirectory: &apos;es&apos;, style: importPath=&gt;&#123; return importPath+&quot;/style.css&quot; &#125;&#125;importPath 组件问价夹路径拼接上组件css路径 配置打包目录与清除目录在 package.json 中自定义一个 customParams 字段; 123456789&quot;customParams&quot;: &#123; &quot;scanRoot&quot;: &quot;demo/components&quot;, &quot;typeRoot&quot;: &quot;demo/typings&quot;, &quot;clean&quot;: [ &quot;es&quot;, &quot;lib&quot; ] &#125; 根据 scanRoot 与 typeRoot 把组件打包到 es 与 lib根据 clean 清除目标目录 自定义指令在 package.json 的 bin 里定义自定义指令名称与入口文件 123&quot;bin&quot;: &#123; &quot;rzzc-tool&quot;: &quot;./bin/rzzc-tool.js&quot; &#125; 使用 commander 在代码里执行 node 的命令，如 cli 脚手架之类的指令。 首先定义解析语言 123#!/usr/bin/env node只能文件顶部加才能生效 1234program .version(packageInfo.version) .command(&apos;run [name]&apos;, &apos;run specified task&apos;) .parse(process.argv); 执行子命令，会找到当前文件名加上 run,如 rzzc-tool.js，那么子命令文件就是 rzzc-tool-run.js,然后执行它。[name] 为参数,这里为 gulp 执行任务的名称，可以从 program.args 中获取。加载 gulp 配置文件，然后使用 gulp.task(name)返回值再调用就会执行当前任务。如: 12const c=gulp.task(&apos;clean&apos;);c(); // 就执行清除任务 npm 发布 登陆账号 1npm login # 输入用户名 密码 publish 1npm publish # 需要确保 package.json version 与上一个版本不一样 版本的更加 123456// 小版本更改 如从1.0.1-&gt;1.0.2npm version patch// 中版本更改 如从1.0.1-&gt;1.1.0npm version minor// 大版本更改 如从1.0.1-&gt;2.0.1npm version major 注:可以 npm 下载下来配置环境然后打包，也可以 github 下载下来 webpack 与 gulp 配合打包 12// 安装npm install --save-dev rzzc-tool 具体代码查看 github","tags":[{"name":"gulp","slug":"gulp","permalink":"https://793338023.github.io/tags/gulp/"}]},{"title":"linux001","date":"2019-06-29T07:29:33.000Z","path":"2019/06/29/linux001/","text":"前言linux的软件使用安装VMware,配置虚拟机，加载镜像，使用NAT网络链接，安装VMTOOls，这样就是使用共享文件夹。远程登陆，安装xshell与xftp，xshell操作命令，xftp传输文件，使用sftp。sshd:守护进程，端口号为22一般ftp与远程登陆xshell都使用sshd的端口号22如果出现登陆不了远程的linux，可以查看一下sshd是否开启，命令setup，网络服务查看ip地址ifconfig vi与vim所有的linux系统都会内建vi文本编辑器。vim具有程序编辑能力，是vi的增强版，对程序编辑友好，可以代码补全等功能。 三个模式:1) 正常模式以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』 按键来移动光标，你可以使用『删除字符』 或『删除整行』 来处理档案内容，也可以使用『复制、贴上』 来处理你的文件数据。 2) 插入模式按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可。 3) 命令行模式在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！ 使用vim进入一般为正常模式，然后按下i等进入插入模式，退出插入模式就是命令行模式。 常用操作:1)vim 进入或创建文件，按下i进入编辑模式，编辑完，按ESC退出编辑模式，按下:wq保存修改，:q 在没有修改情况退出正常模式，:q! 强制退出。2) 正常模式,拷贝当前行 yy , 拷贝当前行向下的5行 5yy，并粘贴 p。3) 正常模式,删除当前行 dd , 删除当前行向下的5行 5dd4) 正常模式,在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]5) 正常模式,设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]6) 正常模式,使用快捷键到底文档的最末行[G]和最首行[gg]7) 插入模式，在一个文件中输入 “hello” ,然后正常模式撤销这个动作 u8) 正常模式,并将光标移动到 20行 shift+g","tags":[{"name":"linux","slug":"linux","permalink":"https://793338023.github.io/tags/linux/"}]},{"title":"IOS对FormData、File兼容性","date":"2019-06-05T15:09:32.000Z","path":"2019/06/05/IOS对FormData、File兼容性/","text":"前言IOS对FormData、File兼容性都不是很好，比如IOS8、9就不支持，但按市场的占比来说，可以忽略这部分，但能处理还是要处理的。 FormDataFormData主要是模拟表单数据，以便用XMLHttpRequest来发送数据，而FormData下有几个方法调用，如添加数据，设置数据，获取数据等，但它们有很一部分在IOS上是不兼容的，而append()这个方法一定是兼容的，其他API如果要使用就要留意他们的兼容性，如has、get都是不兼容的。 FormData添加进入的值不是blob、File，就会转换为String类型。 append第三个参数为文件名,不送第三个参数即为默认blob。 1234var content = &apos;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&apos;; // 新文件的正文...var blob = new Blob([content], &#123; type: &quot;text/xml&quot;&#125;);formData.append(&quot;webmasterfile&quot;, blob); FileIOS8、9度无法兼容File,虽然这个版本的IOS用户已经很少了，但能兼容还是兼容一下。 一个Blob对象表示一个不可变的, 原始数据的类似文件对象。File接口基于Blob，继承 blob功能并将其扩展为支持用户系统上的文件。所以我们可以使用Blob替代File对象，只要在lastModifiedDate与name就和File对象差不多了，而且可以使用FileReader读取数据，因此在某些场景下是可以替换的。而且上传到后台的时Blob与File是一样的，因为File继承于Blob。 123456function blobToFile(blob, fileName)&#123; blob.lastModifiedDate =new Date(); blob.name = fileName; return blob; &#125;","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"移动端调试","date":"2019-06-01T03:28:05.000Z","path":"2019/06/01/移动端调试/","text":"前言大前端时代，移动互联网是大趋势，而偏向移动开发，但前端开发的功能在移动上调试是比较困难的，因为无法像 PC 浏览器那样有各种各样的内置调试工具，而出现问题时只从页面上效果判断具体问题，这是不太可能的，如样式，在 IOS 和安卓上展示的效果不一致，而在开发浏览器上一点问题都没有，这就只能猜测和不断尝试，但如果对需要部署的环境且频繁拜托别人部署是很浪费时间，效率也低下，还要看别人是否愿意陪你折腾，因为你也在浪费他的时间，因此能自己一个人解决就绝对不要浪费别人的时间，而对移动开发的调试，我一般都是 vConsole、weinre、fiddler。 vConsole主要使用在需要打印 console 的内容而能像 pc 浏览器一样有控制台，当然它也有其他的功能，但对我而言 Log 是最重要的。 12345npm install vconsoleimport VConsole from &apos;vconsole/dist/vconsole.min.js&apos; //import vconsolelet vConsole = new VConsole() // 初始化console.log(&apos;test.....&apos;); vConsole vConsole weinreweinre 是一款还不错的远程调试工具。功能与网页浏览器的开发者工具基本类似，适合用于移动端 web 的调试，但可能会用起来不顺手，因为它只是实现了浏览器调式的一部分功能，而且它的调式界面有点简陋，功能运用上没有浏览器调试那么便捷，但它比 VConsole 功能强大一些，也包含了它的功能。而它最好的地方在于可以在 Elements 对样式的修改可以动态的修改到远端的样式，这就和在浏览器上调式样式一样，很不错的功能。 123456npm -g install weinreweinre --httpPort 8081 --boundHost -all-主要参数解析：httpPort 调试服务器运行的端口，默认8080boundHost 调试服务器绑定的IP地址或域名，默认localhost 运行后打开 localhost:8081 调式界面 weinre Elements 的 tab 页里可以对元素进行样式调整，而选中样式也会在移动出现被选中的效果，如果没有重新刷新一下，因为它实现与远端同步是使用轮询方式实现的，如果请求有问题了，只能重新来，就是刷新，这一点我觉得体验效果很差。 weinre fiddlerFiddler 是强大的抓包工具，它的原理是以 web 代理服务器的形式进行工作的。而且 Fiddler 的用途很广，但这里就介绍一下怎么进行移动端的调式。Fiddler 它的简单原理就是拦截请求，伪造请求返回给客户端。 远程抓取手机数据配置 配置 fiddler 允许监听到 https（fiddler 默认只抓取 http 格式的）打开 Fiddler 菜单项 Tools-&gt;Options-&gt;HTTPS勾选 CaptureHTTPS CONNECTs,勾选 Decrypt HTTPS traffic 和 Ignore servercertificate errors 两项,点击 OK（首次点击会弹出是否信任 fiddler 证书和安全提示，直接点击 yes 就行） fiddler 配置 fiddler 允许远程连接 Tools-&gt;Options-&gt;Connections，勾选 allow remote computers to connect，默认监听端口为 8888（下图 Fiddler listens on port 就是端口号），若端口被占用可以设置成其他的，配置好后要重新启动 fiddler fiddler 对手机端进行参数配置 首先要保证手机和电脑都处于同一个 WIFI 网络； 然后要知道电脑的 ip 地址（当然这个电脑是安装 fiddler 的电脑），电脑 ip 地址可通过 cmd，输入 ipconfig 查询，或网络共享中 ipv4 找到，我的是 192.168.0.103。 再者要知道 fiddler 的端口号，Tools-&gt;Options-&gt;Connections，port 中值就是端口号，一般默认为 8888；接下来开始操作手机； 手机打开浏览器输入 http://ip:端口号，如http://192.168.0.103:8888，会打开https证书下载地址，点击FiddlerRootcertificate下载证书。 fiddler 找到手机上证书安装设置，记住证书下载地址，然后在证书安装设置找到证书安装,由于手机不一样，证书安装设置也不一样，需要自己百度自己的手机证书怎么安装。具体参考 更改手机无线网的代理在手机的 WiFi 那里的高级设置，代理选择手动，主机名就是 fiddler 的电脑 ip 地址，端口号，就是 fiddler 的端口号，与浏览器中 ip：端口号保持一致，点击确定即可。 这个无线代理设置也是手机不一样设置也有些不一样，需要自己百度查看自己的手机类型怎么设置。 具体参考 fiddler 使用目前经常使用的 Inspectors 与 AutoResponse。 Inspectors 可以查看到请求中所有报文数据，如 header，报文体，返回数据，而且可以查看不同数据类型的数据，如 json，图片等 AutoResponse 可以拦截转发预期的请求然后返回客户端，这是一个很强大的功能。要勾选上 Enable rules 与 Unmatched requests passthrough fiddler 这样我们可以把请求转发到本地的某个文件，然后实现类似如 mock 数据那样，但不对代码进行调正，只是把请求转发，而我们就可以修改本地的数据，实现到请求数据为我们修改的预期数据，如样式修改，我们把样式文件的请求转发的本地目标样式文件，然后修改本地样式文件就可以刷新查看到重新请求的样式可进行了调整。 如果拦截不生效，是缓存问题或者配置问题，所以要注意。 正则匹配可以使用$1\\$2…等选中匹配中的第几个子串，这和正则一样。 fiddler 资料:Fiddler AutoResponseAutoResponder 正则匹配fiddler 正则匹配 2","tags":[{"name":"调试","slug":"调试","permalink":"https://793338023.github.io/tags/调试/"}]},{"title":"认识TCP","date":"2019-05-14T14:27:39.000Z","path":"2019/05/14/认识TCP/","text":"前言使用过 webSocket 的，应该都知道它是使用 TCP 来实现客户端与服务端双工通道，而且连接方式是 ip+端开口号，这为端到端的模式，而由于它的确认方式与断开方式多次确认避免了错误重发导致的错误连接之类的且各种方式保证了它的可靠的交付能力，而 UDP 在这方面就差了些，是不可靠的交付，它只负责发送，不负责确认，所以省去了很多的确认开销，可以很大的提高传送的速度，提高性能，对要求高性能的服务，一般都会使用到 UDP，所以两者有得有失，看需求的倾向。 三次握手 三次握手 第一次握手，建立连接，客户端会把 SYN 发给服务器，进入 SYN_SEND 状态，等待服务器确认，第二次握手，会确认 SYN 包信息，然后在接受信息上添加 SYN+ACK 报文段，发送给客户端，进入 SYN_RECV 状态，第三次握手，客户端接受到报文后向服务器发送 ACK 包，客户端和服务器端都进入 ESTABLISHED 状态。 TCP 进入三次握手是因为预防客户端与服务器端出现丢失包而双方的一方不知道而以为可以正常进入连接状态，这样会会出现 BUG 问题，就好比收快递，如果快递员只送到目的地而不告知或确认是否收到，那么快递丢失，收件员就无法收到快递而损失或不知道快递在哪，这个很不可靠的，而三次握手就会保证连接无误，因为第一次为请求连接，而服务器回应为确认连接，再到客户端的答复为已经收到确认连接，这样是不是就能明确三次握手的必要性。 四次挥手 四次挥手 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。3）客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。6）服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。 四次挥手是因为客户端的关闭与服务器端关闭都要关闭，每个都有一个请求一个回应，所以就四次。在服务器关闭时客户端的 TINE_WAIT 是为了确认服务器端是否接受客户端的应答，如若收到，那么服务器端就不会再发送关闭请求，那么客户端在 2MSL时间后就自动认为服务器端关闭了，结束本次的 TCP 连接，如若收到再次请求关闭，那么就是重置时间再等待 2MSL 时间。 MSL 指一个片段在网络中最大的存活时间 TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 可靠交付的手段TCP 是一种提供可靠性交付的协议。也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。 超时重传TCP 报文段在传输的过程中，下面的情况都是有可能发生的： 数据包中途丢失；数据包顺利到达，但对方发送的 ACK 报文中途丢失；数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃； 当出现这些异常情况时，TCP 就会超时重传。TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。 滑动窗口滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗口分为「接收窗口」和「发送窗口」因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。 滑动窗口就是在存储有序的内容，当当前的某段内容都确认后就滑动到确认区域内，而某段内容之前有丢失的，那么后面的只能等待丢失的确认后才能有序滑到确认区域。","tags":[{"name":"tcp","slug":"tcp","permalink":"https://793338023.github.io/tags/tcp/"}]},{"title":"前端安全问题","date":"2019-05-02T14:25:13.000Z","path":"2019/05/02/前端安全问题/","text":"前言随着前端的发展，现在应用越来越庞大，而大前端的时代，也让前端独立起来，复杂起来，重要起来，而前端信息被盗用，很容易就出现严重的情况，比如信息泄露，资金损失等等，所以前端安全也是必不可少的。 xssxss跨站脚本攻击，是目前也是一直最流行的攻击方式，而它主要对html或js注入恶意代码，被执行后向目标服务器发送内容或篡改内容，以达到攻击的效果。 xss攻击又分三种，DOM xss、反射型XSS、存储型XSS。而他们的最终目的都是向html或js注入代码，所以只要防御好注入代码不被执行即可。 防御: 前端在解析html时对外部来源的代码进行HtmlEncode既实体字符转换，对js进行JavaScriptEncode既特殊字符进行16进制转换，以达到外部来源的代码不能以代码自执行的方式被使用。 前后端通讯时后台也要对数据的特殊字符进行处理，以免回传到前端时被自动使用执行而入侵。 cookie信息安全，由于cookie在前端很容易被获取，而权限泄露，所以对cookie设置HttpOnly属性，让前端无法获取到cookie，从而无法泄露出去。 iframeiframe框架，一般都是为了让第三方的页面功能可以正常的嵌套在自己项目的页面里，以达到添加的功能，典型的例子是使用iframe在页面上添加第三方提供的广告、天气预报、社交分享插件等等。 防御:html5对iframe提供了sandbox的安全属性，实现“最小权限“原则，这样就可以最大限制各方面的问题。 1&lt;iframe sandbox src=&quot;...&quot;&gt; ... &lt;/iframe&gt; sandbox CSRFCSRF跨站点请求伪造,冒充用户进行一些违背用户操作行为的事。可能会造成以下影响： 利用已通过认证的用户权限更新设定信息等； 利用已通过认证的用户权限购买商品； 利用已通过的用户权限在留言板上发表言论。 CSRF就是劫持http上的登陆权限，然后冒充用户进行非法操作。 防御: 验证码:强制用户进行交互行为，以达到在终端使用。 使用post方法传递参数，get方法参数在url上很容易被劫持。 Referer来源限制，这个方法有缺陷，比如Referer丢失之类的，所以有点没有保障，而且也有可能被伪造。 Token这是最优的解决方式，现在比较流行JWT。 点击劫持利用透明的按钮或连接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个连接访问内容的一种攻击手段。也叫界面伪装。就是把目标页面放到iframe里，然后顶层为透明层，诱惑用户点击，触发透明层。 防御:X-FRAME-OPTIONS；X-FRAME-OPTIONS HTTP 响应头是用来给浏览器指示允许一个页面可否在\\&lt;frame>, \\&lt;iframe> 或者 \\&lt;object> 中展现的标记。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。 错误MIME types被执行有些攻击会用上传文件之类的，然后在后台里储存，当被前端终端读取后，由于终端的智能手段，把把它转换为可执行的类型进行执行，想想就可怕，如某网站允许用户在评论里上传图片，攻击者在上传图片的时候，看似提交的是个图片文件，实则是个含有JavaScript的脚本文件。该文件逃过了文件类型校验（这涉及到了恶意文件上传这个常见安全问题，但是由于和前端相关度不高因此暂不详细介绍），在服务器里存储了下来。接下来，受害者在访问这段评论的时候，浏览器会去请求这个伪装成图片的JavaScript脚本，而此时如果浏览器错误的推断了这个响应的内容类型（MIME types），那么就会把这个图片文件当做JavaScript脚本执行，于是攻击也就成功了。 防御:通过设置X-Content-Type-Options这个HTTP Header明确禁止浏览器去推断响应类型。 不安全的第三方依赖包现如今进行应用开发，就好比站在巨人的肩膀上写代码。据统计，一个应用有将近80%的代码其实是来自于第三方组件、依赖的类库等，而应用自身的代码其实只占了20%左右。无论是后端服务器应用还是前端应用开发，绝大多数时候我们都是在借助开发框架和各种类库进行快速开发。 比如vue的生态包就出现过被黑的情况，安装包时 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。 而依赖使用这些流行框架影响会很大。 防御:只能实时留意网上信息的动态，与使用安全工具对其进行扫描，以防万一，因为三方库都是很多人使用的，有问题会第一时间提出并修改。 HTTPS被拦截降级为HTTPHTTPS是在HTTP上加TLS安全传输层，TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL，它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。但有TLS还是可能被攻击的，黑客可以利用SSL Stripping这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。 问题的本质在于浏览器发出去第一次请求就被攻击者拦截了下来并做了修改，根本不给浏览器和服务器进行HTTPS通信的机会。大致过程如下，用户在浏览器里输入URL的时候往往不是从https:\\//开始的，而是直接从域名开始输入，随后浏览器向服务器发起HTTP通信，然而由于攻击者的存在，它把服务器端返回的跳转到HTTPS页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。由于这一切都是暗中进行的，所以使用前端应用的用户对此毫无察觉。 防御:使用HSTS,它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信：1Strict-Transport-Security: max-age=&lt;seconds&gt;; includeSubDomains; preload Strict-Transport-Security 敏感信息、错误信息暴露 由于程序员疏忽直接在页面的js以及AJAX请求返回的内容中输出参与评论用户的敏感信息，导致攻击者可以轻松获取用户的手机号，真实姓名，注册邮箱，住址甚至有可能获取用户手机的IMEI，和抽奖和抽中的游戏礼包号。泄露内容千奇百怪，遇到此类问题时，看着泄露的内容时常会被雷到。而这些敏感信息很容易就会获取到客户信息。 由于后台的疏忽，经常会出现堆栈信息被打印到页面，而这也是很容易很推断某些信息，而进行他想的攻击。 防御: 使用不对称密钥进行加密。 过滤堆栈信息，打印友好话术信息。","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"defineProperty与Proxy","date":"2019-04-30T14:32:47.000Z","path":"2019/04/30/defineProperty与Proxy/","text":"前言自从vue的出现，让很多前端开发对defineProperty这个方法进入了深入的了解，因为它涉及到vue核心实现，视图与数据的双向绑定，然而vue3后又盯上了Proxy，它比defineProperty完美，很适合做双向绑定。 definePropertyECMAS-262第5版在定义只有内部采用的特性时，提供了描述了属性特征的几种属性。ECMAScript对象中目前存在的属性描述符主要有两种，数据描述符(数据属性)和存取描述符(访问器属性)，数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。 defineProperty提供了对数据描述属性进行修改的操作，而这也提供更加灵活操作，与在getter-setter 函数功能进行某些搜集和变化，所以这也让双向绑定变得更加简单可控。 以下为数据双向绑定例子，但没有对视图与数据进行绑定，只是提供了一个思路。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 校验是否是对象function isObject(obj)&#123; return Object.prototype.toString.call(obj) === &apos;[object Object]&apos;;&#125;// 循环递归给每个对象的值设置definePropertyfunction defineReactive(obj, key, val)&#123; if(isObject(val))&#123; observe(val); &#125;else if(Array.isArray(val))&#123; observeArray(val); dealAugment(val); &#125; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; // 处理获取数据 console.log(`获取值:$&#123;val&#125;`); return val; &#125;, set(newVal)&#123; // 处理设置数据 console.log(`设置值:newVal-$&#123;newVal&#125;，oldVal-$&#123;val&#125;`); val = newVal; if(isObject(newVal))&#123; observe(newVal); &#125;else if(Array.isArray(val))&#123; observeArray(val); dealAugment(val); &#125; &#125; &#125;);&#125;// 数组变异方式实现function dealAugment(arr)&#123; // 把数组的所有原型方法赋值给arrysMethod const arrysMethod = Object.create(Array.prototype); // 重构push，就是变异psuh方法，这里可以实现其他的变异，如pop、shift、unshift arrysMethod.push = function(...args)&#123; // 处理push方法数据 console.log(&quot;push:&quot;,args); [].push.apply(arr, args); &#125; // 重新把原型赋值到数组里 if(&quot;__proto__&quot; in Object)&#123; arr.__proto__ = arrysMethod; &#125;else&#123; // 不支持__proto__，变异当前方法 Object.defineProperty(arr, &quot;push&quot;, &#123; value: arrysMethod.push, enumerable: true &#125;) &#125;&#125;// 数组部分遍历递归检测对象与数组，实现defineProperty与数组变异function observeArray(arr)&#123; arr.forEach((item)=&gt;&#123; if(isObject(item))&#123; observe(item); &#125;else if(Array.isArray(item))&#123; observeArray(item); dealAugment(item); &#125; &#125;);&#125;// 遍历对象，对象值设置definePropertyfunction observe(obj)&#123; Object.keys(obj).forEach((key)=&gt;&#123; defineReactive(obj, key, obj[key]); &#125;);&#125;// 测试部分setTimeout(()=&gt;&#123; let obj = &#123; a: &quot;1&quot;, b: &#123; c: &quot;xxx&quot; &#125;, c: [12,1], d: [[1212],[&quot;ccc&quot;],&quot;vvv&quot;,&#123;e:&quot;222&quot;&#125;] &#125;; window.obj = obj; observe(obj); console.log(obj.a); obj.a = &#123;v:1&#125;; obj.b.c = &quot;wqss&quot;; obj.c.push(10); obj.c.push([1000]); obj.d[0].push(&quot;vvv&quot;); obj.d[3].e = &quot;xcsss&quot;;&#125;,1000); ProxyProxy比defineProperty完善，因为Proxy相当于实现了一个代理，让数据都经过代理里的设置后再输出，所以我们可以再代理里的钩子里拦截下数据，进行操作后进行下一步的数据变化，而且也不需要数组方法变异之类的，因为只要代理的数据有变化，就需要经过代理里的钩子，从而不需要编写一些hack代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const handler = &#123; get(target, prop) &#123; try &#123; // 还有比这更简洁的递归吗 return new Proxy(target[prop], handler); &#125; catch (error) &#123; return target[prop]; // 或者是Reflect.get &#125; &#125;, set(target, prop, newVal) &#123; const oldVal = target[prop]; if (oldVal !== newVal) &#123; console.warn(oldVal, newVal); &#125; target[prop] = newVal; return true; &#125;,&#125;;let obj = &#123; b: true, o: &#123; name: &apos;obj&apos; &#125;, a: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], odeep: &#123; path: &#123; name: &apos;obj deep&apos;, value: [], &#125;, &#125;,&#125;;obj = new Proxy(obj, handler);setTimeout(() =&gt; &#123; // 试试吧，太不可思议了! obj.b = false; obj.o.name = &apos;newObj&apos;; obj.odeep.path.name = &apos;newObj deep&apos;; obj.b = &#123; name: &apos;obj created&apos; &#125;; obj.b.name = &apos;newObj created&apos;; obj.a.push(&apos;d&apos;); obj.odeep.path.value.push(1); obj.b = [&apos;a&apos;]; obj.b.push(&apos;b&apos;); obj.b[0] = &apos;new a&apos;;&#125;, 1000);","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"chrome调试查找问题根源","date":"2019-04-27T14:56:14.000Z","path":"2019/04/27/chrome调试查找问题根源/","text":"前言对于一个开发者来说，开发只是工作里的一个部分，然而修复功能的 bug 才是考验一个开发人员能力的时候，因为写出没有 BUG 的代码是一件很困难的事，不是谁都可以把所有的情况都考虑进去，代码复杂式总会出现一些 BUG 问题，所以才会出现各种各样的日志系统，因为他可以让开发人员从日志内容中找到代码的 BUG 根源，当然也不一定能查到，但这只是调试的一种，而在前端里，日志系统是比较少用的，都是靠浏览器的调试来完成 BUG 查找，而常用的有 console 方式，就是打印内容来定位问题，但这种方式只能应付一般简单的场景，如知道问题在哪，需要进一步核查一下是什么问题之类的，但如果出现 console 量特别大的时候就会出现难以排查。如: 123456for(var i=0;i&lt;10;i++)&#123; conosole.log(&quot;1111&quot;)&#125;for(var j=0;j&lt;10;j++)&#123; conosole.log(&quot;1111&quot;)&#125; cconsole 的地方为循环调用的，而且是交替的，那么就会意义很难懂。 而最好的调式的方式应该是可以查看调用栈，那么就可以追踪问题的行为，而判断 BUG 怎么修复。 调试方式-console在一般知道问题所在的情况下是 console 可以简单的快速定位问题原因，而且 console 量大是可以分组。 1234// 分组方式console.group()console.log(&quot;问题打印&quot;);console.groupEnd(); 调试方式-Sources chrome调试查找问题根源 打开 Sources 可以用来查看页面的源文件，里面包含了 debugger 调式，这是重点。ctrl+p 查找目标文件，当然也可以使用 console 打印后找到目标文件,点击红圈就可以跳转到目标文件。 console 而 debugger 后可以使用-&gt;来一步一步走完所有的调用，这样可以更仔细的查找到问题，当不知道问题具体在哪时。 调用栈 Call Stack 是当前 debugger 过程的调用栈，可以使用它查看到之前的调用过程，从而推断问题，而且点击对应的调用可以跳转到对应的调用方法上，这样就会可以查看当前调用的信息，但旧的浏览器还不可查看那些调用信息，还有 watch 是把某些变量放入，方面之后 debugger 执行查看到当前监控变量的值变化，Scope 当前调用方法的作用域的变量值，BreakPoints 为所拥有的 debugger 数和具体的 debugger，可以在这里删除 debugger，因为有时不知道 debugger 在哪里打，那么在这里移除是最好的，当前还有其他几个，但暂时没有使用到。 调式方式-error当控制台报错时，会有报错信息与调用栈信息，而一般报错信息只能判断是什么原因，不能定位问题所在，而这时不用调用栈时很被动的，因为只有报错信息与简单的文件报错位置，在复杂的场景下是不够定位问题的，而这时调用栈的信息就可以让我们推断出问题所在，因为他与以上的 debugger 的调用栈是一样的，所以可以追踪的到的调用行为，以推断出问题，以想出对应的解决方法。 调用栈 调式方式有很多种，如请求问题，可以查看 network 等等，优化可以 Memory 等，这些都很好，但我觉得调用栈才是定位问题的最佳方式，因为如果你知道问题的行为，那么你就相当如知道具体的问题在哪里出现，就可以直接针对修复，而现在的日志系统也是趋向用户行为分析来定位具体的问题，所以知道行为就是知道具体问题。","tags":[{"name":"调试","slug":"调试","permalink":"https://793338023.github.io/tags/调试/"}]},{"title":"旧博客地址","date":"2019-04-25T15:50:14.000Z","path":"2019/04/25/旧博客地址/","text":"地址由于方便问题，以后的博文都在这里编写，而编写博文是为了记录自己的技术成长与以后忘记有个地方可以查找，好记性不如烂笔头。 以前的博文是在博客园编写的地址为https://www.cnblogs.com/zhangzhicheng","tags":[{"name":"blog","slug":"blog","permalink":"https://793338023.github.io/tags/blog/"}]},{"title":"react的hooks","date":"2019-04-21T05:44:37.000Z","path":"2019/04/21/react的hooks/","text":"前言虽然react一般都是class类的方式编写，但有时为了简单，就使用函数编写，但在以前这是无副作用的函数,所以很多事都无法去做，比如后期为了维护而不得不在函数里使用state等时，这就不会符合无副作用的函数了，所以react会报错，而这是使用hooks就可以拯救啦，当然也有喜欢使用函数式编写的人来说也是福音，因为hooks基本上支持所有react生命周期，state,redux等等，与编写class方式差不多等效了。 State引入react里的useState。useState的参数就像state初始化值。useState返回的值一个数组，数组中第一个参数是以前的state,第二个参数是setState，由于是参数，所以可以自己命名，不用想以前就state,setState这样。 例子如下:1234567891011121314151617181920import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;export const getText = function(props)&#123; const [test, setTest] = useState(&apos;&apos;); function onChange(val)&#123; setTest(val); &#125; return ( &lt;div&gt; &lt;List&gt; &lt;InputItem value=&#123;test&#125; onChange=&#123;onChange&#125;&gt;hooks测试&lt;/InputItem&gt; &lt;/List&gt; &lt;List&gt; &lt;div&gt;&#123;test&#125;&lt;/div&gt; &lt;/List&gt; &lt;/div&gt; );&#125; Effect引入react里的Effect。useEffect增加了从功能组件执行副作用的功能，其实这个钩子就是让函数支持react生命周期。它的目的是作为componentDidMount，componentDidUpdate以及componentWillUnmount，只是都在这个useEffect钩子实现。 useEffect的第二参数为空数组[],效果如componentDidMount: 12345678910111213141516171819import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;export const getText = function(props)&#123; // 调用父级组件函数更新state useEffect(()=&gt;&#123; props.setVal(Math.floor(Math.random()*100)); &#125;,[]); return ( &lt;div&gt; &lt;List&gt; &lt;div&gt;&#123;props.value&#125;&lt;/div&gt; &lt;/List&gt; &lt;/div&gt; );&#125; useEffect的第二参数不传，效果如componentDidUpdate,但初始加载也会触发: 12345678910111213141516171819import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;export const getText = function(props)&#123; // 调用父级组件函数更新state useEffect(()=&gt;&#123; props.setVal(Math.floor(Math.random()*100)); &#125;); return ( &lt;div&gt; &lt;List&gt; &lt;div&gt;&#123;props.value&#125;&lt;/div&gt; &lt;/List&gt; &lt;/div&gt; );&#125; useEffect里函数的返回值，效果如componentWillUnmount,在组件卸载调用: 123456789101112131415161718192021222324import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;export const getText = function(props)&#123; const timer = setInterval(()=&gt;&#123; console.log(+new Date()); &#125;); // 调用父级组件函数更新state useEffect(()=&gt;&#123; props.setVal(Math.floor(Math.random()*100)); return ()=&gt;&#123; clearInterVal(timer); &#125; &#125;); return ( &lt;div&gt; &lt;List&gt; &lt;div&gt;&#123;props.value&#125;&lt;/div&gt; &lt;/List&gt; &lt;/div&gt; );&#125; useEffect的第二参数数组有对应的state或props值，只要当前值更新了才触发: 12345678910111213141516171819import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;export const getText = function(props)&#123; // 调用父级组件函数更新state useEffect(()=&gt;&#123; props.setVal(Math.floor(Math.random()*100)); &#125;,[props.value]); return ( &lt;div&gt; &lt;List&gt; &lt;div&gt;&#123;props.value&#125;&lt;/div&gt; &lt;/List&gt; &lt;/div&gt; );&#125; 自定义钩子就是抽取相同逻辑的部分封装成一个新的钩子，而钩子使用hooks的钩子封装实现，然后返回一个目标内容，如值。 自定义钩子:12345678910import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;export const getHook = function(vId,props)&#123; const [ssId, setSsId] = useState(&apos;&apos;); useEffect(()=&gt;&#123; props.setVal(Math.floor(Math.random()*100)); setSsId(vId); &#125;,[props.value]); return ssId;&#125; 使用自定义钩子:123456789101112131415import React, &#123; Component, useState, useEffect &#125; from &apos;react&apos;;import &#123; InputItem, List &#125; from &apos;antd-mobile&apos;;improt &#123;getHook&#125; from &apos;./hooks&apos;;export const getText = function(props)&#123; const nVal = getHook(&quot;xx&quot;,props); return ( &lt;div&gt; &lt;List&gt; &lt;div&gt;&#123;props.value&#125;&lt;/div&gt; &lt;/List&gt; &lt;/div&gt; );&#125; 使用规则 只能在顶层调用Hooks。不要在循环，条件或嵌套函数中调用Hook。 只能在functional component中使用，所以如果在class使用一定要是组件的形式，而不是函数调用的方式，不是会当成一个在class里使用hooks。 参考react官网有很详细的资料,而且以上的只是当用的，Hooks还提供了别的钩子。react官方Hooks","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"javascript类型与语句","date":"2019-04-13T15:00:32.000Z","path":"2019/04/13/javascript类型与语句/","text":"前言JavaScript 是一门简单易用的语言，应用广泛，同时它的语言机制又十分复杂和微妙，即使经验丰富的开发人员也需要用心学习才能真正掌握。 类型一般描述某某类型，是对变量的值的类型描述，而不是变量，变量是没有类型的 javascript有七种内置类型:1234567空值（null）未定义（undefined）布尔值（boolean）数字（number）字符串（string）对象（object）符号（symbol， ES6 中新增） 使用typeof 就可以查看到，但有意思的null是object,无法一一对应。1234567typeof undefined === &apos;undefined&apos;typeof true === &apos;boolean&apos;typeof 1 === &apos;number&apos;typeof &quot;41&quot; === &apos;string&apos;typeof &#123;&#125; === &apos;object&apos;typeof Symbol() === &apos;symbol&apos;typeof null === &apos;object&apos; 除了object，其他都是基础类型，而使用instanceof对基础类型校验类型，都是object，除非使用String等包装对象，就可以正确的校验出对应的类型，而对象类型都可以instanceof校验，因为它校验的是construct指向类型。 typeof、instanceof、Object.prototype.toString typeof一般使用来检查基本类型，当然也有一些意外，如null为object，这是规范的bug，但牵连过多，所以无法修复，还有function，由于内部的[[call]]原因，当typeof检查时会认为它是可调用对象，所以会返回function字符串，其他的对象统一都返回object，而宿主对象也不一样，但这个很少用，不过有一个很特别就是document.all返回undefined。 对基础类型进行手动的包装对象，typeof只能认为它是对象类型，而且js引擎对这部分优化了，会自动包装，所以最好不要手动包装。1234typeof document.all === &apos;undefined&apos;typeof 宿主对象（由JS环境提供） === Implementation-dependenttypeof null === &apos;object&apos;typeof new String(&quot;xxx&quot;) === &apos;object&apos; instanceofinstanceof是检测对象的原型链上构造器constructor对象是否等于要检查对象。而原型的constructor是很容易被修改的，比如prototype直接赋予对象，那么constructor就等于对象的constructor123function Car()&#123;&#125;Car.prototype = &#123;&#125;// Car的constructor被修改为Object 对象继承了父级对象，那么使用instanceof检查时要检查对象为父级constructor也是为true，因为它会查找原型链上的所有的constructor。123456789function Parent()&#123;&#125;Parent.prototype.get = function()&#123; return &quot;父级&quot;;&#125;function Car()&#123;&#125;Car.prototype = new Parent();Car.prototype.constructor = Car;let car = new Car();console.log(car instanceof Parent); // true Object.prototype.toStringjs的一句很吊的话，“一切皆为对象”，但有时从各种方面又可以体验出这句话的意思，如所有的类型都有一个顶级对象Object，而他们都继承了它的，这方面和java很像，因为java在强类型语言，所以一切变量都要定义好类型，但他们都可以向上转型为Object，他们的顶级类型也为Object。而在一个对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用，就会自动调用toString方法，返回”[object type]”，type是对象的类型，所以可以利用这点对类型进行检查，但要使用到function的call重新定义上下文的this,那么就可以访问到对象里[[class]]属性，从而知道类型，而且这个检查类型的方式是比较全面的，但对自定义的实例化对象是无法检查到的，都统一返回[object Object],所以对这方面使用instanceof检查比较好。 1234let a = &quot;xx&quot;;Object.prototype.toString.call(a) // [object String]Object.prototype.toString.call(null) // [object Null]Object.prototype.toString.call(document.all) // [object HTMLAllCollection] 所以综上所述，Object.prototype.toString对检查类型方面是比较完善正确的，缺点就是在自定义原型的实例化对象上的检查。 语句语句相当于句子，表达式相当于短语，运算符相当于标点符号和连接符。语句都是有结果返回的。如在控制台输入一个语句，可以查看到一个返回结果。 赋值表达式的副作用，就是变量被赋予某个值。123456var b;var a = 10;if(a &amp;&amp; (b = typeof a))&#123;&#125;// b就被赋值，而且也进行了校验 代码块:12[] + &#123;&#125;; // [object object]&#123;&#125; + []; // 0 第一行[]强制转换为””, “”+{}，被认为{}空对象第二行{}被当作空的代码块，而代码块不需要分号，+[]被强制转换为数字0，如+”” === 0 主要看运算符在谁前面 12var a = false,b = true, c = false, d = true, e = false, w = false, q = false, x = true, z = true;a || b &amp;&amp; c?d:e &amp;&amp; w? q: x||z &amp;&amp; 优先于 || 优先于 ?: 优先级,=优先于”,”,用()包着可以先优先执行12var a = 10;var c = (++a,a) 无论情况finally都会执行，除了finally报错，那么try的值就不会给返回。12345try&#123; return 10;&#125;finally&#123; console.log(&quot;finally&quot;);&#125; switch case比较的是和===类似，所以计较严格，类型不一样也无法匹配。123456789switch(a)&#123; case 10:....&#125;switch(true)&#123; case a == &apos;10&apos;:....&#125;// 使用&amp;&amp; || 要小心，因为它返回的是值，不是布尔值","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"github博客域名绑定","date":"2019-04-13T07:58:59.000Z","path":"2019/04/13/github博客域名绑定/","text":"前言阿里云的域名就挺不错的，还有免费的 SSL，就是不稳定，而好的年费上千，而区其他的地方购买域名有点坑，可能解析不成功或感觉卡 BUG。 阿里云解析教程 问题跟着阿里云的域名解析后，打开 DNS 解析设置，添加记录，记录类型为 CNAME，因为 github 不支持子域设置顶级域，所以只能重定向这样的，让 github 博客地址重定向到自定义域名上 DNS 添加 打开 jithub 的博客仓库，然后再 setting 的域名地址。 git 这样就可以直接使用域名访问了，但访问地址是主机名+域名，不是 www+域名，如我的是 blog.gitzhangzhicheng.top 由于使用 hexo 博客，所以每次创建的 CNAME 都会被删除，那么就在 source 目录下创建 CNAME，那么每次提交到会把提交上，就不会出现覆盖不见的情况。","tags":[{"name":"github","slug":"github","permalink":"https://793338023.github.io/tags/github/"}]},{"title":"我所知的linux操作","date":"2019-04-05T13:27:59.000Z","path":"2019/04/05/我所知的linux操作/","text":"##前言作为一个开发者，有时工作久了，总要会一些不一样知识来填充自己，如我是一名前端开发，但前端的发展总要向后台靠拢，不是你无法知道怎么实现一个功能才能更符合逻辑，因为我们最后还是要和后台数据对接的或别的，而部署到服务器的项目，最后不会想windows那样使用，而是一种更加符合编码人员口味的linux，我们使用它打开文件，查看文件，安装等等，而对我们前端，最重要是查看，因为在一个BUG出现后终会看看是不是数据的问题，而这样就要查看日志了。 而我也只是使用过查看的功能，因为我没有权限。 cd命令 进入要目录cd 目录名或路径 进入”家”目录cd ~ 进入上一次工作路径cd - 进入根目录cd / 进入上层目录cd ../ pwd命令查看当前工作目录路径 查看当前路径pwd 查看软链接的实际路径pwd -P ls命令通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等,是目前很常使用的命令，因为进入目录后不知道有什么文件，可以使用它查询 参数: -a 列出目录所有文件，包含以.开始的隐藏文件 -A 列出除.及..的其它文件 -r 反序排列 -t 以文件修改时间排序 -S 以文件大小排序 -h 以易读大小显示 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 使用: 按易读方式按时间反序排序，并显示文件详细信息ls -lhrt 按大小反序显示文件详细信息ls -lrS 列出当前目录中所有以“t”开头的目录的详细内容ls -l t* 列出文件绝对路径（不包含隐藏文件）ls | sed “s:^:pwd/:” 列出文件绝对路径（包含隐藏文件）find $pwd -maxdepth 1 | xargs ls -ld 而我比较常用的是ls -lrt反序列出所有修改时间的文件信息，可以看到最新的文件在顶部 less命令使用 less 可以随意浏览文件，之前使用view浏览文件的，但view查看会以乱码无法查看 常用命令参数：-i 忽略搜索时的大小写-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-s 显示连续空行为一行/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）-x &lt;数字&gt; 将“tab”键显示为规定的数字空格b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页实例： ps查看进程信息并通过less分页显示ps -aux | less -N 查看多个文件less 1.log 2.log可以使用n查看下一个，使用p查看前一个 tail命令用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。而我是为了实时查看某个日志输出情况，而判断问题。 tail -f 查看日志文件 grep命令强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索 grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。 命令格式：grep [option] pattern file|dir grep参数实在太多了，请看grep资料 实例： 查找指定进程ps -ef | grep svn 查找指定进程个数ps -ef | grep svn -c 从文件中读取关键词cat test1.txt | grep -f key.log 从文件夹中递归查找以grep开头的行，并只列出文件grep -lR ‘^grep’ /tmp 查找非x开关的行内容grep ‘^[^x]’ test.txt 显示包含ed或者at字符的内容行grep -E ‘ed|at’ test.txt 而4例子是最常使用的，因为有时不知道文件在哪里。只能根据大概的文件夹，递归的寻找到文件 以上都是一些查看操作权限","tags":[{"name":"linux","slug":"linux","permalink":"https://793338023.github.io/tags/linux/"}]},{"title":"react与antDesign","date":"2019-04-02T14:37:05.000Z","path":"2019/04/02/react与antDesign/","text":"前言react的核心是数据与页面双向绑定，虚拟DOM，JSX，而react与vue差别在于react没有那么多的钩子函数，无指令，class方式编程，当然也可以函数式编程，如hooks，但主流还是class，在主观上react的操作需要构思一下数据结构与父子组件间的渲染优化，因为父组件渲染会触发子组件的钩子函数，并执行render，虽然虚拟DOM的diff算法，已经很大优化了渲染，但还是会出现父组件渲染导致子组件无必要渲染而导致页面卡顿现象，这就需要自己对不必要的数据控制不要渲染，如使用shouldComponentUpdate优化。 安装脚手架的安装运行12create-react-app my-appnpm run eject //弹出webpack 一定要弹出webpack，不是没法进行一些配置，且安装babel-plugin-import那么就可以进行babel的配置，而且不需要建立babel配置文件，在package.json里就可以进行，否则会报错，plugins的import配置多个时需要在数组的第三个标明名称如:12345678910&quot;plugins&quot;: [ [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; &#125;, &quot;antd&quot;], [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd-mobile&quot;, &quot;style&quot;: &quot;css&quot; &#125;,&quot;antd-mobile&quot;] ] 第三个参数没有会报错，如表明为antd或antd-mobile等。而style设置为css，若设置true，那么加载的antd就要是less文件，否则无法正常加载css文件。 react组件间使用的生命周期在不使用路由router的情况下，组件在当前路由一开始就constructor-&gt;componentWillMount-&gt;render-&gt;componentDidMount,而当页面没有被卸载情况下componentWillReceiveProps-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate，当组件被卸载componentWillUnmount。 由于子组件没有卸载，所以constructor、componentWillMount、componentDidMount不会再触发，而是触发更新操作流程，而想每次更新都重新加载组件，那么就是卸载组件如: 123456789101112import &#123;ChildCom&#125; from &apos;./ChildCom&apos;;class App extends Component &#123; render() &#123; const aaa = show?&lt;ChildCom /&gt;:null; return ( &lt;div className=&quot;App&quot;&gt; &#123;aaa&#125; &lt;/div&gt; ); &#125;&#125;// 当shou为false时卸载组件，为true加载组件，这样就可以实现卸载与加载 由于父组件的更新会触发子组件也触发更新操作，所以子组件的更新的钩子函数会去执行，而子组件自己的更新不会触发componentWillReceiveProps钩子函数。 antd与antdDesign的表单校验antd里有自己的一套完善的表单校验规则，根据API使用，而使用时需要Form与Form.Item包着，这样就可以使用getFieldDecorator函数给需要校验的组件进行双向绑定，然后进行表单的校验，而组件必须有value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性),而且传入的组件不需要声明value与onChange，它内部就实现好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from &apos;react&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; setItem, setItemContent &#125; from &apos;../../redux/itemReduce&apos;;import &#123; List, InputItem &#125; from &apos;antd-mobile&apos;;import &#123;Form&#125; from &apos;antd&apos;;class ItemTwo extends Component &#123; constructor(props) &#123; super(props); this.state=&#123;name:&quot;zhang&quot;&#125;; &#125; componentDidMount() &#123; // 全部进行校验，回调校验结果并触发页面的校验规则 this.props.form.validateFields((err, values) =&gt; &#123; if (!err) &#123; console.log(&apos;Received values of form: &apos;, values); &#125; &#125;); &#125; componentDidUpdate()&#123; // isFieldTouched判断一个输入控件是否经历过 getFieldDecorator 的值收集时机 options.trigger // getFieldError获取某个输入控件的 Error const &#123; isFieldTouched,getFieldError,getFieldsValue, validateFields &#125; = this.props.form; const childPhoneError = isFieldTouched(&apos;childPhone&apos;) &amp;&amp; getFieldError(&apos;childPhone&apos;); &#125; render() &#123; const &#123; getFieldDecorator &#125; = this.props.form; return ( &lt;div className=&apos;itemOne&apos;&gt; &lt;Form&gt; &lt;Form.Item&gt; &#123;getFieldDecorator(&apos;childPhone&apos;,&#123; rules: [&#123; required: true, message: &apos;手机号必填!&apos; &#125;] &#125;)( &lt;InputItem &gt;子手机号&lt;/InputItem&gt; )&#125; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = state=&gt;&#123; return state.itemRedux; &#125; const mapDispatchToProps = &#123;setItem, setItemContent&#125;; export default connect(mapStateToProps, mapDispatchToProps)(Form.create(&#123; name:&quot;itemTwo&quot;, // 具体表单进行与父组件或redux，的props属性关联起来 mapPropsToFields(props)&#123; return &#123; childPhone:Form.createFormField(&#123; value: props.phone &#125;) &#125; &#125;, // 当 Form.Item 子节点的值发生改变时触发，可以把对应的值转存到 Redux store onFieldsChange(props, fields)&#123; console.log(props); &#125;, // 任一表单域的值发生改变时的回调 onValuesChange(props, changedValues, allValues)&#123; console.log(props.form.getFieldError) //console.log(changedValues); &#125;&#125;)(ItemTwo)); 这里只是一部分，还有很多校验方法，如自定义校验，自定义校验方法等等。","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"git的协同开发使用","date":"2019-03-27T14:57:17.000Z","path":"2019/03/27/git的协同开发使用/","text":"前言在团队开发中，难免要合并代码，代码冲突，检查代码之类的，而选择一个版本维护工具是首选项，这会影响以后在代码上的把控，而我使用过svn与git，然后在体验上发现git在这方面是做的最好的，它强大的分支功能和离线状态可使用，让后期工作效率更高，在代码上更方便，而svn在这方面就很吃力，代码的合并与检查都需要人为的操作，如需要代码清单，代码比对工具等人为的检查合并代码，真心浪费时间。 协同流程不同公司，协同的方式有可能不一样。而我们的流程是: 首先fork远程源的仓库到自己的远程仓库 使用git clone 把项目克隆到自己的本地 1git clone 远程仓库地址 修改项目代码后检查状态，添加本地，提交本地 1234567891011121314151617181920212223242526// 直接从主分支提交到远程的主分支上git status // 查状态git add . // 添加所以修改或git add 修改文件 // 可文件夹，多个文件用空格隔开git commit -m &quot;修改信息&quot; // 提交到本地仓库git remote -v // 检查关联的远程仓库，找到提交的远程仓库名称git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; // 提交到远程仓库如: 关联的远程仓库有: myDemo、gsgit push myDemo master本地的主分支推送到myDemo远程仓库里// 从创建分支提交到远程的创建分支，然后请求合并，最后合并到主分支master上git checkout -b fz // fz为分支名，这是创建分支并切换到创建分支上git status // 查看状态git diff 文件 // 根据状态查看文件，然后比较是否为需要提交的代码git add 文件... // 根据状态查看文件，添加文件到暂缓区git commit -m &quot;描述&quot; // 提交暂缓区到当前分支的本地仓库上 git branch // 查看所有分支，并确认分支名git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; // 提交到远程仓库// 到远程仓库中提出合并请求git checkout master // 切换到主分支git merge fz // 合并分支到主分支git push &lt;远程主机名&gt; master // 把合并修改提交远程仓库的主分支上，为了同步，因为自己仓库需要自己维护，所以本地合并后提交到远程master 推到自己的远程仓库后向fork源提出合并请求 123点击pull request合并请求填写请求描述 当项目已经存在，每次提交需要拉取一份远程源地址代码然后diff比较不同，查看是否冲突，然后合并到本地代码，再进行提交，推送 123456789101112131415161718git remote add 代码源地址名称taregt 代码源地址 // 添加远程仓库关联git fetch git fetch taregt master:temp // 从远程的taregt仓库的master分支下载到本地并新建一个分支tempgit diff temp // 比较本地的仓库和远程仓库的拉取到本地分支对比git merge temp // 合并temp分支到master分支git branch -d temp // 删除temp分支// 快速拉取，拉取是会自动合并，但有冲突就会提示，然后等冲突解决后合并，如使用git stash储藏可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用git pull &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;// 回退版本，reset回退只是指针的回退到指定版本，然后重这个版本开始git reset --hard 目标版本号或HEAD^上一个版本// revert的作用通过反做创建一个新的版本,是把回退的版本做成一个新的版本，可以保留该目标版本后面的版本git revert -n 版本号// 都可以使用git log 查看版本信息// 重新操作、添加、提交、推送、pull request 进行代码贡献 拉取团队代码操作流程: 12345678910111213141516// 在项目拉取团队开发的代码时，一般有两种保存自己代码方式，为了的是不给拉取代码覆盖// 1. 创建分支，把代码从分支提交到本地分支里，等拉取完后，看情况merge合并分支代码到master里，这样就不会覆盖自己开发的代码，当然在merge时可以使用diff指令查看不同的地方，是否需要调整的git checkout -b 分支名git add .git commit -m &quot;描述&quot;git checkout mastergit pull 远程主机 mastergit diff 分支名git merge 分支名// 2. stash到储存起来，把修改的代码存起来，然后拉取代码git stashgit pull 远程主机 mastergit stash show -p // 查看拉取代码与存起来的代码的不同地方git stash apply // 应用储存的代码，这样就可以实现不被拉取代码覆盖 使用例子2觉得比较好，因为不会在log里存在提交日志，而且也不要创建分支合并分支删除分支等操作，就简单的存起来，然后释放就可以了，其实就就是把修改的代码保存起来，然后工作区的代码还原为当前版本的代码，拉取远程仓库代码带当前版本的代码里，最后应用存起来的代码就是覆盖到当前拉取的代码，就是一个这样的操作，所以有必要git stash show -p查看不同点，然后进行调整。 stash资料 更多git的学习 流程图12345678910111213141516st=&gt;start: 开始op1=&gt;operation: fork源项目op2=&gt;operation: add添加本地op3=&gt;operation: commit提交本地opt4=&gt;operation: 推送自己远程仓库opt5=&gt;operation: pull requestopt6=&gt;operation: remote add 添加远程源仓库opt7=&gt;operation: clone克隆到本地opt8=&gt;operation: fetch拉取到本地仓库的新分支opt9=&gt;operation: diff比较主与支代码opt10=&gt;operation: 合并代码，删除分支cond=&gt;condition: 是否为初创项目?e=&gt;end: 结束st-&gt;condcond(yes)-&gt;op1-&gt;opt7-&gt;opt6-&gt;op2-&gt;op3-&gt;opt4-&gt;opt5-&gt;econd(no)-&gt;opt8-&gt;opt9-&gt;opt10-&gt;op2","tags":[{"name":"git","slug":"git","permalink":"https://793338023.github.io/tags/git/"}]},{"title":"react的setState","date":"2019-03-25T15:12:10.000Z","path":"2019/03/25/react的setState/","text":"前言React通过管理状态实现对组件的管理，通过this.setState()方法更新state，触发render()方法重新渲染页面，而在更新前有一个shouldComponentUpdate可以控制state更新是否触发render，方便不必要的渲染，而state里最好放入与渲染有关的属性，而渲染无关的使用class的属性对象保存使用即可。 12345678910111213141516class Demo extends Component&#123; constructor(props)&#123; super(props); this.state = &#123;name:\"zhang\"&#125;; // state this.objState = &#123;currPage:0&#125;; // 不必要渲染的对象使用 &#125; changePage()&#123; this.objState.currPage++; &#125; render()&#123; return ( &lt;div&gt;&#123;this.state.name&#125;&lt;/div&gt; ) &#125;&#125; state注意事项1、使用state是要遵循react的规则，state是不可变的，需要使用特定的函数更新state，如state在constructor定义后不能对它直接进行赋值操作，而是要使用setState，否则不会触发渲染render，而是直接修改了state，在下次使用setState后直接覆盖掉。 123456789101112131415161718class Demo extends Component&#123; constructor(props)&#123; super(props); this.state = &#123;name:\"zhang\"&#125;; // state this.objState = &#123;currPage:0&#125;; // 不必要渲染的对象使用 &#125; changePage=()=&gt;&#123; // 这是错误的操作 this.state.name = \"测试\"; // 正确操作 this.setState(&#123;name: \"ceshi\"&#125;); &#125; render()&#123; return ( &lt;div onClick=&#123;changePage&#125;&gt;&#123;this.state.name&#125;&lt;/div&gt; ) &#125;&#125; 2、setState是异步的由于react的setState的源码里，会先把state的更新推进队列里，等所有的state都进入后才会进行render的渲染操作，而所以在setState后不要直接获取state的数据，因为那些还是旧数据，而是要等调用栈结束后执行渲染操作再获取更新后state，但shouldComponentUpdate与componentWillUpdate接受的参数是更新后state，所以这些在渲染前的钩子函数可以在接收参数里获取更新的state与props,而setState的异步是代码执行顺序实现的，代码里都是同步的。 但由于setState在一般的调用时都会放到任务队列里，而把setState的使用放在setTimeout这些异步调用的回调函数里时不会放到任务队列里，而是直接调用，所以在setTimeout这些回调函数里可以直接获取到更新的state。 123456789101112131415161718192021222324252627282930313233343536class ItemOne extends Component &#123; constructor(props) &#123; super(props); this.state=&#123;name:\"zhang\"&#125;; &#125; change=()=&gt;&#123; this.setState(&#123;name:\"vvv\"&#125;); setTimeout(()=&gt;&#123; this.setState(&#123;name:\"xxx\"&#125;); console.log(\"time:\"+this.state.name); // xxx &#125;,0) &#125; shouldComponentUpdate(props, state)&#123; console.log(this.state.name) return true; &#125; componentWillUpdate(props, state)&#123; console.log(state); console.log(this.state.name); &#125; componentDidUpdate()&#123; console.log(this.state.name) &#125; render() &#123; return ( &lt;div className='itemOne'&gt; &lt;div onClick=&#123;this.change&#125;&gt;&#123;this.state.name&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;// 打印// zhang// &#123;name: \"vvv\"&#125;// zhang// vvv 3、不要在shouldComponentUpdate与componentWillUpdate使用在shouldComponentUpdate与componentWillUpdate使用setState会造成死循环，所以浏览器都会在控制台报错。 12// 报错信息Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops. 4、不涉及渲染state由于state的更新都会触发render渲染，而有些状态是不需要触发渲染的，那么可以使用一些普通对象保存，而不是使用state管理，因为state与普通对象的差别在于会触发页面的渲染。 123456789101112131415class Demo extends Component&#123; constructor(props)&#123; super(props); this.state = &#123;name:\"zhang\"&#125;; // state this.objState = &#123;currPage:0&#125;; // 不必要渲染的对象使用 &#125; changePage=()=&gt;&#123; this.objState.currPage++; &#125; render()&#123; return ( &lt;div onClick=&#123;changePage&#125;&gt;&#123;this.state.name&#125;&lt;/div&gt; ) &#125;&#125; 5、componentWillReceiveProps当一个组件从父组件接受参数；只要父组件的render函数被重新执行了，子组件的这个生命周期就会被执行；（如果这个组件第一次存在于父组件中，不会执行，如果这个组件之前存在于父组件中，才会执行）所以无论props使用更新，只要父组件渲染了那么就会触发这个函数","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"react与后端通讯和react高阶组件","date":"2019-03-19T13:27:40.000Z","path":"2019/03/19/react与后端通讯和react高阶组件/","text":"react与后端通讯react组件当只考虑使用react组件与后端进行通讯时，一般在componentDidMount钩子函数里实现请求即可，componentDidMount是render渲染后触发，在这里可以进行DOM之类的操作。而react不带请求方法，需要引入插件，而使用JQ这类的有点冗余，而axios插件流行，且灵活度高，而且返回的结果为Promise，便于操作。 12npm isntall axios --save 请求例子:123456789componentDidMount()&#123; axios.get('请求URL') .then(function (response) &#123; // response.data返回数据 &#125;) .catch(function (error) &#123; // 捕获异常，如reject之类的 &#125;) &#125; axios的拦截器可以对请求装饰，如添加token，添加遮罩或处理一些公共的信息，如错误码跳转等，这些可以让项目更容易维护。 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; redux当项目很复杂时需要使用redux进行数据的集中分发时那么数据的来源都是从redux里来，而这样前端与后端的通讯就要在redux里进行。但redux的数据进行传送过程时同步的，那么就需要中间件转为异步操作，而redux的强大又体出来了，redux适配性很高，只要给它加个合适的中间件，即可方便使用。 1npm install --save redux-thunk redux-thunk在Redux的action对象被reducer函数处理之前，插入异步功能。redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装。 1234567891011121314151617181920212223242526272829import &#123;createStore, applyMiddleware&#125; from 'redux';import thunk from 'redux-thunk';function count(state = 0, action) &#123; switch (action.type) &#123; case 'ADD': return state + 1; case 'REDUCER': return state - 1; default: return state; &#125;&#125;const store = createStore(count,applyMiddleware(thunk));//action创建函数function addIfOdd() &#123; return (dispatch, getState) =&gt; &#123; const currentValue = getState(); if (currentValue % 2 == 0) &#123; return false; &#125; dispatch(&#123; type: 'ADD' &#125;) &#125;&#125; 高阶组件高阶组件用于增强现有组件组件，好比装饰器模式一样。简单来说，一个高阶组件就是一个函数，这个函数接受一个组件作为输入，然后返回一个新的组件作为结果，而且，返回的新组件拥有了输入组件所不具有的功能。 而高阶组件的实现有两种方式，代理方式与继承方式。 代理方式代理方式就是以组件为参数传入返回一个新的组件。代理方式的高阶组件，可以应用在下列场景中：1、操纵 prop;2、访问 ref;3、抽取状态；4、包装组件。12345678910111213const newComponent = (Component, newProps)=&gt;&#123; return calss Wrapper extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;Component &#123;...this.props&#125; &#123;...newProps&#125; /&gt; ); &#125; &#125;&#125; 继承方式继承方式的高阶组件采用继承关系关联作为参数的组件和返回的组件，假如传入的组件参数是 WrappedComponent，那么返回的组件就直接继承自 WrappedComponent。 继承方式的高阶组件可以应用于下列场景：1、操纵 prop;2、操纵生命周期函数。 而继承方式改变prop是很麻烦的，需要使用React.cloneElement复制一份组件并修改prop值。123456789const modyComponent = (WrappedComponent)=&gt;&#123; return class NewComponent extends WrappedComponent&#123; render()&#123; const elem = super.render(); const newProps = &#123;...this.props, style: &#123;color: 'red'&#125;&#125;; return React.cloneElement(elem, newProps, elem.props.children); &#125; &#125;&#125; 从上面例子的比较可以看出来，各方面看来代理方式都要优于继承方式。 以函数为子组件由于以上的高阶组件都有一个问题就是嵌套加深，都要在组件外包囊一层，而且固化prop，无法达到预期的灵活要求，而以函数为子组件就可以解决这个问题。以函数为子组件其实就是在使用this.props.children获取嵌套在组件内的函数，然后传参调用返回组件。 弊端就是每次使用都要创建一个函数。 1234567891011121314151617181920calss Wrapper extend Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; childFn = this.props.children(this.props); return childFn; &#125; &#125;// 一定要是函数Wrapper.propTypes = &#123; children: React.PropTypes.func.isRequired&#125;// 使用&lt;Wrapper&gt;&#123;(aa)=&gt;&lt;div&gt;&#123;aa&#125;&lt;/div&gt;&#125;&lt;/Wrapper&gt;","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"redux运用","date":"2019-03-16T04:06:31.000Z","path":"2019/03/16/redux运用/","text":"redux 的概念Redux 是 Flux 的另一种实现，也可以说进步，在以前基本都是使用 MVC 开发模式，然而这个模式没有限制住广大开发者们，因为他只是一个开发模式，没有边界限制，只能自己按照 MVC 的开发模式规范去做，至于是否真的按照规范做，这就不能约束了，所以会出现 M 与 V 直接对话，而没有让 C 起到作用，或者一些别的，使得 MVC 模式下开发混乱，还有就是 Model 和 View 之间缠绕着蜘蛛网一样复杂的依赖关系，让人难以维护。而 Redux 出现可以说把这个模式加上了约束条件，不让开发者为了方便跳过 C 等操作，一定遵循 Action-&gt;Dispatcher-&gt;Store-&gt;view-&gt;Action，这个流程循环执行。 Dispatcher:处理动作分发，维持 Store 之间的依赖关系；Store:负责存储数据和处理数据相关逻辑；Action:驱动 Dispatcher 的 JavaScript 对象；View:视图部分，负责显示用户界面。 如果把 redux 和 MVC 做一个结构对比，那么，redux 的 Dispatcher 相当于 MVC 的 Controller,redux 的 Store 相当于 MVC 的 Model,redux 的 View 是 react 组件 对应 MVC 的 View 了，至于多出来的这个 Action，可以理解为对应给 MVC 框架的用户请求。 Redux 的基本原则1231、唯一数据源2、保持状态只读3、数据改变只能通过纯函数完成 唯一数据源唯一数据源指的是应用的状态数据应该只存储在唯一的一个 Store 上。虽然我们经常会按功能把 store 分成多个文件进行管理，但最后我们还是会把 store 合并成一个 Store。 保持状态只读保持状态只读，就是说不能去直接修改状态，要修改 Store 的状态，必须要通过派发一个 action 对象完成。 数据改变只能通过纯函数完成这里所说的纯函数就是 Reducer，reducer(state , action)第一个参数 state 是当前的状态，第二个参数 action 是接收到的 action 对象，而 reducer 函数要做的事情，就是根据 state 和 action 的值产生一个新的对象返回，注意 reducer 必须是纯函数，也就是说函数的返回结果必须完全由参数 state 和 action 决定，而且不产生任何副作用，也不能修改参数 state 和 action 对象。 react-redux由于 redux 可以通用其他的地方，所以它的灵活性高，使用中间件连接 react 与 redux,免除一些配置，如 react-redux 最主要的两个功能是 connect 与 Provider。 connectconnect 有两个参数 mapStateToProps、mapDispatchToProps，就是把 redux 的 Store 变成组件的 props 与把 action 方法变成组件的 props，方便组件内部调用。connect 的实现就是给组件嵌套一层容器组件，然后让容器组件向内部的组件传递 props，既容器组件与傻瓜组件的概念。 mapStateToProps、mapDispatchToProps 函数都接受两个参数，第二参数都是为自身拥有的 props，mapStateToProps 第一个参数为 Store，返回的对象为转化为 props 的值，mapDispatchToProps 第一参数为 dispatch 派发器，既 action 怎么触发派发函数，而 mapDispatchToProps 可以直接为一个字面量对象，那么就可以把 action 包装为一个派发函数，只要触发它即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';import &#123; Link &#125; from 'react-router-dom';import &#123;connect&#125; from 'react-redux';import &#123;setItem, setItemContent&#125; from '../../redux/itemReduce';import ItemOne from '../ItemOne/';class Item extends Component &#123; constructor(props)&#123; super(props); this.state = &#123;&#125;; this.setName = this.setName.bind(this); &#125; componentDidMount()&#123; console.log(this.props); &#125; setName(ev)&#123; let val = ev.target.value; // 触发action this.props.setItem(&#123;itemName: val&#125;); &#125; render() &#123; return ( &lt;div className='item'&gt; &lt;p&gt;item 欢迎光临&lt;/p&gt; &lt;Link to='/'&gt;跳转home&lt;/Link&gt; &lt;input type='text' onInput=&#123;this.setName&#125;/&gt; &lt;div&gt; &lt;ItemOne /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = state=&gt;&#123; return state.itemRedux;&#125;// setItem,setItemContent是action方法const mapDispatchToProps = &#123;setItem, setItemContent&#125;;export default connect(mapStateToProps, mapDispatchToProps)(Item); ProviderProvider 组件，可以让容器组件拿到 state。Provider 在根组件一般在根组件的上一层包着，App 的所有子组件就默认都可以拿到 state 了。而它的原理就是使用 context，store 放在了上下文对象 context 上面,然后，子组件就可以从 context 拿到 store。 1234567891011121314151617181920212223242526// react-redux、redux-thunk、redux配合使用的写法基本是固定的，除非有特殊要求import React from 'react';import ReactDOM from 'react-dom';import './index.css';import * as serviceWorker from './serviceWorker';import router from './router.js';import &#123;createStore, applyMiddleware, compose&#125; from 'redux'import thunk from 'redux-thunk'import &#123; Provider &#125; from 'react-redux'import reducers from './reduces'// compose是增强store的，如浏览器插件redux监听store数据，添加中间件，如redux-thunk解决异步问题const store = createStore(reducers, compose(applyMiddleware(thunk), window.devToolsExtension?window.devToolsExtension():f=&gt;f))ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &#123;router()&#125; &lt;/Provider&gt;, document.getElementById('root'));serviceWorker.unregister(); 由于 Store 只有一个，如果数据冗余，那么会很占内存且结构复杂，而宁愿牺牲一些性能，进行一些运算达到获取目标结果，也比存储起来好。还有数据的扁平化，由于使用 Store 把数据嵌套过深，会让数据的修改与获取加大难度，这样最好是数据的扁平化，那么就可以减少没有必要的非空判断，默认赋值之类的操作。 12345// 若嵌套深时获取数据const d = state.A &amp;&amp; state.A.B &amp;&amp; state.A.B.C &amp;&amp; state.A.B.C.D ;//而扁平化const d = state.A; 而 redux 的 Store 只有一个，但我们需要模块化的开发，那么就是需要把多个 Store 合并成一个，就要使用 combineReducers。 1234567891011import &#123;combineReducers&#125; from 'redux';import &#123;home&#125; from './redux/homeReduce';import &#123;item&#125; from './redux/itemReduce';let comReduces = &#123; homeRedux: home, itemRedux: item&#125;;export default combineReducers(comReduces); 而合并后 Store 的对应模块的键值为对象的键值，如 homeRedux 下 Store，为 homeRedux。","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"react运用","date":"2019-03-15T14:57:28.000Z","path":"2019/03/15/react运用/","text":"react 的安装由于 react 的需要依赖一些的技术栈才能方便进行正常的开发，但这对学习它的成本会提高很多，如要需要会 webpack、gulp、Babel 等模块与构建工具，这样在没有开始就倒在了入门路上，而这些配置一般都可以是固定的，而使用脚手架，一行代码即可。 但 react 脚手架过于复杂，对初学者来说，没有特殊要求可以不修改配置之类，不过一旦涉及这方面需求就懵逼了，因为 react 脚手架是 node 写的，webpack 只是它的一部分，也是核心部分，所以有 webpack 初步经验，为了更好的了解可以选择自己搭建。 1234567891011121314// 安装全局的create-react-appnpm install --g create-react-app// 在指定目录创建react项目create-react-app 项目名// 进入项目cd 项目名// 启动项目npm start// 对webpack进行操作，执行就无法逆转，如果有必要备份一份npm run eject JSXJSX 是 JavaScript 的扩展语言，让 HTML 可以在 js 里编写，但使用模块一定要引入 react,而一般自定义的组件元素首字母都是大写，而这样区别 html 与 react 组件，而在 HTML 中大量的绑定事件是不规范的。原因有以下:2、如 onclick 添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意料不到的后果；3、给很多 DOM 元素添加 onclick 事件，可能会影响网页的性能，毕竟，网页需要的事件处理函数越多，性能就会越低；4、对于使用 onclick 的 DOM 元素，如果要动态地从 DOM 树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的 bug 很难被发现。 而以上的原因都是针对复杂的项目或单页面项目。 但 JSX 没有这方面的缺点，首先，如 onClick 挂载的每个函数，都可以控制在组件范围内，不会污染全局空间。我们在 JSX 中看到一个组件使用了 onClick，但并没有产生直接使用 onclick 的 HTML，而是使用了事件委托的方式处理点击事件，无论有多少个 onClick 出现，其实最后都只在 DOM 树上添加了一个事件处理函数，挂在最顶层的 DOM 节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定函数，使用事件委托的性能要比为每个 onClick 都挂载一个事件处理函数要高。 React 控制了组件的生命周期，在 unmount 的时候自然能够清除相关的所有事件处理函数，内存泄露也不再是一个问题。 在使用 jsx 时，添加类名要使用 className,因为 class 是保留关键字，使用 js 的保留关键字一般使用报错的，但如果习惯使用 class 可以添加相对的兼容包。 React 与 JQuery 区别JQuery 操作是选中一些 DOM 元素，然后对这些元素做一些操作，而在大项目中频繁的选择各种各样的元素，而一种元素有不同选择方式，使得项目很复杂，难以维护。React 操作就只注重数据怎么操作，而界面对数据进行渲染，而无需关心怎么选择元素操作。既重要的是区分开哪些属于 data，哪些属于 render，想要更新用户界面，要做的就是更新 data，用户界面自然会做出响应。 而 React 渲染都不是整体渲染的，React 利用 Virtual DOM，让每次渲染都只重新渲染最少的 DOM 元素。Web 前端开发关于性能优化有一个原则尽量减少 DOM 操作。虽然 DOM 操作也只是一些简单的 JavaScript 语句，但是 DOM 操作会引起浏览器对网页进行重新布局，重新绘制，这就是一个比 JavaScript 语句执行慢很多的过程。Virutal DOM 不会触及浏览器的部分，只是存在于内存空间的树形结构，每次自上而下渲染 React 组件时，会对比这一次产生的 Virtual DOM 和上一次渲染的 Virtual DOM ，对比就会发现差别，然后修改真正的 DOM 树时就只需要触及差别中的部分就行。所以 react 的渲染基本是达到最优渲染，比人为的操作 DOM 省心多了。 React 组件的数据React 组件的数据分为两种，props 和 state，无论 props 或者 state 的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用 prop?什么时候选择用 state 呢?其实原则很简单，props 是组件的对外接口，state 是组件的内部状态，对外用 props，内部用 state。 props在 React 中，props 是从外部传递给组件的数据，一个 React 组件通过定义自己能够接受的 props 就定义了自己的对外公共接口。每个 React 组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过 props 来和组件对话的。 123456789101112131415// 给prop赋值&lt;Demo test=&#123;100&#125; /&gt;// 读取propsclass Demo extends Component &#123; constructor(props)&#123; super(props); &#125; render()&#123; let &#123;test&#125; = this.props; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; ); &#125;&#125; 但由于是对外公布的接口，那么传入时应该有自己的一套规则，如前端与后端人员对接时后端人员都会对自己的接口，公布一份接口文档，方便人员的对接，而不是让对接人员自己猜想传什么字段，才能正常使用接口，而 props 就需要这样做，使用propTypes规范接口，让使用组件的人员一目了然，知道组件需要什么字段。 而 propTypes 是一种限制，会在运行时与静态代码时检查代码。 12345678910111213141516171819class Demo extends Component &#123; constructor(props)&#123; super(props); &#125; render()&#123; let &#123;test&#125; = this.props; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; ); &#125;&#125;// test字符串并必须传入Demo.propTypes = &#123; test: PropTypes.string.isRequired&#125;// 如何没有传入，浏览器的控制台会报错，但不影响运行 但由于 props 不一定都要传入，这样可以使用 defaultProps 设置默认值。 12345678910111213141516171819202122232425262728293031323334class Demo extends Component &#123; constructor(props)&#123; super(props); &#125; render()&#123; let &#123;test&#125; = this.props; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; ); &#125;&#125;Demo.defaultProps = &#123; test: '测试'&#125;或class Demo extends Component &#123; static defaultProps&#123; test: '测试' &#125; constructor(props)&#123; super(props); &#125; render()&#123; let &#123;test&#125; = this.props; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; ); &#125;&#125;如果你是使用typescript编写的项目，那么就可以不使用propTypes，typescript特性就是静态类型检查。 state由于 React 组件不能修改传入的 props，所以需要记录自身数据变化，就要使用 state。 1234567891011121314class Demo extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; test: props.test &#125; &#125; render()&#123; let &#123;test&#125; = this.state; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; ); &#125;&#125; 但 state 的修改需要使用特定函数，this.setState()进行修改，才能触发 view 与 data 的同步更新，若直接对 this.state 对象进行赋值操作，是不会触发的，但对象里的值是发生了改变，只是没有更新视图，当触发 this.setState()会把变化更新，所以修改一定要使用 this.setState。 123456789101112131415161718192021class Demo extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; test: props.test &#125; this.changeFn = this.changeFn.bind(this); &#125; changeFn(event)&#123; this.setState(&#123;test: event.target.value&#125;); &#125; render()&#123; let &#123;test&#125; = this.state; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; &lt;input value=&#123;test&#125; onChange=&#123;changeFn&#125; type='text' /&gt; ); &#125;&#125; 组件生命周期React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：装载过程，也就是把组件第一次在 DOM 树中渲染的过程；更新过程，当组件被重新渲染的过程；卸载过程，组件从 DOM 中删除的过程。三种不同的过程，React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。 装载过程中会触发: 123456constructorgetlnitialStategetDefaultPropsstatic getDerivedStateFromPropsrendercomponentDidMount getlnitialState 与 getDefaultProps 在 React.createClass 中有效，在 ES6 中不能使用这个，所以一般都不使用。constructor，初始化的操作都会在这里进行，如 this.state，事件处理函数的 this 绑定等。render 函数无疑是 React 组件中最重要的函数，一个 React 组件可以忽略其他所有函数都不实现，但是一定要实现 render 函数，因为所有 React 组件的父类 React.Component 类对除 render 之外的生命周期函数都有默认实现。componentDidMount 是 render 函数执行后 DOM 加载出来才触发的，所以对操作 DOM 或数据请求都可以在这里进行。 getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容,但此方法无法访问组件实例，因为它是一个静态方法。 12345678910111213141516171819class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; email: props.email &#125;; &#125; static getDerivedStateFromProps(props, state) &#123; if (props.email !== state.email) &#123; return &#123; email: props.email &#125;; &#125; return null; &#125; render() &#123; &lt;div&gt; Email: &lt;input value=&#123;this.state.email&#125; /&gt; &lt;/div&gt; &#125;&#125; 更新过程会触发: 123456// 依次触发static getDerivedStateFromPropsshouldComponentUpdaterendergetSnapshotBeforeUpdatecomponentDidUpdate 1234567891011121314151617181920212223242526class Parent extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; test: \"aaa\" &#125; &#125; render()&#123; let &#123;test&#125; = this.state; return ( &lt;Child test=&#123;test&#125;/&gt; ); &#125;&#125;class Child extends Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; let &#123;test&#125; = this.props; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; ); &#125;&#125; shouldComponentUpdate 是对数据的改变是否触发 render 来更新视图的，对性能优化很重要，它决定了一个组件什么时候不需要渲染。当它返回 false 时不渲染，为 true 渲染，默认时都为 true 的。 123456789101112131415161718192021222324252627282930313233class Parent extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; test: \"aaa\" &#125; &#125; render()&#123; let &#123;test&#125; = this.state; return ( &lt;Child test=&#123;test&#125;/&gt; ); &#125;&#125;class Child extends Component&#123; constructor(props)&#123; super(props); &#125; shouldComponentUpdate(nextProps, nextState)&#123; &#123;test&#125; = nextProps; if(test === this.props.test)&#123; return false; &#125; return true; &#125; render()&#123; let &#123;test&#125; = this.props; return ( &lt;div&gt;&#123;test&#125;&lt;/div&gt; ); &#125;&#125; getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。 1234567891011121314151617181920212223242526272829303132class ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 我们是否在 list 中添加新的 items ? // 捕获滚动​​位置以便我们稍后调整滚动位置。 if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items， // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。 //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值） if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; componentDidUpdate 既渲染后的钩子函数。 卸载过程只涉及一个函数 componentWillUnmount，为了在组件被卸载进行一些操作，避免造成污染之类的，如内存溢出。 即将废弃的钩子123componentWillMountcomponentWillUpdatecomponentWillReceiveProps componentWillMount 组件初始化时会出现在 constructor 后 render 前。 componentWillUpdate 组件状态更新时会触发，在 render 之前。 componentWillReceiveProps 组件初始化不会触发，但父组件的状态更新就会触发。 由于 react 团队启用异步渲染方式，把一些长期被使用者不正当使用的生命周期钩子都准备弃用，以达到未来更新的版本更完善做准备。 资料 资料 2 例子项目","tags":[{"name":"react","slug":"react","permalink":"https://793338023.github.io/tags/react/"}]},{"title":"javascript事件循环","date":"2019-02-19T08:06:39.000Z","path":"2019/02/19/javascript事件循环-1/","text":"JavaScript 的事件循环简单了解一下浏览器的 js 事件循环，由于涉及到浏览器版本不一样结果不一样，既参考。 首先要理解一下: js 的执行分同步与异步 在执行 js 时首先执行整体代码的同步代码，然后异步代码处理完后会把回调函数放置到任务队列里等待执行栈执行完后，将任务队列的任务添加到执行栈里执行 事件循环是通过任务队列的机制进行协调的，一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。 任务队列的执行顺序又分为宏任务队列和微任务任务，微任务队列都在当前宏任务执行完毕之后立刻执行，然后才会执行浏览器的渲染。 js事件循环 宏任务宏任务可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。宏任务主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务微任务可以理解是在当前宏任务执行结束后立即执行的任务。也就是说，在当前宏任务任务后，下一个宏任务之前，在渲染之前。 所以它的响应速度相比 setTimeout（setTimeout 是宏任务）会更快，因为无需等渲染。也就是说，在某一个宏任务执行完后，就会将在它执行期间产生的所有微任务都执行完毕（在渲染前）。 微任务主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 运行机制 执行当前宏任务(当前宏任务从任务队列里获取) 在执行栈中遇到微任务，把它放置到微任务队列里，遇到宏任务把它放置宏任务队列 当前执行的宏任务结束，检查微任务队列，如果有任务，则有序的执行微任务，否则执行下一步 浏览器开始检查渲染，然后 GUI 线程接管渲染 渲染完毕后，js 线程接管，继续重第一步执行代码 运行机制 以下为测试: 1234567891011121314151617181920212223242526272829async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; //async2做出如下更改： new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2'); &#125;);&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise3'); resolve();&#125;).then(function() &#123; console.log('promise4');&#125;);console.log('script end'); 输出结果: 12345678script startasync1 startpromise1script endpromise2async1 endpromise4setTimeout","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"复杂vue路由","date":"2019-02-10T14:36:38.000Z","path":"2019/02/10/复杂vue路由/","text":"异步状态问题:异步状态会引入不确定性，代码执行结果的正确与否完全靠运气或者靠网速。而无法确定异步代码的执行阶段，在多个组件或代码块之间耦合情况下会出现代码执行错误情况，怎么办？ 为了应对各种各样的需求，我们在写任何存在异步任务的代码时，都要提前做好流程设计，要确保代码的运行是严格符合期望的。而大部分的需求都可以使用vue-router的这种方案解决掉，而这个方案无法解决的时候，那么就要清楚js的执行机制，那么就可以比较准确的知道什么时候执行那一块代码，具体如下:1、首先要列出所有需要异步操作的代码2、分析他们之间的依赖关系，以此决定请求的顺序3、根据这个顺序，并结合Vue组件的父子关系，决定这些异步代码的存放位置4、不断在脑海里过Vue的执行流程，不断完善代码，弥补纰漏5、最后要确保，在nextTick、setTimeout、ajax、Promise等交织在一起的代码里，自己能预测出任意位置代码的执行时机 vue-router在使用vue-router实现获取数据时有两种获取数据的方式。1、导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子(created\\mounted)中获取数据。在数据获取期间显示“加载中”之类的指示。2、导航完成之前获取：导航完成前，在路由进入的路由钩子(beforeRouteEnter\\beforeRouteUpdate\\beforeRouteLeave)中获取数据，在数据获取成功后执行导航。 beforeRouteEnter\\beforeRouteUpdate\\beforeRouteLeave钩子都是即将进入的路由组件里的编写，如从A页面进入B页面，那么钩子就在B页面的编写钩子，由于执行beforeRouteEnter时组件还有初始化，所以无法使用this，beforeRouteUpdate时组件被复用时调用的，如路由的方式为\\B\\:id，这种路由的组件是会被复用的，所以只会触发beforeRouteUpdate，而beforeRouteLeave是当前页面在离开是调用的，如何使用它制作是否确认离开的，而他们都是要调用next()，否则都无法进入路由。 beforeRouteEnter的next方法的回调可以获取到当前组件的this，可以使用它设置data。 12345678910111213141516171819beforeRouteEnter(to, from, next) &#123; axios(&#123; url: \"/api/v2/movie/subject/\" + to.params.id, method: \"get\" &#125;).then(rps =&gt; &#123; let data = rps.data; next(vm =&gt; &#123; vm.item = data; &#125;); &#125;);&#125;,beforeRouteUpdate(to, from, next) &#123; console.log(\"beforeRouteUpdate\"); next();&#125;,beforeRouteLeave(to, from, next) &#123; console.log(\"beforeRouteLeave\"); next();&#125; 路由缓存与scrollBehavior由于确保前进后退时回看自己之前的内容，而不是重新刷新，实现缓存功能。有时浏览一个内容后点击了页面的内容进入了下一个页面查看，但想回到之前的页面继续看，而不是后退后等待刷新后重新查看之前浏览的内容，但这个的实现就要keep-alive与scrollBehavior结合使用，但这个方案需要了解scrollBehavior的执行阶段，而scrollBehavior函数在组件的生命周期mounted后beforeUpdate前执行，所以要在route组件参数meta里先设置是否缓存的参数，然后v-if在router-view里显示是否缓存的组件。 12345 &lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.isKeepAlive\"/&gt; &lt;/keep-alive&gt; &lt;router-view v-if=\"!$route.meta.isKeepAlive\"/&gt;&lt;/div&gt; isKeepAlive是否缓存，先设置下一次路由到该页面后是否缓存。123456789101112131415161718192021222324252627282930313233343536373839import Vue from 'vue'import Router from 'vue-router'import hotShow from '@/views/hotShow'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'hotShow', component: hotShow, meta: &#123; isKeepAlive: true &#125; &#125;, &#123; path: '/product/:id', name: 'product', component: () =&gt; import('@/views/detail'), meta: &#123; isKeepAlive: true &#125; &#125; ], // 设置只缓存后退，当前进或进入后不缓存 scrollBehavior(to, from, savedPosition) &#123; if (savedPosition || typeof savedPosition === 'undefined') &#123; // 只处理设置了路由元信息的组件 from.meta.isKeepAlive = typeof from.meta.isKeepAlive === 'undefined' ? undefined : false to.meta.isKeepAlive = typeof to.meta.isKeepAlive === 'undefined' ? undefined : true if (savedPosition) &#123; return savedPosition; &#125; &#125; else &#123; from.meta.isKeepAlive = typeof from.meta.isKeepAlive === 'undefined' ? undefined : true to.meta.isKeepAlive = typeof to.meta.isKeepAlive === 'undefined' ? undefined : false &#125; &#125;&#125;) 测试过程问题12345报错:Cannot convert undefined or null to objectObject.keys()中传错了参数由于undefined和null无法转成对象，所以如果它们做为Object.assign()的参数（只有一个参数），也会报错 完整代码","tags":[{"name":"vue","slug":"vue","permalink":"https://793338023.github.io/tags/vue/"}]},{"title":"transform与matrix","date":"2019-02-06T04:57:54.000Z","path":"2019/02/06/transform与matrix/","text":"Transform的值大类transform 本质上来说是一系列的变形函数，主要有以下值：none - 不进行转换，常用作覆盖别的值使用translate(x,y) - 2d位移；translate3d(x,y,z) - 3d位移； transformX/Y/Z(n) - 单向位移scale(x,y) - 2d缩放； scale3d(x,y,z) - 3d缩放； scaleX/Y(n) - 单向缩放rotate(angle) - 2d旋转； rotate3d(x,y,z,angle) - 3d旋转；rotateX/Y/Z(angle) - 单向旋转skew(x-angle,y-angle) - 倾斜变换； skewX/Y(angle) - 单向倾斜变换matrix[3d] - 矩阵perspective(n) - 视距（值） Transform的前置属性transform-origin - 变换原点transform-style - 变换类型perspective - 3d透视视图的视距（属性）perspective-origin - 视距的基点backface-visibility - 是否可以看见背面 Transform特性1、如果是动画效果，translate能达到比1px更小的过渡效果，而position却不行，这就影响了用户体验。2、translate的动画效果能启用电脑GPU加速，分离图层，大大减少页面重绘模块，节省资源。3、position 的可拓展性不如 translate等。4、transform百分比的基准是被设置值的本身容器，而不是像margin等以父级为基准。5、3d效果需要使用在父级使用perspective，否则设置的值无效。 矩阵 - matrix线性代数里矩阵123456789|1 0 0||1 0 0||2 0 0|transform: matrix(a,b,c,d,e,f);|a b c||d e f||0 0 1| 当我们要做变换时，实质上就是对初始值添加一些系数，也就是:123|a c e| |x| |ax cy e||b d f| * |y| = |bx dy f||0 0 1| |1| |0 0 1| 而变化后的x与y坐标12x' = ax + cy + e // 即：x坐标y' = bx + dy + f // 即：y坐标 默认值:12matrix(1, 0, 0, 1, 0, 0)// 在默认基础上继续变化 平移123456matrix(a,b,c,d,e,f);// 只需要变换e,f即可，e为x，f为y// 如transform: matrix(1, 0, 0, 1, 10, 20);// x为10px,y为20px 缩放12345matrix(a,b,c,d,e,f);// 只需要变换a,d即可，a为x，d为y，既放大缩小多少倍，如果在是正常倍数，设置为1即可,否则图形会消失，如设置为0了// 如transform: matrix(2, 0, 0, 2, 0, 0);// x为2倍,y为2倍 旋转由于旋转需要使用到三角函数，cos与sin，而且matrix(a,b,c,d,e,f)中要使用都abcd。 1234'matrix('+Math.cos(x)+', '+Math.sin(x)+', -'+Math.sin(x)+', '+Math.cos(x)+', 0, 0)'// 三角函数的转换let x = 2 * Math.PI / 360 * angle; 例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;button @click='btnFn'&gt;开始&lt;/button&gt; &lt;div class=\"wrapper\"&gt; &lt;div ref=\"item\" class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; timer: null &#125; &#125;, mounted()&#123; &#125;, methods: &#123; transFn(angle = 0)&#123; let item = this.$refs.item; let x = 2 * Math.PI / 360 * angle; item.style.transform = 'matrix('+Math.cos(x)+', '+Math.sin(x)+', -'+Math.sin(x)+', '+Math.cos(x)+', 0, 0)'; &#125;, move(start, end)&#123; clearInterval(this.timer); this.timer = setInterval(()=&gt;&#123; this.transFn(start); if(start &gt;= end)&#123; clearInterval(this.timer); &#125;else&#123; start+= 2; &#125; &#125;, 100); &#125;, btnFn()&#123; this.move(0, 360); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.wrapper &#123; position: absolute; top: 50%; left: 50%; width: 500px; height: 500px; perspective: 100px; &#125;.item &#123; background-color: #42b983; width: 100px; height: 100px; transform: matrix(2, 0, 0, 2, 0, 0); transform-origin: 0 0 0;&#125;&lt;/style&gt; 拉伸由于旋转需要使用到三角函数，tan，而且matrix(a,b,c,d,e,f)中要使用都bc。 123456matrix(1,tan(θy),tan(θx),1,0,0)// 三角函数的转换let x = 2 * Math.PI / 360 * angle;let θ = Math.tan(x);// 30度transform: matrix(1, 0.5, 0.5, 1, 0, 0); 以上是对单种变换的matrix使用，若要多个一起使用就要按顺序使用上述的方法累加起来，所以在使用transform是变换使用都会根据使用的变换顺序不同而达到的结果不一样，因为它会根据前一个变换后的结果进行下一次的变换，如123transform: rotate(30deg) translate(10px, 20px);transform: translate(10px, 20px) rotate(30deg); 以上的数值都一致，但结果是不一样的。第一个为旋转后根据旋转的方向进行移动第二个为移动后再进行旋转 matrix 工具","tags":[{"name":"css3","slug":"css3","permalink":"https://793338023.github.io/tags/css3/"}]},{"title":"__proto__与prototype","date":"2019-02-01T07:36:01.000Z","path":"2019/02/01/proto-与prototype/","text":"proto在JavaScript里面，一切皆为对象，而对象(除了null)都有proto，这个属性会指向该对象的原型，即作为实例对象和实例原型的之间的链接桥梁。proto属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[[Prototype]]。所以直接使用它进行原型对象的操作是很不友好的，它的目的只是为了访问到原型对象里的属性。123let obj = &#123;a:'1'&#125;;console.log(obj.__proto__); prototypeprototype是函数特有属性，因为实现面向对象的编程方式，需要有类似继承等属性，而原型对象即可解决此类问题，且保存javascript的灵活多变的方式。函数上使用prototype，可proto变成合法的操作，而不单单只是一个访问器，可对其添加修改删除等，而在函数上proto与prototype是相等的，因为它们都指向同一个内存地址，但在实际上他们是不一样的，因为除了函数，其他对象都没有prototype属性。 123456function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); //true; ##构造函数、实例对象、原型对象1234567function Person()&#123;&#125;Person.prototype.getName = function()&#123; return 'proto';&#125;let per = new Person(); Person这个函数的prototype属性指向了一个对象,即:Person.prototype也是一个对象。这个对象正是调用该构造函数而创建的实例的原型。 既构造函数与原型对象、实例对象都是需要new一个实例对象时才能正确使用。 12341.调用的构造函数： Person2.使用什么调用： new关键字3.得到了什么： 实例化对象per4.实例化对象和原型是什么关系: per的原型就是 Person.prototype 而原型就是实例对象都共享原型上的属性，而原型对象包含proto对象，指向上层原型对象，当实例对象访问某个属性时，先查询对象本身所函数的属性是否存在该属性，否则访问原型对象上的属性，而当当前原型对象不含有，则通过proto对象访问上层原型对象属性，直到访问到该属性或proto指向的顶层对象Object后停止访问。","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"node-爬虫体验","date":"2019-01-30T13:41:56.000Z","path":"2019/01/30/node-爬虫体验/","text":"node-爬虫使用技术:express + crawler + request而crawler是集成了request+cheerio，由于某些方面crawler没有使用request那么方便，只是在爬虫上可以比request简单的实现爬虫，所以比较强大简单，而在node里比较流行，而node实现爬虫有些不够好，所以在这方面框架没有几个，不像python那么强大而且这方面的库很多，很专业，而node的使用后发现有些不太好，而且这方面都比较简单而粗略。 爬去电影天堂的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204let express = require('express');let router = express.Router();let Crawler = require('crawler');let fs = require('fs');let path = require('path');let request = require('request');let mkdirs = require('../util/mkdirs');let dataUrl = path.resolve(__dirname, '../../data');let root = 'https://www.dytt8.net';/* GET home page. */router.get('/', function(req, res, next) &#123; let c = new Crawler(&#123; // 在每个请求处理完毕后将调用此回调函数 callback : function (error, resData, done) &#123; if(error)&#123; console.log(error); res.render('index', &#123; title: '电影天堂', content: error &#125;); &#125;else&#123; var $ = resData.$; let $dataList = $(\".bd3r .co_content8 ul table\"); let paging = $(\".bd3r .co_content8 .x\"); let listData = []; // 分页处理 let sel = paging.find('select'); let maxLen = sel.children().length; let currPage = sel.find('[selected]').text(); $dataList.each((key, item)=&gt;&#123; let $a = $(item).find('a'); let dac = $(item).find('font').text(); let content = $(\":last-child\",item).find('td').text(); dac.match(/(\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; [\\d:]+)\\D*(\\d+)/); listData.push(&#123;\"name\": $a.text(), \"href\": root+$a.attr('href'), \"date\": RegExp.$1, \"clickNum\": RegExp.$2, \"content\": content &#125;); &#125;); createFs(currPage, listData); let listUrl = []; for(let i=2;i&lt;=maxLen;i++)&#123; listUrl.push(root+'/html/gndy/dyzz/list_23_'+i+'.html'); &#125; getPageNum(listUrl); res.render('index', &#123; title: '电影天堂', content: listData &#125;); &#125; done(); &#125; &#125;); // 将一个URL加入请求队列，并使用默认回调函数 c.queue(root+'/html/gndy/dyzz/list_23_1.html');&#125;);// 获取当前页的数据function getPageNum(listUrl)&#123; let c = new Crawler(&#123; // 在每个请求处理完毕后将调用此回调函数 callback : function (error, resData, done) &#123; if(error)&#123; console.log(error); &#125;else&#123; var $ = resData.$; let $dataList = $(\".bd3r .co_content8 ul table\"); let paging = $(\".bd3r .co_content8 .x\"); let listData = []; // 分页处理 let sel = paging.find('select'); let maxLen = sel.children().length; let currPage = sel.find('[selected]').text(); $dataList.each((key, item)=&gt;&#123; let $a = $(item).find('a'); let dac = $(item).find('font').text(); let content = $(\":last-child\",item).find('td').text(); dac.match(/(\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; [\\d:]+)\\D*(\\d+)/); listData.push(&#123;\"name\": $a.text(), \"href\": root+$a.attr('href'), \"date\": RegExp.$1, \"clickNum\": RegExp.$2, \"content\": content &#125;); &#125;); createFs(currPage, listData); &#125; done(); &#125;&#125;);// 将一个URL加入请求队列，并使用默认回调函数c.queue(listUrl);&#125;// 遍历当前页的条数async function createFs(page, content)&#123; let url = path.join(dataUrl,'./'+page); let file = path.join(url, './mkdir.json'); // 如果不存在创建目录，支持多层创建，异步 await mkdirs(url); await (()=&gt;&#123; let p = new Promise((resolve,reject)=&gt;&#123; fs.writeFile(file, JSON.stringify(content), (err)=&gt;&#123; if(err)&#123; resolve(false); console.log(err); &#125;else&#123; resolve(true); &#125; &#125;); &#125;); return p; &#125;)(); for(let item of content)&#123; detailContent(item, url); &#125;&#125;// 获取具体信息async function detailContent(item, rootUrl)&#123; let dirUrl = path.join(rootUrl,'./'+item.name.replace(/[\\\\\\/:*?\"&lt;&gt;|]/g,\"-\")); let file = path.join(dirUrl,'./detail.json'); await mkdirs(dirUrl); let c = new Crawler(&#123; callback(error, resData, done)&#123; if(error)&#123; console.log(error); &#125;else&#123; let data = &#123;&#125;; let $ = resData.$; let $content = $('.bd3r .co_area2'); let contentStr = $content.find('#Zoom p').eq(0).text(); let imgList = []; data.title = $content.find('.title_all font').text(); data.content = contentStr.substr(0,contentStr.indexOf('【下载地址】')); $content.find('#Zoom img').each(function(key, it)&#123; imgList.push($(it).attr('src')); &#125;); data.img = imgList; data.magnet = $content.find('[href^=\"magnet\"]').attr('href'); data.thunder = $content.find('[vkorgxpv]').attr('vkorgxpv'); fs.writeFile(file, JSON.stringify(data), err=&gt;&#123; if(err)&#123; console.log(err); &#125; &#125;); // getImg(JSON.stringify(imgList), dirUrl); &#125; done(); &#125; &#125;); c.queue(item.href);&#125;// 图片下载处理// 由于某些问题无法正确获取到图片,并且会报错而无法爬取下去function getImg(imgList, dirUrl)&#123; // var c = new Crawler(&#123; // encoding:null, // jQuery:false,// set false to suppress warning message. // callback:function(err, res, done)&#123; // if(err)&#123; // console.error(err.stack); // &#125;else&#123; // console.log(res.options.filename); // console.log(res.body); // fs.createWriteStream(res.options.filename).write(res.body); // &#125; // done(); // &#125; // &#125;); imgList = JSON.parse(imgList); imgList = imgList.map((item, key)=&gt;&#123; return &#123;uri: item, filename: path.join(dirUrl,\"./\"+key+\".jpg\")&#125;; &#125;); // c.queue(imgList); for(let ii = 0; ii&lt;imgList.length; ii++)&#123; if(!fs.existsSync(imgList[ii].filename))&#123; setTimeout(()=&gt;&#123; let options = &#123; url: imgList[ii].uri, headers: &#123; 'content-length': 1001976 &#125; &#125;; request(options).pipe(fs.createWriteStream(imgList[ii].filename)).on('close',function()&#123; console.log(\"关闭...\"+imgList[ii].filename); &#125;); &#125;,1000); &#125; &#125;&#125;module.exports = router; 在文字爬去方面一点问题都没有，但在图片方面都各种问题出现，而图片量大时不要使用pipe，会出现0k的图片，既空图片，而且要使用异步的形式下载图片，如使用bagpipe或async方法下载图片。 // 图片下载方式1234567891011request(&#123; url: imgUrl,// 请求链接 encoding:null&#125;, (err, response, body) =&gt; &#123; fs.writeFileSync( imgPath, // 保存本地地址 body, // 保存内容 &#123; encoding:'binary' &#125; ) github代码","tags":[{"name":"node","slug":"node","permalink":"https://793338023.github.io/tags/node/"}]},{"title":"webpack4-踩坑体验","date":"2019-01-25T03:40:08.000Z","path":"2019/01/25/webpack4-踩坑体验/","text":"webpack4webpack4与之前的版本差别很大，当webpack每个大版本的更新，都需要重新学习一下webpack的打包功能，因为每次的大版本更新带来的一连串的别的模块的跟随更新，而上下版本之前是不兼容的。 1、安装先安装node与npm。建议局部方式安装，因为webpack的版本更新很快，使用全局可能会出现不兼容的报错问题。12345678910// 创建项目文件夹npm init// 安装webpack与webpack-clicnpm webpack webpack-cli --save-dev// 创建webpack.config.js文件，使用webpack指令时会访问到这个webpack配置文件// 在package.json的scripts里添加webpack指令。如\"scripts\": &#123; \"start\": \"webpack\" &#125;// 在终端执行指令npm start 就会执行局部安装的webpack指令，实现简单的打包功能 2、babel安装而babel的更新也是很快的，所以之前安装babel的方式已经不符合了。 1234567891011121314cnpm install babel-cli babel-loader @babel/preset-env @babel/core --save-dev// .babelrc&#123; \"presets\": [ [\"@babel/preset-env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125; &#125;], ], \"plugins\": []&#125; 在.babelrc配置文件中，主要是对预设（presets）和插件（plugins）进行配置。presets 预设targets可以制定兼容浏览器版本，如果设置了browsers，那么就会覆盖targets原本对浏览器的限制配置。targets.node正对node版本进行编译modules通常都会设置为false，因为默认都是支持CommonJS规范，同时还有其他配置参数：”amd” | “umd” | “systemjs” | “commonjs”。123456789&#123; \"targets\": &#123; \"chrome\": 52, \"browsers\": [\"last 2 versions\", \"safari 7\"], \"node\":\"6.10\" &#125; \"modules\": false&#125; 3、webpack-dev-server热替换安装12345cnpm install webpack-dev-server --save-dev// 配置启动\"scripts\": &#123; \"dev\": \"webpack-dev-server\" &#125; 由于热替换的直接配置webpack.config.js里的devServer下，而不是通过CLI配置，所以如hot的配置需要在配置文件添加webpack.HotModuleReplacementPlugin插件，而CLI的配置会自动添加webpack.HotModuleReplacementPlugin。由于启动了热替换，为了在终端上更好的观察变化情况，需要添加webpack.HotModuleReplacementPlugin()插件。 123456789devServer: &#123; hot: true, compress: true &#125;---------------------------plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin()] 4、html-webpack-plugin自动注入使用过vue的一定都对它的开发环境下自动注入很好奇，为什么热替换下没有打包浏览器观察到的文件，而浏览器的开发者模式下观察到的文件与项目下文件不一样，而且项目下没有文件打包，这就是因为html-webpack-plugin与热替换的原因。 资料一资料二 以上资料已经把html-webpack-plugin的使用很详细的介绍了。 而自动注入而不生成文件的，是因为使用热替换的情况下，会把变化的文件放到热替换的开启的服务器容器里，既内存里，只会在浏览器体验到它的打包变化，实际文件是没有变化的，而html-webpack-plugin会把js文件插入html里面，那么实现以上的效果。 完整代码package.json12345678910111213141516171819202122&#123; \"name\": \"w4\", \"version\": \"1.0.0\", \"description\": \"webpack4\", \"main\": \"index.js\", \"scripts\": &#123; \"dev\": \"webpack-dev-server\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"@babel/core\": \"^7.0.0\", \"@babel/preset-env\": \"^7.3.1\", \"babel-cli\": \"^6.26.0\", \"babel-loader\": \"^8.0.5\", \"html-webpack-plugin\": \"^3.2.0\", \"path\": \"^0.12.7\", \"webpack\": \"^4.29.0\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\" &#125;&#125; webpack.config.js123456789101112131415161718192021222324252627282930313233343536const webpack = require('webpack');const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js' &#125;, output: &#123; filename: '[name].js' &#125;, devtool: 'cheap-module-eval-source-map', devServer: &#123; hot: true, compress: true &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /(node_modules|bower_components)/ &#125; ] &#125;, plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;) ]&#125; github代码 webpack4 12345678910111213// 使用babel报错Cannot read property 'bindings' of null是因为没有正常安装与配置解决:cnpm install babel-cli babel-loader @babel/preset-env @babel/core --save-dev&#123;\"presets\": [\"@babel/preset-env\"],\"plugins\": []&#125;还有由于使用babel转换要忽略这些文件exclude: /(node_modules|bower_components)/","tags":[{"name":"webpack","slug":"webpack","permalink":"https://793338023.github.io/tags/webpack/"}]},{"title":"css3的pointer-events","date":"2019-01-21T11:19:33.000Z","path":"2019/01/21/css3的pointer-events/","text":"pointer-eventsCSS属性 pointer-events 允许用户控制特定的图形元素在何时成为鼠标事件的 target。当未指定该属性时，SVG 内容表现如同 visiblePainted。除了指定元素不成为鼠标事件的目标，none 值还指示鼠标事件穿过该元素，并指向位于元素下面的元素。 而目前pointer-events 主要的用途还是穿透元素。如需要一个上层背景覆盖内容而增加页面的丰富性，但由于上层容器的层级比较高，导致无法触发下层的内容的事件，只是一件很不友好的行为，而使用了这个属性pointer-events:none，就可以达成穿透的效果。如使用canvas制作下雪的效果覆盖整个屏幕当成背景效果，或操作迭代的容器，当选中下层元素，可使用这个属性，当选回后设置为pointer-events:auto即可。 兼容性:IE 11+Firefox 3.6＋Chrome 4.0+Safari 6.0Opera 15.0iOS Safari 6.0Android Browser 2.1+Android Chrome 18.0+ 1234567891011121314151617&lt;div class='bg'&gt;&lt;/div&gt;&lt;div class='content'&gt; &lt;a href='wwww.baidu.com'&gt;百度&lt;/a&gt;&lt;/div&gt;&lt;style&gt;.bg&#123; position:fixed; top:0; bottom:0; left:0; right:0; background:rgba(0,0,0,.2); z-index:10000; pointer-events:none;&#125;&lt;/style&gt;","tags":[{"name":"css3","slug":"css3","permalink":"https://793338023.github.io/tags/css3/"}]},{"title":"vue骨架屏","date":"2019-01-17T11:00:14.000Z","path":"2019/01/17/vue骨架屏/","text":"webpack-targetwebpack可以为js的各种不同的宿主环境提供编译功能，为了能正确的进行编译，就需要开发人员在配置里面正确的进行配置。默认情况下，target的值是web，也就是为类浏览器的环境提供编译。123module.exports = &#123; target: 'node'&#125;; webpack-vue-ssr-webpack-plugin当您使用Webpack的按需代码分割功能（通过require.ensure或动态import）时，生成的服务器端捆绑包将包含多个单独的文件。此插件通过自动将这些文件打包到可传递到的单个JSON文件中来简化工作流程bundleRenderer。 node-writeFileSync同步，既当写入完成后才进行下一步，而且会把文件里的内容覆盖为新内容。12const fs = require('fs');fs.writeFileSync(filename, data, [options]) html-minifier作用:压缩的文件第一个参数String类型， 一段html代码第二个参数 options这里只列了几个常用的 removeComments 默认值false；是否去掉注释collapseWhitespace 默认值false；是否去掉空格minifyJS 默认值false；是否压缩html里的js（使用uglify-js进行的压缩）minifyCSS 默认值false；是否压缩html里的css（使用clean-css进行的压缩）1234html = htmlMinifier.minify(html, &#123; collapseWhitespace: true, minifyCSS: true,&#125;); vue-server-renderer用于 Vue2.0 的服务端渲染,既可以在node环境下把所需的内容写入html等目标文件里，实现服务器渲染功能。 插件方式会打包成json文件1234567const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')或const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')const plugin = new VueSSRServerPlugin(&#123; filename: 'my-server-bundle.json' // 自定义名称&#125;) createBundleRenderer使用预编译的应用程序包创建bundleRenderer。bundle参数可以是以下之一：生成的bundle文件（.js或.json）的绝对路径。文件路径必须以/开头由vue-ssr-webpack-plugin生成的束对象。12const &#123; createBundleRenderer &#125; = require('vue-server-renderer')const bundleRenderer = createBundleRenderer(serverBundle, &#123; /* options */ &#125;) renderToString将捆绑的应用程序复制到字符串。与renderer.renderToString相同的回调。可选的上下文对象将被传递到bundle的导出函数。123bundleRenderer.renderToString(&#123; url: '/' &#125;, (err, html) =&gt; &#123; // ...&#125;) 注意:该HTML必须包含, 这个createBundleRenderer函数把这行代码替换成HTML. 由于webpack3与webpack4的vue-loader的差别，webpack4可以使用vue-loader15以上，所以要安装插件VueLoaderPlugin，而vue-loader14既以下都不需要这个。 问题12345678Vue packages version mismatch:- vue@2.4.4- vue-template-compiler@2.5.13This may cause things to work incorrectly. Make sure to use the same version for both.If you are using vue-loader@&gt;=10.0, simply update vue-template-compiler.If you are using vue-loader@&lt;10.0 or vueify, re-installing vue-loader/vueify should bump vue-template-compiler to the latest. 解决:12出现这种错误之后可以使用命令，将vue的版本改成和vue-template-compiler的版本一致，使用命令npm install vue@2.5.13 --save，然后直接运行就可以了！ 完整代码config目录下建webpack.skeleton.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');const webpack = require('webpack');const nodeExternals = require('webpack-node-externals');const VueSSRServerPlugin = require('vue-server-renderer/server-plugin');module.exports = &#123; target: 'node', entry: &#123; skeleton: './src/skeleton/skeleton.entry.js', &#125;, output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: '/dist/', filename: '[name].js', libraryTarget: 'commonjs2', &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ 'vue-style-loader', 'css-loader', ], &#125;, &#123; test: /\\.vue$/, loader: 'vue-loader', &#125;, ], &#125;, externals: nodeExternals(&#123; whitelist: /\\.css$/, &#125;), resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js', &#125;, extensions: ['*', '.js', '.vue', '.json'], &#125;, plugins: [ new VueSSRServerPlugin(&#123; filename: 'skeleton.json', &#125;), ],&#125;; config目录下建skeleton.js12345678910111213141516171819202122232425262728const fs = require('fs');const &#123; resolve &#125; = require('path');const htmlMinifier = require('html-minifier');const createBundleRenderer = require('vue-server-renderer').createBundleRenderer;// 先把vue的模板文件index.html置换成标准的模板，防止骨架屏污染let tempData = fs.readFileSync(resolve(__dirname, '../temp.html'), 'utf-8');fs.writeFileSync(resolve(__dirname, '../index.html'), tempData, 'utf-8');console.log('模板注入完成');// 读取`skeleton.json`，以`index.html`为模板写入内容const renderer = createBundleRenderer(resolve(__dirname, '../dist/skeleton.json'), &#123; template: fs.readFileSync(resolve(__dirname, '../index.html'), 'utf-8'),&#125;);// 把上一步模板完成的内容写入（替换）`index.html`renderer.renderToString(&#123;&#125;, (err, html) =&gt; &#123; if (err) &#123; console.log(err); return; &#125; // 压缩文件 // html = htmlMinifier.minify(html, &#123; // collapseWhitespace: true, // minifyCSS: true, // &#125;); fs.writeFileSync(resolve(__dirname, '../index.html'), html, 'utf-8');&#125;);console.log('骨架屏注入完成'); 根目录(既index.html的目录)下建temp.index,而且从index.html复制到temp.index里，添加注释1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;title&gt;my-demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--vue-ssr-outlet--&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; src目录下建seleton文件夹，里面添加seleton.vue与seleton.entry.js文件seleton.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div class=\"skeleton page\"&gt; &lt;div class=\"skeleton-nav\"&gt;&lt;/div&gt; &lt;div class=\"skeleton-swiper\"&gt; &lt;div class=\"skeleton-swiper-item item-one\"&gt;&lt;/div&gt; &lt;div class=\"skeleton-swiper-item item-two\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;html,body,div&#123; margin:0; padding:0;&#125;.skeleton &#123; height: 100%; overflow: hidden; box-sizing: border-box; background: #fff;&#125;.skeleton-nav &#123; height: 54px; background: #eee; margin-bottom: 20px;&#125;.skeleton-swiper &#123; min-height:600px; max-width:1280px; margin:0 auto;&#125;.skeleton-swiper-item&#123; min-height: 600px; height:100%; background:#eee; border-radius:5px;&#125;.item-one&#123; width:20%; float:left;&#125;.item-two&#123; width:78%; float:right;&#125;&lt;/style&gt; seleton.entry.js123456789import Vue from 'vue';import Skeleton from './Skeleton.vue';export default new Vue(&#123; components: &#123; Skeleton, &#125;, template: '&lt;skeleton /&gt;',&#125;); github代码地址","tags":[{"name":"vue","slug":"vue","permalink":"https://793338023.github.io/tags/vue/"}]},{"title":"es6语法使用之大全","date":"2019-01-07T13:25:07.000Z","path":"2019/01/07/es6语法使用之大全/","text":"let与const声明let与const都是块级作用域，所以不能想var声明一样，没有变量声明提升。let是声明变量，const是常量声明，不能修改。12let a = 5;const b = 10; 块级作用域代替函数作用域1234567891011(function()&#123; // 函数作用域 var a = \"ccc\";&#125;)()console.log(a);// 块级作用域&#123; let b = 1000;&#125;console.log(b); 使用块级作用域就可以避免如循环后只能获取到最后一个值的情况。 箭头函数1234let arr = [1,2,3];arr.map((item, index)=&gt;&#123; return item+index;&#125;) 使用箭头函数可以简化代码，而且this的指向问题也出现了变化，箭头函数的this上下文环境为定义函数的环境，而普通函数的this上下文环境为调用对象决定的环境。如:12345678910111213141516171819let obj = &#123; a()&#123; setTimeout(()=&gt;&#123; console.log(this); &#125;) &#125;&#125;obj.a();// obj对象------------let obj = &#123; a()&#123; setTimeout(function()&#123; console.log(this); &#125;) &#125;&#125;obj.a();// window对象 所以需要注意像事件调用的函数与一些对调用环境决定this指向时不要使用箭头函数，不是会出现this指向错误，如:1doc.addEventListener((e)=&gt;&#123;console.log(this)&#125;); 这是错误的。 字符串模板模板字符串使用反引号 () 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\\）。 1234567let aa = \"abc cc\";let str =` 哈哈 $&#123;aa&#125; 一起走`;console.log(str); 带标签的模板字符串就是使用反引号 () 调用函数，然后传入多个参数，而第一个参数为把含有表达式的部分为分割点切割成多个值存放到数组里，后续的参数为表达式的第一个值、第二个值。。。依次传入，如:123456789101112let p = 'mike', age = 25;function temp(str, ...key)&#123; console.log(str); console.log(key); return str + key;&#125; let op = temp`that is $&#123;p&#125; is a $&#123;age&#125;`;// [\"that is \", \" is a \", \"\"]// ['mike', 25]` 解构结构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。 结构数组1234567891011let [a,b,c,d] = [1,2,3,4]let [v, ...k] = [0,1,2,3,4,'b']// 不完全解构let [a,b] = [7,8,9,1]// 深度解构let [[[a=',b='']='']='']=[[['g','v']],['c']]// 数组合并let arr1 = ['ss','rr','vvv'];let arr2 = ['ccc','kkk','hhh'];let cArr = [...arr1, ...arr2]; 解构对象123456789let &#123;a&#125; = &#123;a:1,b:2&#125;let &#123;a:&#123;b:&#123;c=''&#125;=''&#125;='',a&#125; = &#123;a:&#123;b:&#123;c:10&#125;&#125;&#125;// 对象合并let obj1 = &#123;p:\"vvv\",cc:\"ccc\"&#125;let obj2 = &#123;o:\"dddd\"&#125;let obj = &#123; ...obj1, ...obj2 &#125;// 变量重命名let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125; 对象解构，左边的变量名对应右边的键值名 增强的对象字面量12345678910let aa = 'ooo';let obj = &#123; aa&#125;;// 动态let tt = 'cc';let ff = 'rr';let obj = &#123; [tt+\"#\"+ff]: 'ccc'&#125; 数组的拓展方法1、keys123let arr = [\"a\", , \"c\"];console.log([...arr.keys()]);console.log(Object.keys(arr)); 2、entries12345678910let arr = ['r','p','c'];let itr = arr.entries();for(let a of itr)&#123; console.log(a);&#125;/*** [0, \"r\"]* [1, \"p\"]* [2, \"c\"]**/ 3、values123let arr = [\"a\", , \"c\"];console.log([...arr.values()]);console.log(Object.values(arr)); 4、includes123456789101112var array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: truevar pets = ['cat', 'dog', 'bat'];console.log(pets.includes('cat'));// expected output: trueconsole.log(pets.includes('at'));// expected output: false 5、find12345678var array1 = [5, 12, 8, 130, 44];var found = array1.find(function(element) &#123; return element &gt; 10;&#125;);console.log(found);// expected output: 12 6、findIndex12345678var array1 = [5, 12, 8, 130, 44];function findFirstLargeNumber(element) &#123; return element &gt; 13;&#125;console.log(array1.findIndex(findFirstLargeNumber));// expected output: 3 函数函数的默认值给函数参数设置默认值的意思是：当没有传参的时候 ，参数取设定的默认值，即传入值为undefined1234567function log(x, y = 'World')&#123; console.log(x, y);&#125;console.log('Hello'); // Hello Worldconsole.log('Hello', 'China'); // Hello Chinaconsole.log('Hello', null); // Hello null rest参数1234567function f(a, ...arr, b) &#123; // ...&#125; // 报错function f(a, b, ...arr) &#123; console.log(arr);&#125; f(\"c\",\"b\",\"d\",\"x\",\"c\");// [\"d\",\"x\",\"c\"] name属性12345var f = function () &#123;&#125;;// ES5f.name // \"\"// ES6f.name // \"f\" 对象函数简易写法123456789101112let obj = &#123; func()&#123; return 'xxxx'; &#125;&#125;等同于var obj = &#123; func: function()&#123; let cs = 'xx'; return cs; &#125;&#125; 双冒号运算符双冒号运算符用来取代 call, apply, bind 调用1234567obj::fun;// 等同于obj.bind(fun);obj::fun(...arguments);// 等同于obj.apply(fun, arguments); 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); Set 和 MapES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。123456789101112131415let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue']let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。1234567891011121314let map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;let map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; for..ofIterator遍历器，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。而Iterator为for..of提高消费，既可带有遍历器的对象都可被for…of遍历。 for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、Generator对象，以及字符串。123456789let map = new Map();map.set('a1','b') .set('v2','cr') .set('a3','br') .set('v4','cr');for(let [key, value] of map)&#123; console.log(key); console.log(value);&#125; import与exportimport语句用于导入由另一个模块导出的绑定。无论是否声明了 strict mode ，导入的模块都运行在严格模式下。在浏览器中， import语句只能在声明了type=”module”的script的标签中使用。此外还有一个类似函数的动态import()，它不需要依赖type=”module”的script标签。 1234567891011121314151617181920212223// 默认导入与命名导入一起导入// 第一个参数为默认导入，第二个命名导入import _,&#123;* as names&#125; from 'a.js';// 动态导入import('a.js').then((module)=&#123; // 对导入模块操作&#125;);或aynsc function func()&#123; let module = await import('a.js'); return module;&#125;export语句用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。``` bash// 不能使用var，let或const用于导出默认值export default。// 只能有一个默认的导出// 命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。export let a = &#123;\"a\":10&#125;;export let b = &#123;\"b\":10&#125;;let bb = 20;export default bb; Generators 生成器generator也是为了解决地狱回调问题的，本质还是各种回调。在某些时候也可以认为generator为es6中新定义的数据类型，这种数据类型和函数很像，每个函数只能返回一个结果，即只能return一次，如果在某些函数中没有看到return，其实质在函数结尾是存在一个隐藏的return undefined 的，而generator不同，可以返回多次 Generators生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。123456789101112131415function* gen(a)&#123; let b = 9 * (yield(10 + a)); let c = 100 - (yield(b / 2)); let d = c / 8; return d;&#125;let func = gen(20);console.log(func); // Generator &#123;_invoke: ƒ&#125;let ii = func.next(9); console.log(ii); // &#123;value: 30, done: false&#125;let ii2 = func.next(40); console.log(ii2); // &#123;value: 180, done: false&#125;let ii3 = func.next(5);console.log(ii3); // &#123;value: 11.875, done: true&#125; 当done不为false时可以继续调用next方法，而返回值为yield的结果值，而传入值会替换yield的部分继续走下去。如第一个next传入的值为9，而变量b = 9 * 9。 generator function 返回的,并且它符合可迭代协议和迭代器协议,所以可以被for…of遍历，而当遇到return后不会继续遍历，return值不会被返回出来。1234567891011121314function* gen()&#123; yield 10; yield 20; yield 30; yield 40; return 50; yield 100; &#125;for(let v of gen())&#123; console.log(v);&#125;// 10 20 30 40 return和throw在生成器中起到了终止的作用,迭代器it可以直接调用throw方法，传入的参数就是catch中的err，然后在调用it的next方法时，done已经被设置成true了，就是说生成器终止了。这个异常其实是在生成器内部产生的，只是我们没有捕获，所以继续往外抛了出来，如果在内部try-catch这个异常也是可以的：123456789101112131415var g = function* () &#123; while(true) &#123; yield; &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125; PromisePromise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。Promise 优缺点有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 123456789101112131415161718192021222324// 使用let p = new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve('success'); &#125;,1000);&#125;);p.then(d=&gt;&#123; console.log(d);&#125;,d=&gt;&#123; console.log(d);&#125;);// 链式使用p.then(d=&gt;&#123; console.log(d); return new Promise((resolve, reject)=&gt;&#123; resolve(100); &#125;);&#125;,d=&gt;&#123; console.log(d);&#125;).then(d=&gt;&#123; console.log(d);&#125;); 资料 Promise 的api 1、Promise.resolve()2、Promise.reject()3、Promise.prototype.then()4、Promise.prototype.catch()5、Promise.all() // 所有的都有完成，相当于 且6、Promise.race() // 完成一个即可，相当于 或7、Promise.resolve()的作用将现有对象转为Promise对象resolvedl;Promise.resolve(‘test’)==new Promise(resolve=&gt;resolve(‘test’))8、Promise.reject()也是返回一个Promise对象,状态为rejected；9、then方法上边已经做介绍，这里就不再介绍。10、catch():发生错误的回调函数。 ayncs与awaitasync await可以用更少的处理实现 Promise 和 Generators 所实现的异步处理,避免多层嵌套，是一种多个Promise同步的优雅的写法。 1234567891011121314151617181920212223let a = function ii(x)&#123; let p = new Promise((res, rej)=&gt;&#123; setTimeout(()=&gt;&#123; res('success '+x); &#125;,1000); &#125;); return p;&#125;async function ayn()&#123; let x = await a(\"zzc\"); console.log(x); let b = await a(x+\"zhi\"); console.log(b); let c = await a(b+\"sss\"); console.log(c); let d = await a(c+\"xx\"); return d;&#125;ayn().then(d=&gt;&#123; console.log(d);&#125;); classES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。123456789101112131415161718192021222324252627// 使用class Abc&#123; constructor()&#123; this.a = 'abc'; &#125; getA()&#123; return this.a; &#125; setA(a)&#123; this.a = a; &#125;&#125;let abcx = new Abc();console.log(abcx.getA()); // abc// 继承class Ext extends Abc&#123; constructor()&#123; super(); super.getA(); &#125; getSA()&#123; return this.a; &#125;&#125;let abcx = new Ext();console.log(abcx.getA()); // abc 继承时一定要调用super(),因为需要初始化父类，把父类的this指向子类的this，若不调用会报错。而父类的方法的使用可以使用super。 后续会持续更新…","tags":[{"name":"js","slug":"js","permalink":"https://793338023.github.io/tags/js/"}]},{"title":"github博客网站构建","date":"2018-12-27T13:17:49.000Z","path":"2018/12/27/github博客网站构建/","text":"前言之前一直打算使用github搭建自己的博客地址，而且看起来还不错的，但ssh的问题一直都提交不成功，一度不放弃了很多次，但在最后还是成功了。前面的构建可以参考 ssh问题解决1、首先我得重新在git设置一下身份的名字和邮箱（因为当初都忘了设置啥了，因为遇到坑了）进入到需要提交的文件夹底下（因为直接打开git Bash，在没有路径的情况下，根本没！法！改！刚使用git时遇到的坑。。。）1git config --global user.name \"yourname\"· 1git config --global user.email“your@email.com\" 1注：yourname是你要设置的名字，your@email是你要设置的邮箱。 2、删除.ssh文件夹（直接搜索该文件夹）下的known_hosts(手动删除即可，不需要git）3、git输入命令 1$ ssh-keygen -t rsa -C \"your@email.com\"（请填你设置的邮箱地址） 123456接着出现：Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):请直接按下回车然后系统会自动在.ssh文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub将全部的内容复制 注意输入完ssh-keygen这个后出现的都回车，不要输入东西。那么就可以出现在git中输入命令：ssh -T git@github.com然后会跳出一堆话。。输入命令：yes不是没有yes这个命令输入，并且也无法提交。 资料","tags":[{"name":"github","slug":"github","permalink":"https://793338023.github.io/tags/github/"}]}]